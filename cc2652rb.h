/*
 *
 *
 *
 */
#ifndef cc2652rb_H_
#define cc2652rb_H_

//
// are these correct?
//
#define __CM4_REV                 0x0001            /*!< Cortex-M4 Core Revision                                               */
#define __MPU_PRESENT                  1            /*!< MPU present or not                                                    */
#define __NVIC_PRIO_BITS               3            /*!< Number of Bits used for Priority Levels                               */
#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
#define __FPU_PRESENT                  1            /*!< FPU present or not                                                    */


#ifndef __HW_INTS_H__
#define __HW_INTS_H__

//*****************************************************************************
//
// The following are defines for the interrupt assignments.
//
//*****************************************************************************
#define INT_NMI_FAULT                    2 // NMI Fault
#define INT_HARD_FAULT                   3 // Hard Fault
#define INT_MEMMANAGE_FAULT              4 // Memory Management (MemManage)
                                           // Fault
#define INT_BUS_FAULT                    5 // Bus Fault
#define INT_USAGE_FAULT                  6 // Usage Fault
#define INT_SVCALL                      11 // Supervisor Call (SVCall)
#define INT_DEBUG                       12 // Debug Monitor
#define INT_PENDSV                      14 // Pending Service Call (PendSV)
#define INT_SYSTICK                     15 // SysTick Interrupt from the
                                           // System Timer in NVIC.
#define INT_AON_GPIO_EDGE               16 // Edge detect event from IOC
#define INT_I2C_IRQ                     17 // Interrupt event from I2C
#define INT_RFC_CPE_1                   18 // Combined Interrupt for CPE
                                           // Generated events
#define INT_PKA_IRQ                     19 // PKA Interrupt event
#define INT_AON_RTC_COMB                20 // Event from AON_RTC
#define INT_UART0_COMB                  21 // UART0 combined interrupt
#define INT_AUX_SWEV0                   22 // AUX software event 0
#define INT_SSI0_COMB                   23 // SSI0 combined interrupt
#define INT_SSI1_COMB                   24 // SSI1 combined interrupt
#define INT_RFC_CPE_0                   25 // Combined Interrupt for CPE
                                           // Generated events
#define INT_RFC_HW_COMB                 26 // Combined RFC hardware interrupt
#define INT_RFC_CMD_ACK                 27 // RFC Doorbell Command
                                           // Acknowledgement Interrupt
#define INT_I2S_IRQ                     28 // Interrupt event from I2S
#define INT_AUX_SWEV1                   29 // AUX software event 1
#define INT_WDT_IRQ                     30 // Watchdog interrupt event
#define INT_GPT0A                       31 // GPT0A interrupt event
#define INT_GPT0B                       32 // GPT0B interrupt event
#define INT_GPT1A                       33 // GPT1A interrupt event
#define INT_GPT1B                       34 // GPT1B interrupt event
#define INT_GPT2A                       35 // GPT2A interrupt event
#define INT_GPT2B                       36 // GPT2B interrupt event
#define INT_GPT3A                       37 // GPT3A interrupt event
#define INT_GPT3B                       38 // GPT3B interrupt event
#define INT_CRYPTO_RESULT_AVAIL_IRQ     39 // CRYPTO result available interupt
                                           // event
#define INT_DMA_DONE_COMB               40 // Combined DMA done
#define INT_DMA_ERR                     41 // DMA bus error
#define INT_FLASH                       42 // FLASH controller error event
#define INT_SWEV0                       43 // Software event 0
#define INT_AUX_COMB                    44 // AUX combined event
#define INT_AON_PROG0                   45 // AON programmable event 0
#define INT_PROG0                       46 // Programmable Interrupt 0
#define INT_AUX_COMPA                   47 // AUX Compare A event
#define INT_AUX_ADC_IRQ                 48 // AUX ADC interrupt event
#define INT_TRNG_IRQ                    49 // TRNG Interrupt event
#define INT_OSC_COMB                    50 // Combined event from Oscillator
                                           // control
#define INT_AUX_TIMER2_EV0              51 // AUX Timer2 event 0
#define INT_UART1_COMB                  52 // UART1 combined interrupt
#define INT_BATMON_COMB                 53 // Combined event from battery
                                           // monitor

#define CMSIS_IRQn(N)	((int32_t)(N) - 16)

//*****************************************************************************
//
// The following are defines for number of interrupts and priority levels.
//
//*****************************************************************************
#define NUM_INTERRUPTS							54 // Number of interrupts
#define NUM_PRIORITY_BITS						3 // Number of Priority bits
#define NUM_PRIORITY								8 // Number of priority levels

#define HIGHEST_INTERRUPT_PRIORITY			0
#define HIGH_INTERRUPT_PRIORITY				1
#define NORMAL_INTERRUPT_PRIORITY			2
#define LOW_INTERRUPT_PRIORITY				3
#define LOWEST_INTERRUPT_PRIORITY			7
#define EVENT_LOOP_INTERRUPT_PRIORITY		LOWEST_INTERRUPT_PRIORITY


//*****************************************************************************
//
// Aliases for backwards compatibility with Sensor Controller Studio 1.1.0
//
//*****************************************************************************

#define INT_AON_AUX_SWEV0    INT_AUX_SWEV0
#define INT_AON_AUX_SWEV1    INT_AUX_SWEV1

#endif /* __HW_INTS_H__ */

#ifndef __HW_MEMMAP_H__
#define __HW_MEMMAP_H__

//*****************************************************************************
//
// The following are defines for the base address of the memories and
// peripherals on the CPU_MMAP interface
//
//*****************************************************************************
#define FLASHMEM_BASE           0x00000000 // FLASHMEM
#define BROM_BASE               0x10000000 // BROM
#define GPRAM_BASE              0x11000000 // GPRAM
#define SRAM_BASE               0x20000000 // SRAM
#define RFC_RAM_BASE            0x21000000 // RFC_RAM
#define RFC_ULLRAM_BASE         0x21004000 // RFC_ULLRAM
#define SSI0_BASE               0x40000000 // SSI
#define UART0_BASE              0x40001000 // UART
#define I2C0_BASE               0x40002000 // I2C
#define SSI1_BASE               0x40008000 // SSI
#define UART1_BASE              0x4000B000 // UART
#define GPT0_BASE               0x40010000 // GPT
#define GPT1_BASE               0x40011000 // GPT
#define GPT2_BASE               0x40012000 // GPT
#define GPT3_BASE               0x40013000 // GPT
#define UDMA0_BASE              0x40020000 // UDMA
#define I2S0_BASE               0x40021000 // I2S
#define GPIO_BASE               0x40022000 // GPIO
#define CRYPTO_BASE             0x40024000 // CRYPTO
#define PKA_BASE                0x40025000 // PKA
#define PKA_RAM_BASE            0x40026000 // PKA_RAM
#define PKA_INT_BASE            0x40027000 // PKA_INT
#define TRNG_BASE               0x40028000 // TRNG
#define FLASH_BASE              0x40030000 // FLASH
#define VIMS_BASE               0x40034000 // VIMS
#define SRAM_MMR_BASE           0x40035000 // SRAM_MMR
#define RFC_PWR_BASE            0x40040000 // RFC_PWR
#define RFC_DBELL_BASE          0x40041000 // RFC_DBELL
#define RFC_RAT_BASE            0x40043000 // RFC_RAT
#define RFC_FSCA_BASE           0x40044000 // RFC_FSCA
#define WDT_BASE                0x40080000 // WDT
#define IOC_BASE                0x40081000 // IOC
#define PRCM_BASE               0x40082000 // PRCM
#define EVENT_BASE              0x40083000 // EVENT
#define SMPH_BASE               0x40084000 // SMPH
#define ADI2_BASE               0x40086000 // ADI
#define ADI3_BASE               0x40086200 // ADI
#define AON_PMCTL_BASE          0x40090000 // AON_PMCTL
#define AON_RTC_BASE            0x40092000 // AON_RTC
#define AON_EVENT_BASE          0x40093000 // AON_EVENT
#define AON_IOC_BASE            0x40094000 // AON_IOC
#define AON_BATMON_BASE         0x40095000 // AON_BATMON
#define AUX_SPIM_BASE           0x400C1000 // AUX_SPIM
#define AUX_MAC_BASE            0x400C2000 // AUX_MAC
#define AUX_TIMER2_BASE         0x400C3000 // AUX_TIMER2
#define AUX_TDC_BASE            0x400C4000 // AUX_TDC
#define AUX_EVCTL_BASE          0x400C5000 // AUX_EVCTL
#define AUX_SYSIF_BASE          0x400C6000 // AUX_SYSIF
#define AUX_TIMER01_BASE        0x400C7000 // AUX_TIMER01
#define AUX_SMPH_BASE           0x400C8000 // AUX_SMPH
#define AUX_ANAIF_BASE          0x400C9000 // AUX_ANAIF
#define AUX_DDI0_OSC_BASE       0x400CA000 // DDI
#define AUX_ADI4_BASE           0x400CB000 // ADI
#define AUX_AIODIO0_BASE        0x400CC000 // AUX_AIODIO
#define AUX_AIODIO1_BASE        0x400CD000 // AUX_AIODIO
#define AUX_AIODIO2_BASE        0x400CE000 // AUX_AIODIO
#define AUX_AIODIO3_BASE        0x400CF000 // AUX_AIODIO
#define AUX_RAM_BASE            0x400E0000 // AUX_RAM
#define AUX_SCE_BASE            0x400E1000 // AUX_SCE
#define FLASH_CFG_BASE          0x50000000 // CC26_DUMMY_COMP
#define FCFG1_BASE              0x50001000 // FCFG1
#define FCFG2_BASE              0x50002000 // FCFG2
#ifndef CCFG_BASE
#define CCFG_BASE               0x50003000 // CCFG
#endif
#define CCFG_BASE_DEFAULT       0x50003000 // CCFG
#define SSI0_NONBUF_BASE        0x60000000 // SSI CPU nonbuf base
#define UART0_NONBUF_BASE       0x60001000 // UART CPU nonbuf base
#define I2C0_NONBUF_BASE        0x60002000 // I2C CPU nonbuf base
#define SSI1_NONBUF_BASE        0x60008000 // SSI CPU nonbuf base
#define UART1_NONBUF_BASE       0x6000B000 // UART CPU nonbuf base
#define GPT0_NONBUF_BASE        0x60010000 // GPT CPU nonbuf base
#define GPT1_NONBUF_BASE        0x60011000 // GPT CPU nonbuf base
#define GPT2_NONBUF_BASE        0x60012000 // GPT CPU nonbuf base
#define GPT3_NONBUF_BASE        0x60013000 // GPT CPU nonbuf base
#define UDMA0_NONBUF_BASE       0x60020000 // UDMA CPU nonbuf base
#define I2S0_NONBUF_BASE        0x60021000 // I2S CPU nonbuf base
#define GPIO_NONBUF_BASE        0x60022000 // GPIO CPU nonbuf base
#define CRYPTO_NONBUF_BASE      0x60024000 // CRYPTO CPU nonbuf base
#define PKA_NONBUF_BASE         0x60025000 // PKA CPU nonbuf base
#define PKA_RAM_NONBUF_BASE     0x60026000 // PKA_RAM CPU nonbuf base
#define PKA_INT_NONBUF_BASE     0x60027000 // PKA_INT CPU nonbuf base
#define TRNG_NONBUF_BASE        0x60028000 // TRNG CPU nonbuf base
#define FLASH_NONBUF_BASE       0x60030000 // FLASH CPU nonbuf base
#define VIMS_NONBUF_BASE        0x60034000 // VIMS CPU nonbuf base
#define SRAM_MMR_NONBUF_BASE    0x60035000 // SRAM_MMR CPU nonbuf base
#define RFC_PWR_NONBUF_BASE     0x60040000 // RFC_PWR CPU nonbuf base
#define RFC_DBELL_NONBUF_BASE   0x60041000 // RFC_DBELL CPU nonbuf base
#define RFC_RAT_NONBUF_BASE     0x60043000 // RFC_RAT CPU nonbuf base
#define RFC_FSCA_NONBUF_BASE    0x60044000 // RFC_FSCA CPU nonbuf base
#define WDT_NONBUF_BASE         0x60080000 // WDT CPU nonbuf base
#define IOC_NONBUF_BASE         0x60081000 // IOC CPU nonbuf base
#define PRCM_NONBUF_BASE        0x60082000 // PRCM CPU nonbuf base
#define EVENT_NONBUF_BASE       0x60083000 // EVENT CPU nonbuf base
#define SMPH_NONBUF_BASE        0x60084000 // SMPH CPU nonbuf base
#define ADI2_NONBUF_BASE        0x60086000 // ADI CPU nonbuf base
#define ADI3_NONBUF_BASE        0x60086200 // ADI CPU nonbuf base
#define AON_PMCTL_NONBUF_BASE   0x60090000 // AON_PMCTL CPU nonbuf base
#define AON_RTC_NONBUF_BASE     0x60092000 // AON_RTC CPU nonbuf base
#define AON_EVENT_NONBUF_BASE   0x60093000 // AON_EVENT CPU nonbuf base
#define AON_IOC_NONBUF_BASE     0x60094000 // AON_IOC CPU nonbuf base
#define AON_BATMON_NONBUF_BASE  0x60095000 // AON_BATMON CPU nonbuf base
#define AUX_SPIM_NONBUF_BASE    0x600C1000 // AUX_SPIM CPU nonbuf base
#define AUX_MAC_NONBUF_BASE     0x600C2000 // AUX_MAC CPU nonbuf base
#define AUX_TIMER2_NONBUF_BASE  0x600C3000 // AUX_TIMER2 CPU nonbuf base
#define AUX_TDC_NONBUF_BASE     0x600C4000 // AUX_TDC CPU nonbuf base
#define AUX_EVCTL_NONBUF_BASE   0x600C5000 // AUX_EVCTL CPU nonbuf base
#define AUX_SYSIF_NONBUF_BASE   0x600C6000 // AUX_SYSIF CPU nonbuf base
#define AUX_TIMER01_NONBUF_BASE \
                                0x600C7000 // AUX_TIMER01 CPU nonbuf base
#define AUX_SMPH_NONBUF_BASE    0x600C8000 // AUX_SMPH CPU nonbuf base
#define AUX_ANAIF_NONBUF_BASE   0x600C9000 // AUX_ANAIF CPU nonbuf base
#define AUX_DDI0_OSC_NONBUF_BASE \
                                0x600CA000 // DDI CPU nonbuf base
#define AUX_ADI4_NONBUF_BASE    0x600CB000 // ADI CPU nonbuf base
#define AUX_AIODIO0_NONBUF_BASE \
                                0x600CC000 // AUX_AIODIO CPU nonbuf base
#define AUX_AIODIO1_NONBUF_BASE \
                                0x600CD000 // AUX_AIODIO CPU nonbuf base
#define AUX_AIODIO2_NONBUF_BASE \
                                0x600CE000 // AUX_AIODIO CPU nonbuf base
#define AUX_AIODIO3_NONBUF_BASE \
                                0x600CF000 // AUX_AIODIO CPU nonbuf base
#define AUX_RAM_NONBUF_BASE     0x600E0000 // AUX_RAM CPU nonbuf base
#define AUX_SCE_NONBUF_BASE     0x600E1000 // AUX_SCE CPU nonbuf base
#define FLASHMEM_ALIAS_BASE     0xA0000000 // FLASHMEM Alias base
#define CPU_ITM_BASE            0xE0000000 // CPU_ITM
#define CPU_DWT_BASE            0xE0001000 // CPU_DWT
#define CPU_FPB_BASE            0xE0002000 // CPU_FPB
#define CPU_SCS_BASE            0xE000E000 // CPU_SCS
#define CPU_TPIU_BASE           0xE0040000 // CPU_TPIU
#define CPU_TIPROP_BASE         0xE00FE000 // CPU_TIPROP
#define CPU_ROM_TABLE_BASE      0xE00FF000 // CPU_ROM_TABLE

#endif // __HW_MEMMAP__


#ifndef __GPIO_H__
#define __GPIO_H__

//*****************************************************************************
//
// The following values define the bit field for the GPIO DIOs.
//
//*****************************************************************************
#define GPIO_DIO_0_MASK         0x00000001  // GPIO DIO 0 mask
#define GPIO_DIO_1_MASK         0x00000002  // GPIO DIO 1 mask
#define GPIO_DIO_2_MASK         0x00000004  // GPIO DIO 2 mask
#define GPIO_DIO_3_MASK         0x00000008  // GPIO DIO 3 mask
#define GPIO_DIO_4_MASK         0x00000010  // GPIO DIO 4 mask
#define GPIO_DIO_5_MASK         0x00000020  // GPIO DIO 5 mask
#define GPIO_DIO_6_MASK         0x00000040  // GPIO DIO 6 mask
#define GPIO_DIO_7_MASK         0x00000080  // GPIO DIO 7 mask
#define GPIO_DIO_8_MASK         0x00000100  // GPIO DIO 8 mask
#define GPIO_DIO_9_MASK         0x00000200  // GPIO DIO 9 mask
#define GPIO_DIO_10_MASK        0x00000400  // GPIO DIO 10 mask
#define GPIO_DIO_11_MASK        0x00000800  // GPIO DIO 11 mask
#define GPIO_DIO_12_MASK        0x00001000  // GPIO DIO 12 mask
#define GPIO_DIO_13_MASK        0x00002000  // GPIO DIO 13 mask
#define GPIO_DIO_14_MASK        0x00004000  // GPIO DIO 14 mask
#define GPIO_DIO_15_MASK        0x00008000  // GPIO DIO 15 mask
#define GPIO_DIO_16_MASK        0x00010000  // GPIO DIO 16 mask
#define GPIO_DIO_17_MASK        0x00020000  // GPIO DIO 17 mask
#define GPIO_DIO_18_MASK        0x00040000  // GPIO DIO 18 mask
#define GPIO_DIO_19_MASK        0x00080000  // GPIO DIO 19 mask
#define GPIO_DIO_20_MASK        0x00100000  // GPIO DIO 20 mask
#define GPIO_DIO_21_MASK        0x00200000  // GPIO DIO 21 mask
#define GPIO_DIO_22_MASK        0x00400000  // GPIO DIO 22 mask
#define GPIO_DIO_23_MASK        0x00800000  // GPIO DIO 23 mask
#define GPIO_DIO_24_MASK        0x01000000  // GPIO DIO 24 mask
#define GPIO_DIO_25_MASK        0x02000000  // GPIO DIO 25 mask
#define GPIO_DIO_26_MASK        0x04000000  // GPIO DIO 26 mask
#define GPIO_DIO_27_MASK        0x08000000  // GPIO DIO 27 mask
#define GPIO_DIO_28_MASK        0x10000000  // GPIO DIO 28 mask
#define GPIO_DIO_29_MASK        0x20000000  // GPIO DIO 29 mask
#define GPIO_DIO_30_MASK        0x40000000  // GPIO DIO 30 mask
#define GPIO_DIO_31_MASK        0x80000000  // GPIO DIO 31 mask
#define GPIO_DIO_ALL_MASK       0xFFFFFFFF  // GPIO all DIOs mask

//*****************************************************************************
//
// Define constants that shall be passed as the outputEnableValue parameter to
// GPIO_setOutputEnableDio() and will be returned from the function
// GPIO_getOutputEnableDio().
//
//*****************************************************************************
#define GPIO_OUTPUT_DISABLE     0x00000000  // DIO output is disabled
#define GPIO_OUTPUT_ENABLE      0x00000001  // DIO output is enabled

#endif // __GPIO_H__

#ifndef __HW_GPIO_H__
#define __HW_GPIO_H__

//*****************************************************************************
//
// This section defines the register offsets of
// GPIO component
//
//*****************************************************************************
// Data Out 0 to 3
#define GPIO_O_DOUT3_0                                              0x00000000

// Data Out 4 to 7
#define GPIO_O_DOUT7_4                                              0x00000004

// Data Out 8 to 11
#define GPIO_O_DOUT11_8                                             0x00000008

// Data Out 12 to 15
#define GPIO_O_DOUT15_12                                            0x0000000C

// Data Out 16 to 19
#define GPIO_O_DOUT19_16                                            0x00000010

// Data Out 20 to 23
#define GPIO_O_DOUT23_20                                            0x00000014

// Data Out 24 to 27
#define GPIO_O_DOUT27_24                                            0x00000018

// Data Out 28 to 31
#define GPIO_O_DOUT31_28                                            0x0000001C

// Data Output for DIO 0 to 31
#define GPIO_O_DOUT31_0                                             0x00000080

// Data Out Set
#define GPIO_O_DOUTSET31_0                                          0x00000090

// Data Out Clear
#define GPIO_O_DOUTCLR31_0                                          0x000000A0

// Data Out Toggle
#define GPIO_O_DOUTTGL31_0                                          0x000000B0

// Data Input from DIO 0 to 31
#define GPIO_O_DIN31_0                                              0x000000C0

// Data Output Enable for DIO 0 to 31
#define GPIO_O_DOE31_0                                              0x000000D0

// Event Register for DIO 0 to 31
#define GPIO_O_EVFLAGS31_0                                          0x000000E0

//*****************************************************************************
//
// Register: GPIO_O_DOUT3_0
//
//*****************************************************************************
// Field:    [24] DIO3
//
// Sets the state of the pin that is configured as DIO#3, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT3_0_DIO3                                           0x01000000
#define GPIO_DOUT3_0_DIO3_BITN                                              24
#define GPIO_DOUT3_0_DIO3_M                                         0x01000000
#define GPIO_DOUT3_0_DIO3_S                                                 24

// Field:    [16] DIO2
//
// Sets the state of the pin that is configured as DIO#2, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT3_0_DIO2                                           0x00010000
#define GPIO_DOUT3_0_DIO2_BITN                                              16
#define GPIO_DOUT3_0_DIO2_M                                         0x00010000
#define GPIO_DOUT3_0_DIO2_S                                                 16

// Field:     [8] DIO1
//
// Sets the state of the pin that is configured as DIO#1, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT3_0_DIO1                                           0x00000100
#define GPIO_DOUT3_0_DIO1_BITN                                               8
#define GPIO_DOUT3_0_DIO1_M                                         0x00000100
#define GPIO_DOUT3_0_DIO1_S                                                  8

// Field:     [0] DIO0
//
// Sets the state of the pin that is configured as DIO#0, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT3_0_DIO0                                           0x00000001
#define GPIO_DOUT3_0_DIO0_BITN                                               0
#define GPIO_DOUT3_0_DIO0_M                                         0x00000001
#define GPIO_DOUT3_0_DIO0_S                                                  0

//*****************************************************************************
//
// Register: GPIO_O_DOUT7_4
//
//*****************************************************************************
// Field:    [24] DIO7
//
// Sets the state of the pin that is configured as DIO#7, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT7_4_DIO7                                           0x01000000
#define GPIO_DOUT7_4_DIO7_BITN                                              24
#define GPIO_DOUT7_4_DIO7_M                                         0x01000000
#define GPIO_DOUT7_4_DIO7_S                                                 24

// Field:    [16] DIO6
//
// Sets the state of the pin that is configured as DIO#6, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT7_4_DIO6                                           0x00010000
#define GPIO_DOUT7_4_DIO6_BITN                                              16
#define GPIO_DOUT7_4_DIO6_M                                         0x00010000
#define GPIO_DOUT7_4_DIO6_S                                                 16

// Field:     [8] DIO5
//
// Sets the state of the pin that is configured as DIO#5, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT7_4_DIO5                                           0x00000100
#define GPIO_DOUT7_4_DIO5_BITN                                               8
#define GPIO_DOUT7_4_DIO5_M                                         0x00000100
#define GPIO_DOUT7_4_DIO5_S                                                  8

// Field:     [0] DIO4
//
// Sets the state of the pin that is configured as DIO#4, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT7_4_DIO4                                           0x00000001
#define GPIO_DOUT7_4_DIO4_BITN                                               0
#define GPIO_DOUT7_4_DIO4_M                                         0x00000001
#define GPIO_DOUT7_4_DIO4_S                                                  0

//*****************************************************************************
//
// Register: GPIO_O_DOUT11_8
//
//*****************************************************************************
// Field:    [24] DIO11
//
// Sets the state of the pin that is configured as DIO#11, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT11_8_DIO11                                         0x01000000
#define GPIO_DOUT11_8_DIO11_BITN                                            24
#define GPIO_DOUT11_8_DIO11_M                                       0x01000000
#define GPIO_DOUT11_8_DIO11_S                                               24

// Field:    [16] DIO10
//
// Sets the state of the pin that is configured as DIO#10, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT11_8_DIO10                                         0x00010000
#define GPIO_DOUT11_8_DIO10_BITN                                            16
#define GPIO_DOUT11_8_DIO10_M                                       0x00010000
#define GPIO_DOUT11_8_DIO10_S                                               16

// Field:     [8] DIO9
//
// Sets the state of the pin that is configured as DIO#9, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT11_8_DIO9                                          0x00000100
#define GPIO_DOUT11_8_DIO9_BITN                                              8
#define GPIO_DOUT11_8_DIO9_M                                        0x00000100
#define GPIO_DOUT11_8_DIO9_S                                                 8

// Field:     [0] DIO8
//
// Sets the state of the pin that is configured as DIO#8, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT11_8_DIO8                                          0x00000001
#define GPIO_DOUT11_8_DIO8_BITN                                              0
#define GPIO_DOUT11_8_DIO8_M                                        0x00000001
#define GPIO_DOUT11_8_DIO8_S                                                 0

//*****************************************************************************
//
// Register: GPIO_O_DOUT15_12
//
//*****************************************************************************
// Field:    [24] DIO15
//
// Sets the state of the pin that is configured as DIO#15, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT15_12_DIO15                                        0x01000000
#define GPIO_DOUT15_12_DIO15_BITN                                           24
#define GPIO_DOUT15_12_DIO15_M                                      0x01000000
#define GPIO_DOUT15_12_DIO15_S                                              24

// Field:    [16] DIO14
//
// Sets the state of the pin that is configured as DIO#14, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT15_12_DIO14                                        0x00010000
#define GPIO_DOUT15_12_DIO14_BITN                                           16
#define GPIO_DOUT15_12_DIO14_M                                      0x00010000
#define GPIO_DOUT15_12_DIO14_S                                              16

// Field:     [8] DIO13
//
// Sets the state of the pin that is configured as DIO#13, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT15_12_DIO13                                        0x00000100
#define GPIO_DOUT15_12_DIO13_BITN                                            8
#define GPIO_DOUT15_12_DIO13_M                                      0x00000100
#define GPIO_DOUT15_12_DIO13_S                                               8

// Field:     [0] DIO12
//
// Sets the state of the pin that is configured as DIO#12, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT15_12_DIO12                                        0x00000001
#define GPIO_DOUT15_12_DIO12_BITN                                            0
#define GPIO_DOUT15_12_DIO12_M                                      0x00000001
#define GPIO_DOUT15_12_DIO12_S                                               0

//*****************************************************************************
//
// Register: GPIO_O_DOUT19_16
//
//*****************************************************************************
// Field:    [24] DIO19
//
// Sets the state of the pin that is configured as DIO#19, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT19_16_DIO19                                        0x01000000
#define GPIO_DOUT19_16_DIO19_BITN                                           24
#define GPIO_DOUT19_16_DIO19_M                                      0x01000000
#define GPIO_DOUT19_16_DIO19_S                                              24

// Field:    [16] DIO18
//
// Sets the state of the pin that is configured as DIO#18, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT19_16_DIO18                                        0x00010000
#define GPIO_DOUT19_16_DIO18_BITN                                           16
#define GPIO_DOUT19_16_DIO18_M                                      0x00010000
#define GPIO_DOUT19_16_DIO18_S                                              16

// Field:     [8] DIO17
//
// Sets the state of the pin that is configured as DIO#17, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT19_16_DIO17                                        0x00000100
#define GPIO_DOUT19_16_DIO17_BITN                                            8
#define GPIO_DOUT19_16_DIO17_M                                      0x00000100
#define GPIO_DOUT19_16_DIO17_S                                               8

// Field:     [0] DIO16
//
// Sets the state of the pin that is configured as DIO#16, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT19_16_DIO16                                        0x00000001
#define GPIO_DOUT19_16_DIO16_BITN                                            0
#define GPIO_DOUT19_16_DIO16_M                                      0x00000001
#define GPIO_DOUT19_16_DIO16_S                                               0

//*****************************************************************************
//
// Register: GPIO_O_DOUT23_20
//
//*****************************************************************************
// Field:    [24] DIO23
//
// Sets the state of the pin that is configured as DIO#23, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT23_20_DIO23                                        0x01000000
#define GPIO_DOUT23_20_DIO23_BITN                                           24
#define GPIO_DOUT23_20_DIO23_M                                      0x01000000
#define GPIO_DOUT23_20_DIO23_S                                              24

// Field:    [16] DIO22
//
// Sets the state of the pin that is configured as DIO#22, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT23_20_DIO22                                        0x00010000
#define GPIO_DOUT23_20_DIO22_BITN                                           16
#define GPIO_DOUT23_20_DIO22_M                                      0x00010000
#define GPIO_DOUT23_20_DIO22_S                                              16

// Field:     [8] DIO21
//
// Sets the state of the pin that is configured as DIO#21, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT23_20_DIO21                                        0x00000100
#define GPIO_DOUT23_20_DIO21_BITN                                            8
#define GPIO_DOUT23_20_DIO21_M                                      0x00000100
#define GPIO_DOUT23_20_DIO21_S                                               8

// Field:     [0] DIO20
//
// Sets the state of the pin that is configured as DIO#20, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT23_20_DIO20                                        0x00000001
#define GPIO_DOUT23_20_DIO20_BITN                                            0
#define GPIO_DOUT23_20_DIO20_M                                      0x00000001
#define GPIO_DOUT23_20_DIO20_S                                               0

//*****************************************************************************
//
// Register: GPIO_O_DOUT27_24
//
//*****************************************************************************
// Field:    [24] DIO27
//
// Sets the state of the pin that is configured as DIO#27, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT27_24_DIO27                                        0x01000000
#define GPIO_DOUT27_24_DIO27_BITN                                           24
#define GPIO_DOUT27_24_DIO27_M                                      0x01000000
#define GPIO_DOUT27_24_DIO27_S                                              24

// Field:    [16] DIO26
//
// Sets the state of the pin that is configured as DIO#26, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT27_24_DIO26                                        0x00010000
#define GPIO_DOUT27_24_DIO26_BITN                                           16
#define GPIO_DOUT27_24_DIO26_M                                      0x00010000
#define GPIO_DOUT27_24_DIO26_S                                              16

// Field:     [8] DIO25
//
// Sets the state of the pin that is configured as DIO#25, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT27_24_DIO25                                        0x00000100
#define GPIO_DOUT27_24_DIO25_BITN                                            8
#define GPIO_DOUT27_24_DIO25_M                                      0x00000100
#define GPIO_DOUT27_24_DIO25_S                                               8

// Field:     [0] DIO24
//
// Sets the state of the pin that is configured as DIO#24, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT27_24_DIO24                                        0x00000001
#define GPIO_DOUT27_24_DIO24_BITN                                            0
#define GPIO_DOUT27_24_DIO24_M                                      0x00000001
#define GPIO_DOUT27_24_DIO24_S                                               0

//*****************************************************************************
//
// Register: GPIO_O_DOUT31_28
//
//*****************************************************************************
// Field:    [24] DIO31
//
// Sets the state of the pin that is configured as DIO#31, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT31_28_DIO31                                        0x01000000
#define GPIO_DOUT31_28_DIO31_BITN                                           24
#define GPIO_DOUT31_28_DIO31_M                                      0x01000000
#define GPIO_DOUT31_28_DIO31_S                                              24

// Field:    [16] DIO30
//
// Sets the state of the pin that is configured as DIO#30, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT31_28_DIO30                                        0x00010000
#define GPIO_DOUT31_28_DIO30_BITN                                           16
#define GPIO_DOUT31_28_DIO30_M                                      0x00010000
#define GPIO_DOUT31_28_DIO30_S                                              16

// Field:     [8] DIO29
//
// Sets the state of the pin that is configured as DIO#29, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT31_28_DIO29                                        0x00000100
#define GPIO_DOUT31_28_DIO29_BITN                                            8
#define GPIO_DOUT31_28_DIO29_M                                      0x00000100
#define GPIO_DOUT31_28_DIO29_S                                               8

// Field:     [0] DIO28
//
// Sets the state of the pin that is configured as DIO#28, if the corresponding
// DOE31_0 bitfield is set.
#define GPIO_DOUT31_28_DIO28                                        0x00000001
#define GPIO_DOUT31_28_DIO28_BITN                                            0
#define GPIO_DOUT31_28_DIO28_M                                      0x00000001
#define GPIO_DOUT31_28_DIO28_S                                               0

//*****************************************************************************
//
// Register: GPIO_O_DOUT31_0
//
//*****************************************************************************
// Field:    [31] DIO31
//
// Data output for DIO 31
#define GPIO_DOUT31_0_DIO31                                         0x80000000
#define GPIO_DOUT31_0_DIO31_BITN                                            31
#define GPIO_DOUT31_0_DIO31_M                                       0x80000000
#define GPIO_DOUT31_0_DIO31_S                                               31

// Field:    [30] DIO30
//
// Data output for DIO 30
#define GPIO_DOUT31_0_DIO30                                         0x40000000
#define GPIO_DOUT31_0_DIO30_BITN                                            30
#define GPIO_DOUT31_0_DIO30_M                                       0x40000000
#define GPIO_DOUT31_0_DIO30_S                                               30

// Field:    [29] DIO29
//
// Data output for DIO 29
#define GPIO_DOUT31_0_DIO29                                         0x20000000
#define GPIO_DOUT31_0_DIO29_BITN                                            29
#define GPIO_DOUT31_0_DIO29_M                                       0x20000000
#define GPIO_DOUT31_0_DIO29_S                                               29

// Field:    [28] DIO28
//
// Data output for DIO 28
#define GPIO_DOUT31_0_DIO28                                         0x10000000
#define GPIO_DOUT31_0_DIO28_BITN                                            28
#define GPIO_DOUT31_0_DIO28_M                                       0x10000000
#define GPIO_DOUT31_0_DIO28_S                                               28

// Field:    [27] DIO27
//
// Data output for DIO 27
#define GPIO_DOUT31_0_DIO27                                         0x08000000
#define GPIO_DOUT31_0_DIO27_BITN                                            27
#define GPIO_DOUT31_0_DIO27_M                                       0x08000000
#define GPIO_DOUT31_0_DIO27_S                                               27

// Field:    [26] DIO26
//
// Data output for DIO 26
#define GPIO_DOUT31_0_DIO26                                         0x04000000
#define GPIO_DOUT31_0_DIO26_BITN                                            26
#define GPIO_DOUT31_0_DIO26_M                                       0x04000000
#define GPIO_DOUT31_0_DIO26_S                                               26

// Field:    [25] DIO25
//
// Data output for DIO 25
#define GPIO_DOUT31_0_DIO25                                         0x02000000
#define GPIO_DOUT31_0_DIO25_BITN                                            25
#define GPIO_DOUT31_0_DIO25_M                                       0x02000000
#define GPIO_DOUT31_0_DIO25_S                                               25

// Field:    [24] DIO24
//
// Data output for DIO 24
#define GPIO_DOUT31_0_DIO24                                         0x01000000
#define GPIO_DOUT31_0_DIO24_BITN                                            24
#define GPIO_DOUT31_0_DIO24_M                                       0x01000000
#define GPIO_DOUT31_0_DIO24_S                                               24

// Field:    [23] DIO23
//
// Data output for DIO 23
#define GPIO_DOUT31_0_DIO23                                         0x00800000
#define GPIO_DOUT31_0_DIO23_BITN                                            23
#define GPIO_DOUT31_0_DIO23_M                                       0x00800000
#define GPIO_DOUT31_0_DIO23_S                                               23

// Field:    [22] DIO22
//
// Data output for DIO 22
#define GPIO_DOUT31_0_DIO22                                         0x00400000
#define GPIO_DOUT31_0_DIO22_BITN                                            22
#define GPIO_DOUT31_0_DIO22_M                                       0x00400000
#define GPIO_DOUT31_0_DIO22_S                                               22

// Field:    [21] DIO21
//
// Data output for DIO 21
#define GPIO_DOUT31_0_DIO21                                         0x00200000
#define GPIO_DOUT31_0_DIO21_BITN                                            21
#define GPIO_DOUT31_0_DIO21_M                                       0x00200000
#define GPIO_DOUT31_0_DIO21_S                                               21

// Field:    [20] DIO20
//
// Data output for DIO 20
#define GPIO_DOUT31_0_DIO20                                         0x00100000
#define GPIO_DOUT31_0_DIO20_BITN                                            20
#define GPIO_DOUT31_0_DIO20_M                                       0x00100000
#define GPIO_DOUT31_0_DIO20_S                                               20

// Field:    [19] DIO19
//
// Data output for DIO 19
#define GPIO_DOUT31_0_DIO19                                         0x00080000
#define GPIO_DOUT31_0_DIO19_BITN                                            19
#define GPIO_DOUT31_0_DIO19_M                                       0x00080000
#define GPIO_DOUT31_0_DIO19_S                                               19

// Field:    [18] DIO18
//
// Data output for DIO 18
#define GPIO_DOUT31_0_DIO18                                         0x00040000
#define GPIO_DOUT31_0_DIO18_BITN                                            18
#define GPIO_DOUT31_0_DIO18_M                                       0x00040000
#define GPIO_DOUT31_0_DIO18_S                                               18

// Field:    [17] DIO17
//
// Data output for DIO 17
#define GPIO_DOUT31_0_DIO17                                         0x00020000
#define GPIO_DOUT31_0_DIO17_BITN                                            17
#define GPIO_DOUT31_0_DIO17_M                                       0x00020000
#define GPIO_DOUT31_0_DIO17_S                                               17

// Field:    [16] DIO16
//
// Data output for DIO 16
#define GPIO_DOUT31_0_DIO16                                         0x00010000
#define GPIO_DOUT31_0_DIO16_BITN                                            16
#define GPIO_DOUT31_0_DIO16_M                                       0x00010000
#define GPIO_DOUT31_0_DIO16_S                                               16

// Field:    [15] DIO15
//
// Data output for DIO 15
#define GPIO_DOUT31_0_DIO15                                         0x00008000
#define GPIO_DOUT31_0_DIO15_BITN                                            15
#define GPIO_DOUT31_0_DIO15_M                                       0x00008000
#define GPIO_DOUT31_0_DIO15_S                                               15

// Field:    [14] DIO14
//
// Data output for DIO 14
#define GPIO_DOUT31_0_DIO14                                         0x00004000
#define GPIO_DOUT31_0_DIO14_BITN                                            14
#define GPIO_DOUT31_0_DIO14_M                                       0x00004000
#define GPIO_DOUT31_0_DIO14_S                                               14

// Field:    [13] DIO13
//
// Data output for DIO 13
#define GPIO_DOUT31_0_DIO13                                         0x00002000
#define GPIO_DOUT31_0_DIO13_BITN                                            13
#define GPIO_DOUT31_0_DIO13_M                                       0x00002000
#define GPIO_DOUT31_0_DIO13_S                                               13

// Field:    [12] DIO12
//
// Data output for DIO 12
#define GPIO_DOUT31_0_DIO12                                         0x00001000
#define GPIO_DOUT31_0_DIO12_BITN                                            12
#define GPIO_DOUT31_0_DIO12_M                                       0x00001000
#define GPIO_DOUT31_0_DIO12_S                                               12

// Field:    [11] DIO11
//
// Data output for DIO 11
#define GPIO_DOUT31_0_DIO11                                         0x00000800
#define GPIO_DOUT31_0_DIO11_BITN                                            11
#define GPIO_DOUT31_0_DIO11_M                                       0x00000800
#define GPIO_DOUT31_0_DIO11_S                                               11

// Field:    [10] DIO10
//
// Data output for DIO 10
#define GPIO_DOUT31_0_DIO10                                         0x00000400
#define GPIO_DOUT31_0_DIO10_BITN                                            10
#define GPIO_DOUT31_0_DIO10_M                                       0x00000400
#define GPIO_DOUT31_0_DIO10_S                                               10

// Field:     [9] DIO9
//
// Data output for DIO 9
#define GPIO_DOUT31_0_DIO9                                          0x00000200
#define GPIO_DOUT31_0_DIO9_BITN                                              9
#define GPIO_DOUT31_0_DIO9_M                                        0x00000200
#define GPIO_DOUT31_0_DIO9_S                                                 9

// Field:     [8] DIO8
//
// Data output for DIO 8
#define GPIO_DOUT31_0_DIO8                                          0x00000100
#define GPIO_DOUT31_0_DIO8_BITN                                              8
#define GPIO_DOUT31_0_DIO8_M                                        0x00000100
#define GPIO_DOUT31_0_DIO8_S                                                 8

// Field:     [7] DIO7
//
// Data output for DIO 7
#define GPIO_DOUT31_0_DIO7                                          0x00000080
#define GPIO_DOUT31_0_DIO7_BITN                                              7
#define GPIO_DOUT31_0_DIO7_M                                        0x00000080
#define GPIO_DOUT31_0_DIO7_S                                                 7

// Field:     [6] DIO6
//
// Data output for DIO 6
#define GPIO_DOUT31_0_DIO6                                          0x00000040
#define GPIO_DOUT31_0_DIO6_BITN                                              6
#define GPIO_DOUT31_0_DIO6_M                                        0x00000040
#define GPIO_DOUT31_0_DIO6_S                                                 6

// Field:     [5] DIO5
//
// Data output for DIO 5
#define GPIO_DOUT31_0_DIO5                                          0x00000020
#define GPIO_DOUT31_0_DIO5_BITN                                              5
#define GPIO_DOUT31_0_DIO5_M                                        0x00000020
#define GPIO_DOUT31_0_DIO5_S                                                 5

// Field:     [4] DIO4
//
// Data output for DIO 4
#define GPIO_DOUT31_0_DIO4                                          0x00000010
#define GPIO_DOUT31_0_DIO4_BITN                                              4
#define GPIO_DOUT31_0_DIO4_M                                        0x00000010
#define GPIO_DOUT31_0_DIO4_S                                                 4

// Field:     [3] DIO3
//
// Data output for DIO 3
#define GPIO_DOUT31_0_DIO3                                          0x00000008
#define GPIO_DOUT31_0_DIO3_BITN                                              3
#define GPIO_DOUT31_0_DIO3_M                                        0x00000008
#define GPIO_DOUT31_0_DIO3_S                                                 3

// Field:     [2] DIO2
//
// Data output for DIO 2
#define GPIO_DOUT31_0_DIO2                                          0x00000004
#define GPIO_DOUT31_0_DIO2_BITN                                              2
#define GPIO_DOUT31_0_DIO2_M                                        0x00000004
#define GPIO_DOUT31_0_DIO2_S                                                 2

// Field:     [1] DIO1
//
// Data output for DIO 1
#define GPIO_DOUT31_0_DIO1                                          0x00000002
#define GPIO_DOUT31_0_DIO1_BITN                                              1
#define GPIO_DOUT31_0_DIO1_M                                        0x00000002
#define GPIO_DOUT31_0_DIO1_S                                                 1

// Field:     [0] DIO0
//
// Data output for DIO 0
#define GPIO_DOUT31_0_DIO0                                          0x00000001
#define GPIO_DOUT31_0_DIO0_BITN                                              0
#define GPIO_DOUT31_0_DIO0_M                                        0x00000001
#define GPIO_DOUT31_0_DIO0_S                                                 0

//*****************************************************************************
//
// Register: GPIO_O_DOUTSET31_0
//
//*****************************************************************************
// Field:    [31] DIO31
//
// Set bit 31
#define GPIO_DOUTSET31_0_DIO31                                      0x80000000
#define GPIO_DOUTSET31_0_DIO31_BITN                                         31
#define GPIO_DOUTSET31_0_DIO31_M                                    0x80000000
#define GPIO_DOUTSET31_0_DIO31_S                                            31

// Field:    [30] DIO30
//
// Set bit 30
#define GPIO_DOUTSET31_0_DIO30                                      0x40000000
#define GPIO_DOUTSET31_0_DIO30_BITN                                         30
#define GPIO_DOUTSET31_0_DIO30_M                                    0x40000000
#define GPIO_DOUTSET31_0_DIO30_S                                            30

// Field:    [29] DIO29
//
// Set bit 29
#define GPIO_DOUTSET31_0_DIO29                                      0x20000000
#define GPIO_DOUTSET31_0_DIO29_BITN                                         29
#define GPIO_DOUTSET31_0_DIO29_M                                    0x20000000
#define GPIO_DOUTSET31_0_DIO29_S                                            29

// Field:    [28] DIO28
//
// Set bit 28
#define GPIO_DOUTSET31_0_DIO28                                      0x10000000
#define GPIO_DOUTSET31_0_DIO28_BITN                                         28
#define GPIO_DOUTSET31_0_DIO28_M                                    0x10000000
#define GPIO_DOUTSET31_0_DIO28_S                                            28

// Field:    [27] DIO27
//
// Set bit 27
#define GPIO_DOUTSET31_0_DIO27                                      0x08000000
#define GPIO_DOUTSET31_0_DIO27_BITN                                         27
#define GPIO_DOUTSET31_0_DIO27_M                                    0x08000000
#define GPIO_DOUTSET31_0_DIO27_S                                            27

// Field:    [26] DIO26
//
// Set bit 26
#define GPIO_DOUTSET31_0_DIO26                                      0x04000000
#define GPIO_DOUTSET31_0_DIO26_BITN                                         26
#define GPIO_DOUTSET31_0_DIO26_M                                    0x04000000
#define GPIO_DOUTSET31_0_DIO26_S                                            26

// Field:    [25] DIO25
//
// Set bit 25
#define GPIO_DOUTSET31_0_DIO25                                      0x02000000
#define GPIO_DOUTSET31_0_DIO25_BITN                                         25
#define GPIO_DOUTSET31_0_DIO25_M                                    0x02000000
#define GPIO_DOUTSET31_0_DIO25_S                                            25

// Field:    [24] DIO24
//
// Set bit 24
#define GPIO_DOUTSET31_0_DIO24                                      0x01000000
#define GPIO_DOUTSET31_0_DIO24_BITN                                         24
#define GPIO_DOUTSET31_0_DIO24_M                                    0x01000000
#define GPIO_DOUTSET31_0_DIO24_S                                            24

// Field:    [23] DIO23
//
// Set bit 23
#define GPIO_DOUTSET31_0_DIO23                                      0x00800000
#define GPIO_DOUTSET31_0_DIO23_BITN                                         23
#define GPIO_DOUTSET31_0_DIO23_M                                    0x00800000
#define GPIO_DOUTSET31_0_DIO23_S                                            23

// Field:    [22] DIO22
//
// Set bit 22
#define GPIO_DOUTSET31_0_DIO22                                      0x00400000
#define GPIO_DOUTSET31_0_DIO22_BITN                                         22
#define GPIO_DOUTSET31_0_DIO22_M                                    0x00400000
#define GPIO_DOUTSET31_0_DIO22_S                                            22

// Field:    [21] DIO21
//
// Set bit 21
#define GPIO_DOUTSET31_0_DIO21                                      0x00200000
#define GPIO_DOUTSET31_0_DIO21_BITN                                         21
#define GPIO_DOUTSET31_0_DIO21_M                                    0x00200000
#define GPIO_DOUTSET31_0_DIO21_S                                            21

// Field:    [20] DIO20
//
// Set bit 20
#define GPIO_DOUTSET31_0_DIO20                                      0x00100000
#define GPIO_DOUTSET31_0_DIO20_BITN                                         20
#define GPIO_DOUTSET31_0_DIO20_M                                    0x00100000
#define GPIO_DOUTSET31_0_DIO20_S                                            20

// Field:    [19] DIO19
//
// Set bit 19
#define GPIO_DOUTSET31_0_DIO19                                      0x00080000
#define GPIO_DOUTSET31_0_DIO19_BITN                                         19
#define GPIO_DOUTSET31_0_DIO19_M                                    0x00080000
#define GPIO_DOUTSET31_0_DIO19_S                                            19

// Field:    [18] DIO18
//
// Set bit 18
#define GPIO_DOUTSET31_0_DIO18                                      0x00040000
#define GPIO_DOUTSET31_0_DIO18_BITN                                         18
#define GPIO_DOUTSET31_0_DIO18_M                                    0x00040000
#define GPIO_DOUTSET31_0_DIO18_S                                            18

// Field:    [17] DIO17
//
// Set bit 17
#define GPIO_DOUTSET31_0_DIO17                                      0x00020000
#define GPIO_DOUTSET31_0_DIO17_BITN                                         17
#define GPIO_DOUTSET31_0_DIO17_M                                    0x00020000
#define GPIO_DOUTSET31_0_DIO17_S                                            17

// Field:    [16] DIO16
//
// Set bit 16
#define GPIO_DOUTSET31_0_DIO16                                      0x00010000
#define GPIO_DOUTSET31_0_DIO16_BITN                                         16
#define GPIO_DOUTSET31_0_DIO16_M                                    0x00010000
#define GPIO_DOUTSET31_0_DIO16_S                                            16

// Field:    [15] DIO15
//
// Set bit 15
#define GPIO_DOUTSET31_0_DIO15                                      0x00008000
#define GPIO_DOUTSET31_0_DIO15_BITN                                         15
#define GPIO_DOUTSET31_0_DIO15_M                                    0x00008000
#define GPIO_DOUTSET31_0_DIO15_S                                            15

// Field:    [14] DIO14
//
// Set bit 14
#define GPIO_DOUTSET31_0_DIO14                                      0x00004000
#define GPIO_DOUTSET31_0_DIO14_BITN                                         14
#define GPIO_DOUTSET31_0_DIO14_M                                    0x00004000
#define GPIO_DOUTSET31_0_DIO14_S                                            14

// Field:    [13] DIO13
//
// Set bit 13
#define GPIO_DOUTSET31_0_DIO13                                      0x00002000
#define GPIO_DOUTSET31_0_DIO13_BITN                                         13
#define GPIO_DOUTSET31_0_DIO13_M                                    0x00002000
#define GPIO_DOUTSET31_0_DIO13_S                                            13

// Field:    [12] DIO12
//
// Set bit 12
#define GPIO_DOUTSET31_0_DIO12                                      0x00001000
#define GPIO_DOUTSET31_0_DIO12_BITN                                         12
#define GPIO_DOUTSET31_0_DIO12_M                                    0x00001000
#define GPIO_DOUTSET31_0_DIO12_S                                            12

// Field:    [11] DIO11
//
// Set bit 11
#define GPIO_DOUTSET31_0_DIO11                                      0x00000800
#define GPIO_DOUTSET31_0_DIO11_BITN                                         11
#define GPIO_DOUTSET31_0_DIO11_M                                    0x00000800
#define GPIO_DOUTSET31_0_DIO11_S                                            11

// Field:    [10] DIO10
//
// Set bit 10
#define GPIO_DOUTSET31_0_DIO10                                      0x00000400
#define GPIO_DOUTSET31_0_DIO10_BITN                                         10
#define GPIO_DOUTSET31_0_DIO10_M                                    0x00000400
#define GPIO_DOUTSET31_0_DIO10_S                                            10

// Field:     [9] DIO9
//
// Set bit 9
#define GPIO_DOUTSET31_0_DIO9                                       0x00000200
#define GPIO_DOUTSET31_0_DIO9_BITN                                           9
#define GPIO_DOUTSET31_0_DIO9_M                                     0x00000200
#define GPIO_DOUTSET31_0_DIO9_S                                              9

// Field:     [8] DIO8
//
// Set bit 8
#define GPIO_DOUTSET31_0_DIO8                                       0x00000100
#define GPIO_DOUTSET31_0_DIO8_BITN                                           8
#define GPIO_DOUTSET31_0_DIO8_M                                     0x00000100
#define GPIO_DOUTSET31_0_DIO8_S                                              8

// Field:     [7] DIO7
//
// Set bit 7
#define GPIO_DOUTSET31_0_DIO7                                       0x00000080
#define GPIO_DOUTSET31_0_DIO7_BITN                                           7
#define GPIO_DOUTSET31_0_DIO7_M                                     0x00000080
#define GPIO_DOUTSET31_0_DIO7_S                                              7

// Field:     [6] DIO6
//
// Set bit 6
#define GPIO_DOUTSET31_0_DIO6                                       0x00000040
#define GPIO_DOUTSET31_0_DIO6_BITN                                           6
#define GPIO_DOUTSET31_0_DIO6_M                                     0x00000040
#define GPIO_DOUTSET31_0_DIO6_S                                              6

// Field:     [5] DIO5
//
// Set bit 5
#define GPIO_DOUTSET31_0_DIO5                                       0x00000020
#define GPIO_DOUTSET31_0_DIO5_BITN                                           5
#define GPIO_DOUTSET31_0_DIO5_M                                     0x00000020
#define GPIO_DOUTSET31_0_DIO5_S                                              5

// Field:     [4] DIO4
//
// Set bit 4
#define GPIO_DOUTSET31_0_DIO4                                       0x00000010
#define GPIO_DOUTSET31_0_DIO4_BITN                                           4
#define GPIO_DOUTSET31_0_DIO4_M                                     0x00000010
#define GPIO_DOUTSET31_0_DIO4_S                                              4

// Field:     [3] DIO3
//
// Set bit 3
#define GPIO_DOUTSET31_0_DIO3                                       0x00000008
#define GPIO_DOUTSET31_0_DIO3_BITN                                           3
#define GPIO_DOUTSET31_0_DIO3_M                                     0x00000008
#define GPIO_DOUTSET31_0_DIO3_S                                              3

// Field:     [2] DIO2
//
// Set bit 2
#define GPIO_DOUTSET31_0_DIO2                                       0x00000004
#define GPIO_DOUTSET31_0_DIO2_BITN                                           2
#define GPIO_DOUTSET31_0_DIO2_M                                     0x00000004
#define GPIO_DOUTSET31_0_DIO2_S                                              2

// Field:     [1] DIO1
//
// Set bit 1
#define GPIO_DOUTSET31_0_DIO1                                       0x00000002
#define GPIO_DOUTSET31_0_DIO1_BITN                                           1
#define GPIO_DOUTSET31_0_DIO1_M                                     0x00000002
#define GPIO_DOUTSET31_0_DIO1_S                                              1

// Field:     [0] DIO0
//
// Set bit 0
#define GPIO_DOUTSET31_0_DIO0                                       0x00000001
#define GPIO_DOUTSET31_0_DIO0_BITN                                           0
#define GPIO_DOUTSET31_0_DIO0_M                                     0x00000001
#define GPIO_DOUTSET31_0_DIO0_S                                              0

//*****************************************************************************
//
// Register: GPIO_O_DOUTCLR31_0
//
//*****************************************************************************
// Field:    [31] DIO31
//
// Clears bit 31
#define GPIO_DOUTCLR31_0_DIO31                                      0x80000000
#define GPIO_DOUTCLR31_0_DIO31_BITN                                         31
#define GPIO_DOUTCLR31_0_DIO31_M                                    0x80000000
#define GPIO_DOUTCLR31_0_DIO31_S                                            31

// Field:    [30] DIO30
//
// Clears bit 30
#define GPIO_DOUTCLR31_0_DIO30                                      0x40000000
#define GPIO_DOUTCLR31_0_DIO30_BITN                                         30
#define GPIO_DOUTCLR31_0_DIO30_M                                    0x40000000
#define GPIO_DOUTCLR31_0_DIO30_S                                            30

// Field:    [29] DIO29
//
// Clears bit 29
#define GPIO_DOUTCLR31_0_DIO29                                      0x20000000
#define GPIO_DOUTCLR31_0_DIO29_BITN                                         29
#define GPIO_DOUTCLR31_0_DIO29_M                                    0x20000000
#define GPIO_DOUTCLR31_0_DIO29_S                                            29

// Field:    [28] DIO28
//
// Clears bit 28
#define GPIO_DOUTCLR31_0_DIO28                                      0x10000000
#define GPIO_DOUTCLR31_0_DIO28_BITN                                         28
#define GPIO_DOUTCLR31_0_DIO28_M                                    0x10000000
#define GPIO_DOUTCLR31_0_DIO28_S                                            28

// Field:    [27] DIO27
//
// Clears bit 27
#define GPIO_DOUTCLR31_0_DIO27                                      0x08000000
#define GPIO_DOUTCLR31_0_DIO27_BITN                                         27
#define GPIO_DOUTCLR31_0_DIO27_M                                    0x08000000
#define GPIO_DOUTCLR31_0_DIO27_S                                            27

// Field:    [26] DIO26
//
// Clears bit 26
#define GPIO_DOUTCLR31_0_DIO26                                      0x04000000
#define GPIO_DOUTCLR31_0_DIO26_BITN                                         26
#define GPIO_DOUTCLR31_0_DIO26_M                                    0x04000000
#define GPIO_DOUTCLR31_0_DIO26_S                                            26

// Field:    [25] DIO25
//
// Clears bit 25
#define GPIO_DOUTCLR31_0_DIO25                                      0x02000000
#define GPIO_DOUTCLR31_0_DIO25_BITN                                         25
#define GPIO_DOUTCLR31_0_DIO25_M                                    0x02000000
#define GPIO_DOUTCLR31_0_DIO25_S                                            25

// Field:    [24] DIO24
//
// Clears bit 24
#define GPIO_DOUTCLR31_0_DIO24                                      0x01000000
#define GPIO_DOUTCLR31_0_DIO24_BITN                                         24
#define GPIO_DOUTCLR31_0_DIO24_M                                    0x01000000
#define GPIO_DOUTCLR31_0_DIO24_S                                            24

// Field:    [23] DIO23
//
// Clears bit 23
#define GPIO_DOUTCLR31_0_DIO23                                      0x00800000
#define GPIO_DOUTCLR31_0_DIO23_BITN                                         23
#define GPIO_DOUTCLR31_0_DIO23_M                                    0x00800000
#define GPIO_DOUTCLR31_0_DIO23_S                                            23

// Field:    [22] DIO22
//
// Clears bit 22
#define GPIO_DOUTCLR31_0_DIO22                                      0x00400000
#define GPIO_DOUTCLR31_0_DIO22_BITN                                         22
#define GPIO_DOUTCLR31_0_DIO22_M                                    0x00400000
#define GPIO_DOUTCLR31_0_DIO22_S                                            22

// Field:    [21] DIO21
//
// Clears bit 21
#define GPIO_DOUTCLR31_0_DIO21                                      0x00200000
#define GPIO_DOUTCLR31_0_DIO21_BITN                                         21
#define GPIO_DOUTCLR31_0_DIO21_M                                    0x00200000
#define GPIO_DOUTCLR31_0_DIO21_S                                            21

// Field:    [20] DIO20
//
// Clears bit 20
#define GPIO_DOUTCLR31_0_DIO20                                      0x00100000
#define GPIO_DOUTCLR31_0_DIO20_BITN                                         20
#define GPIO_DOUTCLR31_0_DIO20_M                                    0x00100000
#define GPIO_DOUTCLR31_0_DIO20_S                                            20

// Field:    [19] DIO19
//
// Clears bit 19
#define GPIO_DOUTCLR31_0_DIO19                                      0x00080000
#define GPIO_DOUTCLR31_0_DIO19_BITN                                         19
#define GPIO_DOUTCLR31_0_DIO19_M                                    0x00080000
#define GPIO_DOUTCLR31_0_DIO19_S                                            19

// Field:    [18] DIO18
//
// Clears bit 18
#define GPIO_DOUTCLR31_0_DIO18                                      0x00040000
#define GPIO_DOUTCLR31_0_DIO18_BITN                                         18
#define GPIO_DOUTCLR31_0_DIO18_M                                    0x00040000
#define GPIO_DOUTCLR31_0_DIO18_S                                            18

// Field:    [17] DIO17
//
// Clears bit 17
#define GPIO_DOUTCLR31_0_DIO17                                      0x00020000
#define GPIO_DOUTCLR31_0_DIO17_BITN                                         17
#define GPIO_DOUTCLR31_0_DIO17_M                                    0x00020000
#define GPIO_DOUTCLR31_0_DIO17_S                                            17

// Field:    [16] DIO16
//
// Clears bit 16
#define GPIO_DOUTCLR31_0_DIO16                                      0x00010000
#define GPIO_DOUTCLR31_0_DIO16_BITN                                         16
#define GPIO_DOUTCLR31_0_DIO16_M                                    0x00010000
#define GPIO_DOUTCLR31_0_DIO16_S                                            16

// Field:    [15] DIO15
//
// Clears bit 15
#define GPIO_DOUTCLR31_0_DIO15                                      0x00008000
#define GPIO_DOUTCLR31_0_DIO15_BITN                                         15
#define GPIO_DOUTCLR31_0_DIO15_M                                    0x00008000
#define GPIO_DOUTCLR31_0_DIO15_S                                            15

// Field:    [14] DIO14
//
// Clears bit 14
#define GPIO_DOUTCLR31_0_DIO14                                      0x00004000
#define GPIO_DOUTCLR31_0_DIO14_BITN                                         14
#define GPIO_DOUTCLR31_0_DIO14_M                                    0x00004000
#define GPIO_DOUTCLR31_0_DIO14_S                                            14

// Field:    [13] DIO13
//
// Clears bit 13
#define GPIO_DOUTCLR31_0_DIO13                                      0x00002000
#define GPIO_DOUTCLR31_0_DIO13_BITN                                         13
#define GPIO_DOUTCLR31_0_DIO13_M                                    0x00002000
#define GPIO_DOUTCLR31_0_DIO13_S                                            13

// Field:    [12] DIO12
//
// Clears bit 12
#define GPIO_DOUTCLR31_0_DIO12                                      0x00001000
#define GPIO_DOUTCLR31_0_DIO12_BITN                                         12
#define GPIO_DOUTCLR31_0_DIO12_M                                    0x00001000
#define GPIO_DOUTCLR31_0_DIO12_S                                            12

// Field:    [11] DIO11
//
// Clears bit 11
#define GPIO_DOUTCLR31_0_DIO11                                      0x00000800
#define GPIO_DOUTCLR31_0_DIO11_BITN                                         11
#define GPIO_DOUTCLR31_0_DIO11_M                                    0x00000800
#define GPIO_DOUTCLR31_0_DIO11_S                                            11

// Field:    [10] DIO10
//
// Clears bit 10
#define GPIO_DOUTCLR31_0_DIO10                                      0x00000400
#define GPIO_DOUTCLR31_0_DIO10_BITN                                         10
#define GPIO_DOUTCLR31_0_DIO10_M                                    0x00000400
#define GPIO_DOUTCLR31_0_DIO10_S                                            10

// Field:     [9] DIO9
//
// Clears bit 9
#define GPIO_DOUTCLR31_0_DIO9                                       0x00000200
#define GPIO_DOUTCLR31_0_DIO9_BITN                                           9
#define GPIO_DOUTCLR31_0_DIO9_M                                     0x00000200
#define GPIO_DOUTCLR31_0_DIO9_S                                              9

// Field:     [8] DIO8
//
// Clears bit 8
#define GPIO_DOUTCLR31_0_DIO8                                       0x00000100
#define GPIO_DOUTCLR31_0_DIO8_BITN                                           8
#define GPIO_DOUTCLR31_0_DIO8_M                                     0x00000100
#define GPIO_DOUTCLR31_0_DIO8_S                                              8

// Field:     [7] DIO7
//
// Clears bit 7
#define GPIO_DOUTCLR31_0_DIO7                                       0x00000080
#define GPIO_DOUTCLR31_0_DIO7_BITN                                           7
#define GPIO_DOUTCLR31_0_DIO7_M                                     0x00000080
#define GPIO_DOUTCLR31_0_DIO7_S                                              7

// Field:     [6] DIO6
//
// Clears bit 6
#define GPIO_DOUTCLR31_0_DIO6                                       0x00000040
#define GPIO_DOUTCLR31_0_DIO6_BITN                                           6
#define GPIO_DOUTCLR31_0_DIO6_M                                     0x00000040
#define GPIO_DOUTCLR31_0_DIO6_S                                              6

// Field:     [5] DIO5
//
// Clears bit 5
#define GPIO_DOUTCLR31_0_DIO5                                       0x00000020
#define GPIO_DOUTCLR31_0_DIO5_BITN                                           5
#define GPIO_DOUTCLR31_0_DIO5_M                                     0x00000020
#define GPIO_DOUTCLR31_0_DIO5_S                                              5

// Field:     [4] DIO4
//
// Clears bit 4
#define GPIO_DOUTCLR31_0_DIO4                                       0x00000010
#define GPIO_DOUTCLR31_0_DIO4_BITN                                           4
#define GPIO_DOUTCLR31_0_DIO4_M                                     0x00000010
#define GPIO_DOUTCLR31_0_DIO4_S                                              4

// Field:     [3] DIO3
//
// Clears bit 3
#define GPIO_DOUTCLR31_0_DIO3                                       0x00000008
#define GPIO_DOUTCLR31_0_DIO3_BITN                                           3
#define GPIO_DOUTCLR31_0_DIO3_M                                     0x00000008
#define GPIO_DOUTCLR31_0_DIO3_S                                              3

// Field:     [2] DIO2
//
// Clears bit 2
#define GPIO_DOUTCLR31_0_DIO2                                       0x00000004
#define GPIO_DOUTCLR31_0_DIO2_BITN                                           2
#define GPIO_DOUTCLR31_0_DIO2_M                                     0x00000004
#define GPIO_DOUTCLR31_0_DIO2_S                                              2

// Field:     [1] DIO1
//
// Clears bit 1
#define GPIO_DOUTCLR31_0_DIO1                                       0x00000002
#define GPIO_DOUTCLR31_0_DIO1_BITN                                           1
#define GPIO_DOUTCLR31_0_DIO1_M                                     0x00000002
#define GPIO_DOUTCLR31_0_DIO1_S                                              1

// Field:     [0] DIO0
//
// Clears bit 0
#define GPIO_DOUTCLR31_0_DIO0                                       0x00000001
#define GPIO_DOUTCLR31_0_DIO0_BITN                                           0
#define GPIO_DOUTCLR31_0_DIO0_M                                     0x00000001
#define GPIO_DOUTCLR31_0_DIO0_S                                              0

//*****************************************************************************
//
// Register: GPIO_O_DOUTTGL31_0
//
//*****************************************************************************
// Field:    [31] DIO31
//
// Toggles bit 31
#define GPIO_DOUTTGL31_0_DIO31                                      0x80000000
#define GPIO_DOUTTGL31_0_DIO31_BITN                                         31
#define GPIO_DOUTTGL31_0_DIO31_M                                    0x80000000
#define GPIO_DOUTTGL31_0_DIO31_S                                            31

// Field:    [30] DIO30
//
// Toggles bit 30
#define GPIO_DOUTTGL31_0_DIO30                                      0x40000000
#define GPIO_DOUTTGL31_0_DIO30_BITN                                         30
#define GPIO_DOUTTGL31_0_DIO30_M                                    0x40000000
#define GPIO_DOUTTGL31_0_DIO30_S                                            30

// Field:    [29] DIO29
//
// Toggles bit 29
#define GPIO_DOUTTGL31_0_DIO29                                      0x20000000
#define GPIO_DOUTTGL31_0_DIO29_BITN                                         29
#define GPIO_DOUTTGL31_0_DIO29_M                                    0x20000000
#define GPIO_DOUTTGL31_0_DIO29_S                                            29

// Field:    [28] DIO28
//
// Toggles bit 28
#define GPIO_DOUTTGL31_0_DIO28                                      0x10000000
#define GPIO_DOUTTGL31_0_DIO28_BITN                                         28
#define GPIO_DOUTTGL31_0_DIO28_M                                    0x10000000
#define GPIO_DOUTTGL31_0_DIO28_S                                            28

// Field:    [27] DIO27
//
// Toggles bit 27
#define GPIO_DOUTTGL31_0_DIO27                                      0x08000000
#define GPIO_DOUTTGL31_0_DIO27_BITN                                         27
#define GPIO_DOUTTGL31_0_DIO27_M                                    0x08000000
#define GPIO_DOUTTGL31_0_DIO27_S                                            27

// Field:    [26] DIO26
//
// Toggles bit 26
#define GPIO_DOUTTGL31_0_DIO26                                      0x04000000
#define GPIO_DOUTTGL31_0_DIO26_BITN                                         26
#define GPIO_DOUTTGL31_0_DIO26_M                                    0x04000000
#define GPIO_DOUTTGL31_0_DIO26_S                                            26

// Field:    [25] DIO25
//
// Toggles bit 25
#define GPIO_DOUTTGL31_0_DIO25                                      0x02000000
#define GPIO_DOUTTGL31_0_DIO25_BITN                                         25
#define GPIO_DOUTTGL31_0_DIO25_M                                    0x02000000
#define GPIO_DOUTTGL31_0_DIO25_S                                            25

// Field:    [24] DIO24
//
// Toggles bit 24
#define GPIO_DOUTTGL31_0_DIO24                                      0x01000000
#define GPIO_DOUTTGL31_0_DIO24_BITN                                         24
#define GPIO_DOUTTGL31_0_DIO24_M                                    0x01000000
#define GPIO_DOUTTGL31_0_DIO24_S                                            24

// Field:    [23] DIO23
//
// Toggles bit 23
#define GPIO_DOUTTGL31_0_DIO23                                      0x00800000
#define GPIO_DOUTTGL31_0_DIO23_BITN                                         23
#define GPIO_DOUTTGL31_0_DIO23_M                                    0x00800000
#define GPIO_DOUTTGL31_0_DIO23_S                                            23

// Field:    [22] DIO22
//
// Toggles bit 22
#define GPIO_DOUTTGL31_0_DIO22                                      0x00400000
#define GPIO_DOUTTGL31_0_DIO22_BITN                                         22
#define GPIO_DOUTTGL31_0_DIO22_M                                    0x00400000
#define GPIO_DOUTTGL31_0_DIO22_S                                            22

// Field:    [21] DIO21
//
// Toggles bit 21
#define GPIO_DOUTTGL31_0_DIO21                                      0x00200000
#define GPIO_DOUTTGL31_0_DIO21_BITN                                         21
#define GPIO_DOUTTGL31_0_DIO21_M                                    0x00200000
#define GPIO_DOUTTGL31_0_DIO21_S                                            21

// Field:    [20] DIO20
//
// Toggles bit 20
#define GPIO_DOUTTGL31_0_DIO20                                      0x00100000
#define GPIO_DOUTTGL31_0_DIO20_BITN                                         20
#define GPIO_DOUTTGL31_0_DIO20_M                                    0x00100000
#define GPIO_DOUTTGL31_0_DIO20_S                                            20

// Field:    [19] DIO19
//
// Toggles bit 19
#define GPIO_DOUTTGL31_0_DIO19                                      0x00080000
#define GPIO_DOUTTGL31_0_DIO19_BITN                                         19
#define GPIO_DOUTTGL31_0_DIO19_M                                    0x00080000
#define GPIO_DOUTTGL31_0_DIO19_S                                            19

// Field:    [18] DIO18
//
// Toggles bit 18
#define GPIO_DOUTTGL31_0_DIO18                                      0x00040000
#define GPIO_DOUTTGL31_0_DIO18_BITN                                         18
#define GPIO_DOUTTGL31_0_DIO18_M                                    0x00040000
#define GPIO_DOUTTGL31_0_DIO18_S                                            18

// Field:    [17] DIO17
//
// Toggles bit 17
#define GPIO_DOUTTGL31_0_DIO17                                      0x00020000
#define GPIO_DOUTTGL31_0_DIO17_BITN                                         17
#define GPIO_DOUTTGL31_0_DIO17_M                                    0x00020000
#define GPIO_DOUTTGL31_0_DIO17_S                                            17

// Field:    [16] DIO16
//
// Toggles bit 16
#define GPIO_DOUTTGL31_0_DIO16                                      0x00010000
#define GPIO_DOUTTGL31_0_DIO16_BITN                                         16
#define GPIO_DOUTTGL31_0_DIO16_M                                    0x00010000
#define GPIO_DOUTTGL31_0_DIO16_S                                            16

// Field:    [15] DIO15
//
// Toggles bit 15
#define GPIO_DOUTTGL31_0_DIO15                                      0x00008000
#define GPIO_DOUTTGL31_0_DIO15_BITN                                         15
#define GPIO_DOUTTGL31_0_DIO15_M                                    0x00008000
#define GPIO_DOUTTGL31_0_DIO15_S                                            15

// Field:    [14] DIO14
//
// Toggles bit 14
#define GPIO_DOUTTGL31_0_DIO14                                      0x00004000
#define GPIO_DOUTTGL31_0_DIO14_BITN                                         14
#define GPIO_DOUTTGL31_0_DIO14_M                                    0x00004000
#define GPIO_DOUTTGL31_0_DIO14_S                                            14

// Field:    [13] DIO13
//
// Toggles bit 13
#define GPIO_DOUTTGL31_0_DIO13                                      0x00002000
#define GPIO_DOUTTGL31_0_DIO13_BITN                                         13
#define GPIO_DOUTTGL31_0_DIO13_M                                    0x00002000
#define GPIO_DOUTTGL31_0_DIO13_S                                            13

// Field:    [12] DIO12
//
// Toggles bit 12
#define GPIO_DOUTTGL31_0_DIO12                                      0x00001000
#define GPIO_DOUTTGL31_0_DIO12_BITN                                         12
#define GPIO_DOUTTGL31_0_DIO12_M                                    0x00001000
#define GPIO_DOUTTGL31_0_DIO12_S                                            12

// Field:    [11] DIO11
//
// Toggles bit 11
#define GPIO_DOUTTGL31_0_DIO11                                      0x00000800
#define GPIO_DOUTTGL31_0_DIO11_BITN                                         11
#define GPIO_DOUTTGL31_0_DIO11_M                                    0x00000800
#define GPIO_DOUTTGL31_0_DIO11_S                                            11

// Field:    [10] DIO10
//
// Toggles bit 10
#define GPIO_DOUTTGL31_0_DIO10                                      0x00000400
#define GPIO_DOUTTGL31_0_DIO10_BITN                                         10
#define GPIO_DOUTTGL31_0_DIO10_M                                    0x00000400
#define GPIO_DOUTTGL31_0_DIO10_S                                            10

// Field:     [9] DIO9
//
// Toggles bit 9
#define GPIO_DOUTTGL31_0_DIO9                                       0x00000200
#define GPIO_DOUTTGL31_0_DIO9_BITN                                           9
#define GPIO_DOUTTGL31_0_DIO9_M                                     0x00000200
#define GPIO_DOUTTGL31_0_DIO9_S                                              9

// Field:     [8] DIO8
//
// Toggles bit 8
#define GPIO_DOUTTGL31_0_DIO8                                       0x00000100
#define GPIO_DOUTTGL31_0_DIO8_BITN                                           8
#define GPIO_DOUTTGL31_0_DIO8_M                                     0x00000100
#define GPIO_DOUTTGL31_0_DIO8_S                                              8

// Field:     [7] DIO7
//
// Toggles bit 7
#define GPIO_DOUTTGL31_0_DIO7                                       0x00000080
#define GPIO_DOUTTGL31_0_DIO7_BITN                                           7
#define GPIO_DOUTTGL31_0_DIO7_M                                     0x00000080
#define GPIO_DOUTTGL31_0_DIO7_S                                              7

// Field:     [6] DIO6
//
// Toggles bit 6
#define GPIO_DOUTTGL31_0_DIO6                                       0x00000040
#define GPIO_DOUTTGL31_0_DIO6_BITN                                           6
#define GPIO_DOUTTGL31_0_DIO6_M                                     0x00000040
#define GPIO_DOUTTGL31_0_DIO6_S                                              6

// Field:     [5] DIO5
//
// Toggles bit 5
#define GPIO_DOUTTGL31_0_DIO5                                       0x00000020
#define GPIO_DOUTTGL31_0_DIO5_BITN                                           5
#define GPIO_DOUTTGL31_0_DIO5_M                                     0x00000020
#define GPIO_DOUTTGL31_0_DIO5_S                                              5

// Field:     [4] DIO4
//
// Toggles bit 4
#define GPIO_DOUTTGL31_0_DIO4                                       0x00000010
#define GPIO_DOUTTGL31_0_DIO4_BITN                                           4
#define GPIO_DOUTTGL31_0_DIO4_M                                     0x00000010
#define GPIO_DOUTTGL31_0_DIO4_S                                              4

// Field:     [3] DIO3
//
// Toggles bit 3
#define GPIO_DOUTTGL31_0_DIO3                                       0x00000008
#define GPIO_DOUTTGL31_0_DIO3_BITN                                           3
#define GPIO_DOUTTGL31_0_DIO3_M                                     0x00000008
#define GPIO_DOUTTGL31_0_DIO3_S                                              3

// Field:     [2] DIO2
//
// Toggles bit 2
#define GPIO_DOUTTGL31_0_DIO2                                       0x00000004
#define GPIO_DOUTTGL31_0_DIO2_BITN                                           2
#define GPIO_DOUTTGL31_0_DIO2_M                                     0x00000004
#define GPIO_DOUTTGL31_0_DIO2_S                                              2

// Field:     [1] DIO1
//
// Toggles bit 1
#define GPIO_DOUTTGL31_0_DIO1                                       0x00000002
#define GPIO_DOUTTGL31_0_DIO1_BITN                                           1
#define GPIO_DOUTTGL31_0_DIO1_M                                     0x00000002
#define GPIO_DOUTTGL31_0_DIO1_S                                              1

// Field:     [0] DIO0
//
// Toggles bit 0
#define GPIO_DOUTTGL31_0_DIO0                                       0x00000001
#define GPIO_DOUTTGL31_0_DIO0_BITN                                           0
#define GPIO_DOUTTGL31_0_DIO0_M                                     0x00000001
#define GPIO_DOUTTGL31_0_DIO0_S                                              0

//*****************************************************************************
//
// Register: GPIO_O_DIN31_0
//
//*****************************************************************************
// Field:    [31] DIO31
//
// Data input from DIO 31
#define GPIO_DIN31_0_DIO31                                          0x80000000
#define GPIO_DIN31_0_DIO31_BITN                                             31
#define GPIO_DIN31_0_DIO31_M                                        0x80000000
#define GPIO_DIN31_0_DIO31_S                                                31

// Field:    [30] DIO30
//
// Data input from DIO 30
#define GPIO_DIN31_0_DIO30                                          0x40000000
#define GPIO_DIN31_0_DIO30_BITN                                             30
#define GPIO_DIN31_0_DIO30_M                                        0x40000000
#define GPIO_DIN31_0_DIO30_S                                                30

// Field:    [29] DIO29
//
// Data input from DIO 29
#define GPIO_DIN31_0_DIO29                                          0x20000000
#define GPIO_DIN31_0_DIO29_BITN                                             29
#define GPIO_DIN31_0_DIO29_M                                        0x20000000
#define GPIO_DIN31_0_DIO29_S                                                29

// Field:    [28] DIO28
//
// Data input from DIO 28
#define GPIO_DIN31_0_DIO28                                          0x10000000
#define GPIO_DIN31_0_DIO28_BITN                                             28
#define GPIO_DIN31_0_DIO28_M                                        0x10000000
#define GPIO_DIN31_0_DIO28_S                                                28

// Field:    [27] DIO27
//
// Data input from DIO 27
#define GPIO_DIN31_0_DIO27                                          0x08000000
#define GPIO_DIN31_0_DIO27_BITN                                             27
#define GPIO_DIN31_0_DIO27_M                                        0x08000000
#define GPIO_DIN31_0_DIO27_S                                                27

// Field:    [26] DIO26
//
// Data input from DIO 26
#define GPIO_DIN31_0_DIO26                                          0x04000000
#define GPIO_DIN31_0_DIO26_BITN                                             26
#define GPIO_DIN31_0_DIO26_M                                        0x04000000
#define GPIO_DIN31_0_DIO26_S                                                26

// Field:    [25] DIO25
//
// Data input from DIO 25
#define GPIO_DIN31_0_DIO25                                          0x02000000
#define GPIO_DIN31_0_DIO25_BITN                                             25
#define GPIO_DIN31_0_DIO25_M                                        0x02000000
#define GPIO_DIN31_0_DIO25_S                                                25

// Field:    [24] DIO24
//
// Data input from DIO 24
#define GPIO_DIN31_0_DIO24                                          0x01000000
#define GPIO_DIN31_0_DIO24_BITN                                             24
#define GPIO_DIN31_0_DIO24_M                                        0x01000000
#define GPIO_DIN31_0_DIO24_S                                                24

// Field:    [23] DIO23
//
// Data input from DIO 23
#define GPIO_DIN31_0_DIO23                                          0x00800000
#define GPIO_DIN31_0_DIO23_BITN                                             23
#define GPIO_DIN31_0_DIO23_M                                        0x00800000
#define GPIO_DIN31_0_DIO23_S                                                23

// Field:    [22] DIO22
//
// Data input from DIO 22
#define GPIO_DIN31_0_DIO22                                          0x00400000
#define GPIO_DIN31_0_DIO22_BITN                                             22
#define GPIO_DIN31_0_DIO22_M                                        0x00400000
#define GPIO_DIN31_0_DIO22_S                                                22

// Field:    [21] DIO21
//
// Data input from DIO 21
#define GPIO_DIN31_0_DIO21                                          0x00200000
#define GPIO_DIN31_0_DIO21_BITN                                             21
#define GPIO_DIN31_0_DIO21_M                                        0x00200000
#define GPIO_DIN31_0_DIO21_S                                                21

// Field:    [20] DIO20
//
// Data input from DIO 20
#define GPIO_DIN31_0_DIO20                                          0x00100000
#define GPIO_DIN31_0_DIO20_BITN                                             20
#define GPIO_DIN31_0_DIO20_M                                        0x00100000
#define GPIO_DIN31_0_DIO20_S                                                20

// Field:    [19] DIO19
//
// Data input from DIO 19
#define GPIO_DIN31_0_DIO19                                          0x00080000
#define GPIO_DIN31_0_DIO19_BITN                                             19
#define GPIO_DIN31_0_DIO19_M                                        0x00080000
#define GPIO_DIN31_0_DIO19_S                                                19

// Field:    [18] DIO18
//
// Data input from DIO 18
#define GPIO_DIN31_0_DIO18                                          0x00040000
#define GPIO_DIN31_0_DIO18_BITN                                             18
#define GPIO_DIN31_0_DIO18_M                                        0x00040000
#define GPIO_DIN31_0_DIO18_S                                                18

// Field:    [17] DIO17
//
// Data input from DIO 17
#define GPIO_DIN31_0_DIO17                                          0x00020000
#define GPIO_DIN31_0_DIO17_BITN                                             17
#define GPIO_DIN31_0_DIO17_M                                        0x00020000
#define GPIO_DIN31_0_DIO17_S                                                17

// Field:    [16] DIO16
//
// Data input from DIO 16
#define GPIO_DIN31_0_DIO16                                          0x00010000
#define GPIO_DIN31_0_DIO16_BITN                                             16
#define GPIO_DIN31_0_DIO16_M                                        0x00010000
#define GPIO_DIN31_0_DIO16_S                                                16

// Field:    [15] DIO15
//
// Data input from DIO 15
#define GPIO_DIN31_0_DIO15                                          0x00008000
#define GPIO_DIN31_0_DIO15_BITN                                             15
#define GPIO_DIN31_0_DIO15_M                                        0x00008000
#define GPIO_DIN31_0_DIO15_S                                                15

// Field:    [14] DIO14
//
// Data input from DIO 14
#define GPIO_DIN31_0_DIO14                                          0x00004000
#define GPIO_DIN31_0_DIO14_BITN                                             14
#define GPIO_DIN31_0_DIO14_M                                        0x00004000
#define GPIO_DIN31_0_DIO14_S                                                14

// Field:    [13] DIO13
//
// Data input from DIO 13
#define GPIO_DIN31_0_DIO13                                          0x00002000
#define GPIO_DIN31_0_DIO13_BITN                                             13
#define GPIO_DIN31_0_DIO13_M                                        0x00002000
#define GPIO_DIN31_0_DIO13_S                                                13

// Field:    [12] DIO12
//
// Data input from DIO 12
#define GPIO_DIN31_0_DIO12                                          0x00001000
#define GPIO_DIN31_0_DIO12_BITN                                             12
#define GPIO_DIN31_0_DIO12_M                                        0x00001000
#define GPIO_DIN31_0_DIO12_S                                                12

// Field:    [11] DIO11
//
// Data input from DIO 11
#define GPIO_DIN31_0_DIO11                                          0x00000800
#define GPIO_DIN31_0_DIO11_BITN                                             11
#define GPIO_DIN31_0_DIO11_M                                        0x00000800
#define GPIO_DIN31_0_DIO11_S                                                11

// Field:    [10] DIO10
//
// Data input from DIO 10
#define GPIO_DIN31_0_DIO10                                          0x00000400
#define GPIO_DIN31_0_DIO10_BITN                                             10
#define GPIO_DIN31_0_DIO10_M                                        0x00000400
#define GPIO_DIN31_0_DIO10_S                                                10

// Field:     [9] DIO9
//
// Data input from DIO 9
#define GPIO_DIN31_0_DIO9                                           0x00000200
#define GPIO_DIN31_0_DIO9_BITN                                               9
#define GPIO_DIN31_0_DIO9_M                                         0x00000200
#define GPIO_DIN31_0_DIO9_S                                                  9

// Field:     [8] DIO8
//
// Data input from DIO 8
#define GPIO_DIN31_0_DIO8                                           0x00000100
#define GPIO_DIN31_0_DIO8_BITN                                               8
#define GPIO_DIN31_0_DIO8_M                                         0x00000100
#define GPIO_DIN31_0_DIO8_S                                                  8

// Field:     [7] DIO7
//
// Data input from DIO 7
#define GPIO_DIN31_0_DIO7                                           0x00000080
#define GPIO_DIN31_0_DIO7_BITN                                               7
#define GPIO_DIN31_0_DIO7_M                                         0x00000080
#define GPIO_DIN31_0_DIO7_S                                                  7

// Field:     [6] DIO6
//
// Data input from DIO 6
#define GPIO_DIN31_0_DIO6                                           0x00000040
#define GPIO_DIN31_0_DIO6_BITN                                               6
#define GPIO_DIN31_0_DIO6_M                                         0x00000040
#define GPIO_DIN31_0_DIO6_S                                                  6

// Field:     [5] DIO5
//
// Data input from DIO 5
#define GPIO_DIN31_0_DIO5                                           0x00000020
#define GPIO_DIN31_0_DIO5_BITN                                               5
#define GPIO_DIN31_0_DIO5_M                                         0x00000020
#define GPIO_DIN31_0_DIO5_S                                                  5

// Field:     [4] DIO4
//
// Data input from DIO 4
#define GPIO_DIN31_0_DIO4                                           0x00000010
#define GPIO_DIN31_0_DIO4_BITN                                               4
#define GPIO_DIN31_0_DIO4_M                                         0x00000010
#define GPIO_DIN31_0_DIO4_S                                                  4

// Field:     [3] DIO3
//
// Data input from DIO 3
#define GPIO_DIN31_0_DIO3                                           0x00000008
#define GPIO_DIN31_0_DIO3_BITN                                               3
#define GPIO_DIN31_0_DIO3_M                                         0x00000008
#define GPIO_DIN31_0_DIO3_S                                                  3

// Field:     [2] DIO2
//
// Data input from DIO 2
#define GPIO_DIN31_0_DIO2                                           0x00000004
#define GPIO_DIN31_0_DIO2_BITN                                               2
#define GPIO_DIN31_0_DIO2_M                                         0x00000004
#define GPIO_DIN31_0_DIO2_S                                                  2

// Field:     [1] DIO1
//
// Data input from DIO 1
#define GPIO_DIN31_0_DIO1                                           0x00000002
#define GPIO_DIN31_0_DIO1_BITN                                               1
#define GPIO_DIN31_0_DIO1_M                                         0x00000002
#define GPIO_DIN31_0_DIO1_S                                                  1

// Field:     [0] DIO0
//
// Data input from DIO 0
#define GPIO_DIN31_0_DIO0                                           0x00000001
#define GPIO_DIN31_0_DIO0_BITN                                               0
#define GPIO_DIN31_0_DIO0_M                                         0x00000001
#define GPIO_DIN31_0_DIO0_S                                                  0

//*****************************************************************************
//
// Register: GPIO_O_DOE31_0
//
//*****************************************************************************
// Field:    [31] DIO31
//
// Data output enable for DIO 31
#define GPIO_DOE31_0_DIO31                                          0x80000000
#define GPIO_DOE31_0_DIO31_BITN                                             31
#define GPIO_DOE31_0_DIO31_M                                        0x80000000
#define GPIO_DOE31_0_DIO31_S                                                31

// Field:    [30] DIO30
//
// Data output enable for DIO 30
#define GPIO_DOE31_0_DIO30                                          0x40000000
#define GPIO_DOE31_0_DIO30_BITN                                             30
#define GPIO_DOE31_0_DIO30_M                                        0x40000000
#define GPIO_DOE31_0_DIO30_S                                                30

// Field:    [29] DIO29
//
// Data output enable for DIO 29
#define GPIO_DOE31_0_DIO29                                          0x20000000
#define GPIO_DOE31_0_DIO29_BITN                                             29
#define GPIO_DOE31_0_DIO29_M                                        0x20000000
#define GPIO_DOE31_0_DIO29_S                                                29

// Field:    [28] DIO28
//
// Data output enable for DIO 28
#define GPIO_DOE31_0_DIO28                                          0x10000000
#define GPIO_DOE31_0_DIO28_BITN                                             28
#define GPIO_DOE31_0_DIO28_M                                        0x10000000
#define GPIO_DOE31_0_DIO28_S                                                28

// Field:    [27] DIO27
//
// Data output enable for DIO 27
#define GPIO_DOE31_0_DIO27                                          0x08000000
#define GPIO_DOE31_0_DIO27_BITN                                             27
#define GPIO_DOE31_0_DIO27_M                                        0x08000000
#define GPIO_DOE31_0_DIO27_S                                                27

// Field:    [26] DIO26
//
// Data output enable for DIO 26
#define GPIO_DOE31_0_DIO26                                          0x04000000
#define GPIO_DOE31_0_DIO26_BITN                                             26
#define GPIO_DOE31_0_DIO26_M                                        0x04000000
#define GPIO_DOE31_0_DIO26_S                                                26

// Field:    [25] DIO25
//
// Data output enable for DIO 25
#define GPIO_DOE31_0_DIO25                                          0x02000000
#define GPIO_DOE31_0_DIO25_BITN                                             25
#define GPIO_DOE31_0_DIO25_M                                        0x02000000
#define GPIO_DOE31_0_DIO25_S                                                25

// Field:    [24] DIO24
//
// Data output enable for DIO 24
#define GPIO_DOE31_0_DIO24                                          0x01000000
#define GPIO_DOE31_0_DIO24_BITN                                             24
#define GPIO_DOE31_0_DIO24_M                                        0x01000000
#define GPIO_DOE31_0_DIO24_S                                                24

// Field:    [23] DIO23
//
// Data output enable for DIO 23
#define GPIO_DOE31_0_DIO23                                          0x00800000
#define GPIO_DOE31_0_DIO23_BITN                                             23
#define GPIO_DOE31_0_DIO23_M                                        0x00800000
#define GPIO_DOE31_0_DIO23_S                                                23

// Field:    [22] DIO22
//
// Data output enable for DIO 22
#define GPIO_DOE31_0_DIO22                                          0x00400000
#define GPIO_DOE31_0_DIO22_BITN                                             22
#define GPIO_DOE31_0_DIO22_M                                        0x00400000
#define GPIO_DOE31_0_DIO22_S                                                22

// Field:    [21] DIO21
//
// Data output enable for DIO 21
#define GPIO_DOE31_0_DIO21                                          0x00200000
#define GPIO_DOE31_0_DIO21_BITN                                             21
#define GPIO_DOE31_0_DIO21_M                                        0x00200000
#define GPIO_DOE31_0_DIO21_S                                                21

// Field:    [20] DIO20
//
// Data output enable for DIO 20
#define GPIO_DOE31_0_DIO20                                          0x00100000
#define GPIO_DOE31_0_DIO20_BITN                                             20
#define GPIO_DOE31_0_DIO20_M                                        0x00100000
#define GPIO_DOE31_0_DIO20_S                                                20

// Field:    [19] DIO19
//
// Data output enable for DIO 19
#define GPIO_DOE31_0_DIO19                                          0x00080000
#define GPIO_DOE31_0_DIO19_BITN                                             19
#define GPIO_DOE31_0_DIO19_M                                        0x00080000
#define GPIO_DOE31_0_DIO19_S                                                19

// Field:    [18] DIO18
//
// Data output enable for DIO 18
#define GPIO_DOE31_0_DIO18                                          0x00040000
#define GPIO_DOE31_0_DIO18_BITN                                             18
#define GPIO_DOE31_0_DIO18_M                                        0x00040000
#define GPIO_DOE31_0_DIO18_S                                                18

// Field:    [17] DIO17
//
// Data output enable for DIO 17
#define GPIO_DOE31_0_DIO17                                          0x00020000
#define GPIO_DOE31_0_DIO17_BITN                                             17
#define GPIO_DOE31_0_DIO17_M                                        0x00020000
#define GPIO_DOE31_0_DIO17_S                                                17

// Field:    [16] DIO16
//
// Data output enable for DIO 16
#define GPIO_DOE31_0_DIO16                                          0x00010000
#define GPIO_DOE31_0_DIO16_BITN                                             16
#define GPIO_DOE31_0_DIO16_M                                        0x00010000
#define GPIO_DOE31_0_DIO16_S                                                16

// Field:    [15] DIO15
//
// Data output enable for DIO 15
#define GPIO_DOE31_0_DIO15                                          0x00008000
#define GPIO_DOE31_0_DIO15_BITN                                             15
#define GPIO_DOE31_0_DIO15_M                                        0x00008000
#define GPIO_DOE31_0_DIO15_S                                                15

// Field:    [14] DIO14
//
// Data output enable for DIO 14
#define GPIO_DOE31_0_DIO14                                          0x00004000
#define GPIO_DOE31_0_DIO14_BITN                                             14
#define GPIO_DOE31_0_DIO14_M                                        0x00004000
#define GPIO_DOE31_0_DIO14_S                                                14

// Field:    [13] DIO13
//
// Data output enable for DIO 13
#define GPIO_DOE31_0_DIO13                                          0x00002000
#define GPIO_DOE31_0_DIO13_BITN                                             13
#define GPIO_DOE31_0_DIO13_M                                        0x00002000
#define GPIO_DOE31_0_DIO13_S                                                13

// Field:    [12] DIO12
//
// Data output enable for DIO 12
#define GPIO_DOE31_0_DIO12                                          0x00001000
#define GPIO_DOE31_0_DIO12_BITN                                             12
#define GPIO_DOE31_0_DIO12_M                                        0x00001000
#define GPIO_DOE31_0_DIO12_S                                                12

// Field:    [11] DIO11
//
// Data output enable for DIO 11
#define GPIO_DOE31_0_DIO11                                          0x00000800
#define GPIO_DOE31_0_DIO11_BITN                                             11
#define GPIO_DOE31_0_DIO11_M                                        0x00000800
#define GPIO_DOE31_0_DIO11_S                                                11

// Field:    [10] DIO10
//
// Data output enable for DIO 10
#define GPIO_DOE31_0_DIO10                                          0x00000400
#define GPIO_DOE31_0_DIO10_BITN                                             10
#define GPIO_DOE31_0_DIO10_M                                        0x00000400
#define GPIO_DOE31_0_DIO10_S                                                10

// Field:     [9] DIO9
//
// Data output enable for DIO 9
#define GPIO_DOE31_0_DIO9                                           0x00000200
#define GPIO_DOE31_0_DIO9_BITN                                               9
#define GPIO_DOE31_0_DIO9_M                                         0x00000200
#define GPIO_DOE31_0_DIO9_S                                                  9

// Field:     [8] DIO8
//
// Data output enable for DIO 8
#define GPIO_DOE31_0_DIO8                                           0x00000100
#define GPIO_DOE31_0_DIO8_BITN                                               8
#define GPIO_DOE31_0_DIO8_M                                         0x00000100
#define GPIO_DOE31_0_DIO8_S                                                  8

// Field:     [7] DIO7
//
// Data output enable for DIO 7
#define GPIO_DOE31_0_DIO7                                           0x00000080
#define GPIO_DOE31_0_DIO7_BITN                                               7
#define GPIO_DOE31_0_DIO7_M                                         0x00000080
#define GPIO_DOE31_0_DIO7_S                                                  7

// Field:     [6] DIO6
//
// Data output enable for DIO 6
#define GPIO_DOE31_0_DIO6                                           0x00000040
#define GPIO_DOE31_0_DIO6_BITN                                               6
#define GPIO_DOE31_0_DIO6_M                                         0x00000040
#define GPIO_DOE31_0_DIO6_S                                                  6

// Field:     [5] DIO5
//
// Data output enable for DIO 5
#define GPIO_DOE31_0_DIO5                                           0x00000020
#define GPIO_DOE31_0_DIO5_BITN                                               5
#define GPIO_DOE31_0_DIO5_M                                         0x00000020
#define GPIO_DOE31_0_DIO5_S                                                  5

// Field:     [4] DIO4
//
// Data output enable for DIO 4
#define GPIO_DOE31_0_DIO4                                           0x00000010
#define GPIO_DOE31_0_DIO4_BITN                                               4
#define GPIO_DOE31_0_DIO4_M                                         0x00000010
#define GPIO_DOE31_0_DIO4_S                                                  4

// Field:     [3] DIO3
//
// Data output enable for DIO 3
#define GPIO_DOE31_0_DIO3                                           0x00000008
#define GPIO_DOE31_0_DIO3_BITN                                               3
#define GPIO_DOE31_0_DIO3_M                                         0x00000008
#define GPIO_DOE31_0_DIO3_S                                                  3

// Field:     [2] DIO2
//
// Data output enable for DIO 2
#define GPIO_DOE31_0_DIO2                                           0x00000004
#define GPIO_DOE31_0_DIO2_BITN                                               2
#define GPIO_DOE31_0_DIO2_M                                         0x00000004
#define GPIO_DOE31_0_DIO2_S                                                  2

// Field:     [1] DIO1
//
// Data output enable for DIO 1
#define GPIO_DOE31_0_DIO1                                           0x00000002
#define GPIO_DOE31_0_DIO1_BITN                                               1
#define GPIO_DOE31_0_DIO1_M                                         0x00000002
#define GPIO_DOE31_0_DIO1_S                                                  1

// Field:     [0] DIO0
//
// Data output enable for DIO 0
#define GPIO_DOE31_0_DIO0                                           0x00000001
#define GPIO_DOE31_0_DIO0_BITN                                               0
#define GPIO_DOE31_0_DIO0_M                                         0x00000001
#define GPIO_DOE31_0_DIO0_S                                                  0

//*****************************************************************************
//
// Register: GPIO_O_EVFLAGS31_0
//
//*****************************************************************************
// Field:    [31] DIO31
//
// Event for DIO 31
#define GPIO_EVFLAGS31_0_DIO31                                      0x80000000
#define GPIO_EVFLAGS31_0_DIO31_BITN                                         31
#define GPIO_EVFLAGS31_0_DIO31_M                                    0x80000000
#define GPIO_EVFLAGS31_0_DIO31_S                                            31

// Field:    [30] DIO30
//
// Event for DIO 30
#define GPIO_EVFLAGS31_0_DIO30                                      0x40000000
#define GPIO_EVFLAGS31_0_DIO30_BITN                                         30
#define GPIO_EVFLAGS31_0_DIO30_M                                    0x40000000
#define GPIO_EVFLAGS31_0_DIO30_S                                            30

// Field:    [29] DIO29
//
// Event for DIO 29
#define GPIO_EVFLAGS31_0_DIO29                                      0x20000000
#define GPIO_EVFLAGS31_0_DIO29_BITN                                         29
#define GPIO_EVFLAGS31_0_DIO29_M                                    0x20000000
#define GPIO_EVFLAGS31_0_DIO29_S                                            29

// Field:    [28] DIO28
//
// Event for DIO 28
#define GPIO_EVFLAGS31_0_DIO28                                      0x10000000
#define GPIO_EVFLAGS31_0_DIO28_BITN                                         28
#define GPIO_EVFLAGS31_0_DIO28_M                                    0x10000000
#define GPIO_EVFLAGS31_0_DIO28_S                                            28

// Field:    [27] DIO27
//
// Event for DIO 27
#define GPIO_EVFLAGS31_0_DIO27                                      0x08000000
#define GPIO_EVFLAGS31_0_DIO27_BITN                                         27
#define GPIO_EVFLAGS31_0_DIO27_M                                    0x08000000
#define GPIO_EVFLAGS31_0_DIO27_S                                            27

// Field:    [26] DIO26
//
// Event for DIO 26
#define GPIO_EVFLAGS31_0_DIO26                                      0x04000000
#define GPIO_EVFLAGS31_0_DIO26_BITN                                         26
#define GPIO_EVFLAGS31_0_DIO26_M                                    0x04000000
#define GPIO_EVFLAGS31_0_DIO26_S                                            26

// Field:    [25] DIO25
//
// Event for DIO 25
#define GPIO_EVFLAGS31_0_DIO25                                      0x02000000
#define GPIO_EVFLAGS31_0_DIO25_BITN                                         25
#define GPIO_EVFLAGS31_0_DIO25_M                                    0x02000000
#define GPIO_EVFLAGS31_0_DIO25_S                                            25

// Field:    [24] DIO24
//
// Event for DIO 24
#define GPIO_EVFLAGS31_0_DIO24                                      0x01000000
#define GPIO_EVFLAGS31_0_DIO24_BITN                                         24
#define GPIO_EVFLAGS31_0_DIO24_M                                    0x01000000
#define GPIO_EVFLAGS31_0_DIO24_S                                            24

// Field:    [23] DIO23
//
// Event for DIO 23
#define GPIO_EVFLAGS31_0_DIO23                                      0x00800000
#define GPIO_EVFLAGS31_0_DIO23_BITN                                         23
#define GPIO_EVFLAGS31_0_DIO23_M                                    0x00800000
#define GPIO_EVFLAGS31_0_DIO23_S                                            23

// Field:    [22] DIO22
//
// Event for DIO 22
#define GPIO_EVFLAGS31_0_DIO22                                      0x00400000
#define GPIO_EVFLAGS31_0_DIO22_BITN                                         22
#define GPIO_EVFLAGS31_0_DIO22_M                                    0x00400000
#define GPIO_EVFLAGS31_0_DIO22_S                                            22

// Field:    [21] DIO21
//
// Event for DIO 21
#define GPIO_EVFLAGS31_0_DIO21                                      0x00200000
#define GPIO_EVFLAGS31_0_DIO21_BITN                                         21
#define GPIO_EVFLAGS31_0_DIO21_M                                    0x00200000
#define GPIO_EVFLAGS31_0_DIO21_S                                            21

// Field:    [20] DIO20
//
// Event for DIO 20
#define GPIO_EVFLAGS31_0_DIO20                                      0x00100000
#define GPIO_EVFLAGS31_0_DIO20_BITN                                         20
#define GPIO_EVFLAGS31_0_DIO20_M                                    0x00100000
#define GPIO_EVFLAGS31_0_DIO20_S                                            20

// Field:    [19] DIO19
//
// Event for DIO 19
#define GPIO_EVFLAGS31_0_DIO19                                      0x00080000
#define GPIO_EVFLAGS31_0_DIO19_BITN                                         19
#define GPIO_EVFLAGS31_0_DIO19_M                                    0x00080000
#define GPIO_EVFLAGS31_0_DIO19_S                                            19

// Field:    [18] DIO18
//
// Event for DIO 18
#define GPIO_EVFLAGS31_0_DIO18                                      0x00040000
#define GPIO_EVFLAGS31_0_DIO18_BITN                                         18
#define GPIO_EVFLAGS31_0_DIO18_M                                    0x00040000
#define GPIO_EVFLAGS31_0_DIO18_S                                            18

// Field:    [17] DIO17
//
// Event for DIO 17
#define GPIO_EVFLAGS31_0_DIO17                                      0x00020000
#define GPIO_EVFLAGS31_0_DIO17_BITN                                         17
#define GPIO_EVFLAGS31_0_DIO17_M                                    0x00020000
#define GPIO_EVFLAGS31_0_DIO17_S                                            17

// Field:    [16] DIO16
//
// Event for DIO 16
#define GPIO_EVFLAGS31_0_DIO16                                      0x00010000
#define GPIO_EVFLAGS31_0_DIO16_BITN                                         16
#define GPIO_EVFLAGS31_0_DIO16_M                                    0x00010000
#define GPIO_EVFLAGS31_0_DIO16_S                                            16

// Field:    [15] DIO15
//
// Event for DIO 15
#define GPIO_EVFLAGS31_0_DIO15                                      0x00008000
#define GPIO_EVFLAGS31_0_DIO15_BITN                                         15
#define GPIO_EVFLAGS31_0_DIO15_M                                    0x00008000
#define GPIO_EVFLAGS31_0_DIO15_S                                            15

// Field:    [14] DIO14
//
// Event for DIO 14
#define GPIO_EVFLAGS31_0_DIO14                                      0x00004000
#define GPIO_EVFLAGS31_0_DIO14_BITN                                         14
#define GPIO_EVFLAGS31_0_DIO14_M                                    0x00004000
#define GPIO_EVFLAGS31_0_DIO14_S                                            14

// Field:    [13] DIO13
//
// Event for DIO 13
#define GPIO_EVFLAGS31_0_DIO13                                      0x00002000
#define GPIO_EVFLAGS31_0_DIO13_BITN                                         13
#define GPIO_EVFLAGS31_0_DIO13_M                                    0x00002000
#define GPIO_EVFLAGS31_0_DIO13_S                                            13

// Field:    [12] DIO12
//
// Event for DIO 12
#define GPIO_EVFLAGS31_0_DIO12                                      0x00001000
#define GPIO_EVFLAGS31_0_DIO12_BITN                                         12
#define GPIO_EVFLAGS31_0_DIO12_M                                    0x00001000
#define GPIO_EVFLAGS31_0_DIO12_S                                            12

// Field:    [11] DIO11
//
// Event for DIO 11
#define GPIO_EVFLAGS31_0_DIO11                                      0x00000800
#define GPIO_EVFLAGS31_0_DIO11_BITN                                         11
#define GPIO_EVFLAGS31_0_DIO11_M                                    0x00000800
#define GPIO_EVFLAGS31_0_DIO11_S                                            11

// Field:    [10] DIO10
//
// Event for DIO 10
#define GPIO_EVFLAGS31_0_DIO10                                      0x00000400
#define GPIO_EVFLAGS31_0_DIO10_BITN                                         10
#define GPIO_EVFLAGS31_0_DIO10_M                                    0x00000400
#define GPIO_EVFLAGS31_0_DIO10_S                                            10

// Field:     [9] DIO9
//
// Event for DIO 9
#define GPIO_EVFLAGS31_0_DIO9                                       0x00000200
#define GPIO_EVFLAGS31_0_DIO9_BITN                                           9
#define GPIO_EVFLAGS31_0_DIO9_M                                     0x00000200
#define GPIO_EVFLAGS31_0_DIO9_S                                              9

// Field:     [8] DIO8
//
// Event for DIO 8
#define GPIO_EVFLAGS31_0_DIO8                                       0x00000100
#define GPIO_EVFLAGS31_0_DIO8_BITN                                           8
#define GPIO_EVFLAGS31_0_DIO8_M                                     0x00000100
#define GPIO_EVFLAGS31_0_DIO8_S                                              8

// Field:     [7] DIO7
//
// Event for DIO 7
#define GPIO_EVFLAGS31_0_DIO7                                       0x00000080
#define GPIO_EVFLAGS31_0_DIO7_BITN                                           7
#define GPIO_EVFLAGS31_0_DIO7_M                                     0x00000080
#define GPIO_EVFLAGS31_0_DIO7_S                                              7

// Field:     [6] DIO6
//
// Event for DIO 6
#define GPIO_EVFLAGS31_0_DIO6                                       0x00000040
#define GPIO_EVFLAGS31_0_DIO6_BITN                                           6
#define GPIO_EVFLAGS31_0_DIO6_M                                     0x00000040
#define GPIO_EVFLAGS31_0_DIO6_S                                              6

// Field:     [5] DIO5
//
// Event for DIO 5
#define GPIO_EVFLAGS31_0_DIO5                                       0x00000020
#define GPIO_EVFLAGS31_0_DIO5_BITN                                           5
#define GPIO_EVFLAGS31_0_DIO5_M                                     0x00000020
#define GPIO_EVFLAGS31_0_DIO5_S                                              5

// Field:     [4] DIO4
//
// Event for DIO 4
#define GPIO_EVFLAGS31_0_DIO4                                       0x00000010
#define GPIO_EVFLAGS31_0_DIO4_BITN                                           4
#define GPIO_EVFLAGS31_0_DIO4_M                                     0x00000010
#define GPIO_EVFLAGS31_0_DIO4_S                                              4

// Field:     [3] DIO3
//
// Event for DIO 3
#define GPIO_EVFLAGS31_0_DIO3                                       0x00000008
#define GPIO_EVFLAGS31_0_DIO3_BITN                                           3
#define GPIO_EVFLAGS31_0_DIO3_M                                     0x00000008
#define GPIO_EVFLAGS31_0_DIO3_S                                              3

// Field:     [2] DIO2
//
// Event for DIO 2
#define GPIO_EVFLAGS31_0_DIO2                                       0x00000004
#define GPIO_EVFLAGS31_0_DIO2_BITN                                           2
#define GPIO_EVFLAGS31_0_DIO2_M                                     0x00000004
#define GPIO_EVFLAGS31_0_DIO2_S                                              2

// Field:     [1] DIO1
//
// Event for DIO 1
#define GPIO_EVFLAGS31_0_DIO1                                       0x00000002
#define GPIO_EVFLAGS31_0_DIO1_BITN                                           1
#define GPIO_EVFLAGS31_0_DIO1_M                                     0x00000002
#define GPIO_EVFLAGS31_0_DIO1_S                                              1

// Field:     [0] DIO0
//
// Event for DIO 0
#define GPIO_EVFLAGS31_0_DIO0                                       0x00000001
#define GPIO_EVFLAGS31_0_DIO0_BITN                                           0
#define GPIO_EVFLAGS31_0_DIO0_M                                     0x00000001
#define GPIO_EVFLAGS31_0_DIO0_S                                              0


#endif // __HW_GPIO_H__

#ifndef __HW_TYPES_H__
#define __HW_TYPES_H__

#include <stdint.h>
#include <stdbool.h>

// for "../inc/hw_chip_def.h" did not find CC2652RB1FRG in Ti SDK
#define CC2652R1FRGZ
#define CC_CHIP_ID 0x26523710

//*****************************************************************************
//
// Common driverlib types
//
//*****************************************************************************
typedef void (* FPTR_VOID_VOID_T) (void);
typedef void (* FPTR_VOID_UINT8_T) (uint8_t);

//*****************************************************************************
//
// This symbol forces simple driverlib functions to be inlined in the code
// instead of using function calls.
//
//*****************************************************************************
#ifndef __STATIC_INLINE
#define __STATIC_INLINE static inline
#endif

//*****************************************************************************
//
// C99 types only allows bitfield defintions on certain datatypes.
//
//*****************************************************************************
typedef unsigned int  __UINT32;

//*****************************************************************************
//
// Macros for direct hardware access.
//
// If using these macros the programmer should be aware of any limitations to
// the address accessed i.e. if it supports word and/or byte access.
//
//*****************************************************************************
// Word (32 bit) access to address x
// Read example  : my32BitVar = HWREG(base_addr + offset) ;
// Write example : HWREG(base_addr + offset) = my32BitVar ;
#define HWREG(x)                                                              \
        (*((volatile unsigned long *)(x)))

// Half word (16 bit) access to address x
// Read example  : my16BitVar = HWREGH(base_addr + offset) ;
// Write example : HWREGH(base_addr + offset) = my16BitVar ;
#define HWREGH(x)                                                             \
        (*((volatile unsigned short *)(x)))

// Byte (8 bit) access to address x
// Read example  : my8BitVar = HWREGB(base_addr + offset) ;
// Write example : HWREGB(base_addr + offset) = my8BitVar ;
#define HWREGB(x)                                                             \
        (*((volatile unsigned char *)(x)))

//*****************************************************************************
//
// Macros for hardware access to bit-band supported addresses via the bit-band region.
//
// Macros calculate the corresponding address to access in the bit-band region
// based on the actual address of the memory/register and the bit number.
//
// Do NOT use these macros to access the bit-band region directly!
//
//*****************************************************************************
// Bit-band access to address x bit number b using word access (32 bit)
#define HWREGBITW(x, b)                                                       \
        HWREG(((unsigned long)(x) & 0xF0000000) | 0x02000000 |                \
              (((unsigned long)(x) & 0x000FFFFF) << 5) | ((b) << 2))

// Bit-band access to address x bit number b using half word access (16 bit)
#define HWREGBITH(x, b)                                                       \
        HWREGH(((unsigned long)(x) & 0xF0000000) | 0x02000000 |               \
               (((unsigned long)(x) & 0x000FFFFF) << 5) | ((b) << 2))

// Bit-band access to address x bit number b using byte access (8 bit)
#define HWREGBITB(x, b)                                                       \
        HWREGB(((unsigned long)(x) & 0xF0000000) | 0x02000000 |               \
               (((unsigned long)(x) & 0x000FFFFF) << 5) | ((b) << 2))

#endif // __HW_TYPES_H__

__STATIC_INLINE void
GPIO_writeDio (uint32_t dioNumber,uint32_t value) {
	HWREGB( GPIO_BASE + dioNumber ) = value;
}

__STATIC_INLINE void
GPIO_toggleDio(uint32_t dioNumber) {
	HWREG( GPIO_BASE + GPIO_O_DOUTTGL31_0 ) = ( 1 << dioNumber );
}

#ifndef __HW_DDI_0_OSC_H__
#define __HW_DDI_0_OSC_H__

//*****************************************************************************
//
// This section defines the register offsets of
// DDI_0_OSC component
//
// ti/simplelink_cc13x2_26x2_sdk_3_40_00_02/source/ti/devices/cc13x2_cc26x2/inc/hw_ddi_0_osc.h
//
//*****************************************************************************
// Control 0
#define DDI_0_OSC_O_CTL0                                            0x00000000

// Control 1
#define DDI_0_OSC_O_CTL1                                            0x00000004

// RADC External Configuration
#define DDI_0_OSC_O_RADCEXTCFG                                      0x00000008

// Amplitude Compensation Control
#define DDI_0_OSC_O_AMPCOMPCTL                                      0x0000000C

// Amplitude Compensation Threshold 1
#define DDI_0_OSC_O_AMPCOMPTH1                                      0x00000010

// Amplitude Compensation Threshold 2
#define DDI_0_OSC_O_AMPCOMPTH2                                      0x00000014

// Analog Bypass Values 1
#define DDI_0_OSC_O_ANABYPASSVAL1                                   0x00000018

// Internal
#define DDI_0_OSC_O_ANABYPASSVAL2                                   0x0000001C

// Analog Test Control
#define DDI_0_OSC_O_ATESTCTL                                        0x00000020

// ADC Doubler Nanoamp Control
#define DDI_0_OSC_O_ADCDOUBLERNANOAMPCTL                            0x00000024

// XOSCHF Control
#define DDI_0_OSC_O_XOSCHFCTL                                       0x00000028

// Low Frequency Oscillator Control
#define DDI_0_OSC_O_LFOSCCTL                                        0x0000002C

// RCOSCHF Control
#define DDI_0_OSC_O_RCOSCHFCTL                                      0x00000030

// RCOSC_MF Control
#define DDI_0_OSC_O_RCOSCMFCTL                                      0x00000034

// Status 0
#define DDI_0_OSC_O_STAT0                                           0x0000003C

// Status 1
#define DDI_0_OSC_O_STAT1                                           0x00000040

// Status 2
#define DDI_0_OSC_O_STAT2                                           0x00000044

//*****************************************************************************
//
// Register: DDI_0_OSC_O_CTL0
//
//*****************************************************************************
// Field:    [31] XTAL_IS_24M
//
// Set based on the accurate high frequency XTAL.
// ENUMs:
// 24M                      Internal. Only to be used through TI provided API.
// 48M                      Internal. Only to be used through TI provided API.
#define DDI_0_OSC_CTL0_XTAL_IS_24M                                  0x80000000
#define DDI_0_OSC_CTL0_XTAL_IS_24M_M                                0x80000000
#define DDI_0_OSC_CTL0_XTAL_IS_24M_S                                        31
#define DDI_0_OSC_CTL0_XTAL_IS_24M_24M                              0x80000000
#define DDI_0_OSC_CTL0_XTAL_IS_24M_48M                              0x00000000

// Field:    [29] BYPASS_XOSC_LF_CLK_QUAL
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_CTL0_BYPASS_XOSC_LF_CLK_QUAL                      0x20000000
#define DDI_0_OSC_CTL0_BYPASS_XOSC_LF_CLK_QUAL_M                    0x20000000
#define DDI_0_OSC_CTL0_BYPASS_XOSC_LF_CLK_QUAL_S                            29

// Field:    [28] BYPASS_RCOSC_LF_CLK_QUAL
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_CTL0_BYPASS_RCOSC_LF_CLK_QUAL                     0x10000000
#define DDI_0_OSC_CTL0_BYPASS_RCOSC_LF_CLK_QUAL_M                   0x10000000
#define DDI_0_OSC_CTL0_BYPASS_RCOSC_LF_CLK_QUAL_S                           28

// Field: [27:26] DOUBLER_START_DURATION
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_CTL0_DOUBLER_START_DURATION_W                              2
#define DDI_0_OSC_CTL0_DOUBLER_START_DURATION_M                     0x0C000000
#define DDI_0_OSC_CTL0_DOUBLER_START_DURATION_S                             26

// Field:    [25] DOUBLER_RESET_DURATION
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_CTL0_DOUBLER_RESET_DURATION                       0x02000000
#define DDI_0_OSC_CTL0_DOUBLER_RESET_DURATION_M                     0x02000000
#define DDI_0_OSC_CTL0_DOUBLER_RESET_DURATION_S                             25

// Field:    [24] CLK_DCDC_SRC_SEL
//
// Select DCDC clock source.
//
// 0: CLK_DCDC is 48 MHz clock from RCOSC or XOSC / HPOSC
// 1: CLK_DCDC is always 48 MHz clock from RCOSC
#define DDI_0_OSC_CTL0_CLK_DCDC_SRC_SEL                             0x01000000
#define DDI_0_OSC_CTL0_CLK_DCDC_SRC_SEL_M                           0x01000000
#define DDI_0_OSC_CTL0_CLK_DCDC_SRC_SEL_S                                   24

// Field:    [14] HPOSC_MODE_EN
//
// 0: HPOSC mode is not enabled. The 48 MHz crystal is required for radio
// operation.
// 1: Enables HPOSC mode. The internal HPOSC can be used as HF system clock and
// for radio operation.
#define DDI_0_OSC_CTL0_HPOSC_MODE_EN                                0x00004000
#define DDI_0_OSC_CTL0_HPOSC_MODE_EN_M                              0x00004000
#define DDI_0_OSC_CTL0_HPOSC_MODE_EN_S                                      14

// Field:    [12] RCOSC_LF_TRIMMED
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_CTL0_RCOSC_LF_TRIMMED                             0x00001000
#define DDI_0_OSC_CTL0_RCOSC_LF_TRIMMED_M                           0x00001000
#define DDI_0_OSC_CTL0_RCOSC_LF_TRIMMED_S                                   12

// Field:    [11] XOSC_HF_POWER_MODE
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_CTL0_XOSC_HF_POWER_MODE                           0x00000800
#define DDI_0_OSC_CTL0_XOSC_HF_POWER_MODE_M                         0x00000800
#define DDI_0_OSC_CTL0_XOSC_HF_POWER_MODE_S                                 11

// Field:    [10] XOSC_LF_DIG_BYPASS
//
// Bypass XOSC_LF and use the digital input clock from AON for the xosc_lf
// clock.
//
// 0: Use 32kHz XOSC as xosc_lf clock source
// 1: Use digital input (from AON) as xosc_lf clock source.
//
// This bit will only have effect when SCLK_LF_SRC_SEL is selecting the xosc_lf
// as the sclk_lf source. The muxing performed by this bit is not glitch free.
// The following procedure must be followed when changing this field to avoid
// glitches on sclk_lf.
//
// 1) Set SCLK_LF_SRC_SEL to select any source other than the xosc_lf clock
// source.
// 2) Set or clear this bit to bypass or not bypass the xosc_lf.
// 3) Set SCLK_LF_SRC_SEL to use xosc_lf.
//
// It is recommended that either the rcosc_hf or xosc_hf (whichever is
// currently active) be selected as the source in step 1 above. This provides a
// faster clock change.
#define DDI_0_OSC_CTL0_XOSC_LF_DIG_BYPASS                           0x00000400
#define DDI_0_OSC_CTL0_XOSC_LF_DIG_BYPASS_M                         0x00000400
#define DDI_0_OSC_CTL0_XOSC_LF_DIG_BYPASS_S                                 10

// Field:     [9] CLK_LOSS_EN
//
// Enable clock loss detection and hence the indicators to the system
// controller.  Checks both SCLK_HF, SCLK_MF and SCLK_LF clock loss indicators.
//
// 0: Disable
// 1: Enable
//
// Clock loss detection must be disabled when changing the sclk_lf source.
// STAT0.SCLK_LF_SRC can be polled to determine when a change to a new sclk_lf
// source has completed.
#define DDI_0_OSC_CTL0_CLK_LOSS_EN                                  0x00000200
#define DDI_0_OSC_CTL0_CLK_LOSS_EN_M                                0x00000200
#define DDI_0_OSC_CTL0_CLK_LOSS_EN_S                                         9

// Field:   [8:7] ACLK_TDC_SRC_SEL
//
// Source select for aclk_tdc.
//
// 00: RCOSC_HF (48MHz)
// 01: RCOSC_HF (24MHz)
// 10: XOSC_HF (24MHz)
// 11: Not used
#define DDI_0_OSC_CTL0_ACLK_TDC_SRC_SEL_W                                    2
#define DDI_0_OSC_CTL0_ACLK_TDC_SRC_SEL_M                           0x00000180
#define DDI_0_OSC_CTL0_ACLK_TDC_SRC_SEL_S                                    7

// Field:   [6:4] ACLK_REF_SRC_SEL
//
// Source select for aclk_ref
//
// 000: RCOSC_HF derived (31.25kHz)
// 001: XOSC_HF derived (31.25kHz)
// 010: RCOSC_LF (32kHz)
// 011: XOSC_LF (32.768kHz)
// 100: RCOSC_MF (2MHz)
// 101-111: Not used
#define DDI_0_OSC_CTL0_ACLK_REF_SRC_SEL_W                                    3
#define DDI_0_OSC_CTL0_ACLK_REF_SRC_SEL_M                           0x00000070
#define DDI_0_OSC_CTL0_ACLK_REF_SRC_SEL_S                                    4

// Field:   [3:2] SCLK_LF_SRC_SEL
//
// Source select for sclk_lf
// ENUMs:
// XOSCLF                   Low frequency XOSC
// RCOSCLF                  Low frequency RCOSC
// XOSCHFDLF                Low frequency clock derived from High Frequency
//                          XOSC or HPOSC clk (use HPOSC when HPOSC_MODE_EN
//                          = 1)
// RCOSCHFDLF               Low frequency clock derived from High Frequency
//                          RCOSC
#define DDI_0_OSC_CTL0_SCLK_LF_SRC_SEL_W                                     2
#define DDI_0_OSC_CTL0_SCLK_LF_SRC_SEL_M                            0x0000000C
#define DDI_0_OSC_CTL0_SCLK_LF_SRC_SEL_S                                     2
#define DDI_0_OSC_CTL0_SCLK_LF_SRC_SEL_XOSCLF                       0x0000000C
#define DDI_0_OSC_CTL0_SCLK_LF_SRC_SEL_RCOSCLF                      0x00000008
#define DDI_0_OSC_CTL0_SCLK_LF_SRC_SEL_XOSCHFDLF                    0x00000004
#define DDI_0_OSC_CTL0_SCLK_LF_SRC_SEL_RCOSCHFDLF                   0x00000000

// Field:     [0] SCLK_HF_SRC_SEL
//
// Source select for sclk_hf.
// ENUMs:
// XOSC                     High frequency XOSC or HPOSC clk (use HPOSC when
//                          HPOSC_MODE_EN = 1
// RCOSC                    High frequency RCOSC clock
#define DDI_0_OSC_CTL0_SCLK_HF_SRC_SEL                              0x00000001
#define DDI_0_OSC_CTL0_SCLK_HF_SRC_SEL_M                            0x00000001
#define DDI_0_OSC_CTL0_SCLK_HF_SRC_SEL_S                                     0
#define DDI_0_OSC_CTL0_SCLK_HF_SRC_SEL_XOSC                         0x00000001
#define DDI_0_OSC_CTL0_SCLK_HF_SRC_SEL_RCOSC                        0x00000000

//*****************************************************************************
//
// Register: DDI_0_OSC_O_CTL1
//
//*****************************************************************************
// Field: [22:18] RCOSCHFCTRIMFRACT
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_CTL1_RCOSCHFCTRIMFRACT_W                                   5
#define DDI_0_OSC_CTL1_RCOSCHFCTRIMFRACT_M                          0x007C0000
#define DDI_0_OSC_CTL1_RCOSCHFCTRIMFRACT_S                                  18

// Field:    [17] RCOSCHFCTRIMFRACT_EN
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_CTL1_RCOSCHFCTRIMFRACT_EN                         0x00020000
#define DDI_0_OSC_CTL1_RCOSCHFCTRIMFRACT_EN_M                       0x00020000
#define DDI_0_OSC_CTL1_RCOSCHFCTRIMFRACT_EN_S                               17

// Field:   [1:0] XOSC_HF_FAST_START
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_CTL1_XOSC_HF_FAST_START_W                                  2
#define DDI_0_OSC_CTL1_XOSC_HF_FAST_START_M                         0x00000003
#define DDI_0_OSC_CTL1_XOSC_HF_FAST_START_S                                  0

//*****************************************************************************
//
// Register: DDI_0_OSC_O_RADCEXTCFG
//
//*****************************************************************************
// Field: [31:22] HPM_IBIAS_WAIT_CNT
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_RADCEXTCFG_HPM_IBIAS_WAIT_CNT_W                           10
#define DDI_0_OSC_RADCEXTCFG_HPM_IBIAS_WAIT_CNT_M                   0xFFC00000
#define DDI_0_OSC_RADCEXTCFG_HPM_IBIAS_WAIT_CNT_S                           22

// Field: [21:16] LPM_IBIAS_WAIT_CNT
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_RADCEXTCFG_LPM_IBIAS_WAIT_CNT_W                            6
#define DDI_0_OSC_RADCEXTCFG_LPM_IBIAS_WAIT_CNT_M                   0x003F0000
#define DDI_0_OSC_RADCEXTCFG_LPM_IBIAS_WAIT_CNT_S                           16

// Field: [15:12] IDAC_STEP
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_RADCEXTCFG_IDAC_STEP_W                                     4
#define DDI_0_OSC_RADCEXTCFG_IDAC_STEP_M                            0x0000F000
#define DDI_0_OSC_RADCEXTCFG_IDAC_STEP_S                                    12

// Field:  [11:6] RADC_DAC_TH
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_RADCEXTCFG_RADC_DAC_TH_W                                   6
#define DDI_0_OSC_RADCEXTCFG_RADC_DAC_TH_M                          0x00000FC0
#define DDI_0_OSC_RADCEXTCFG_RADC_DAC_TH_S                                   6

// Field:     [5] RADC_MODE_IS_SAR
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_RADCEXTCFG_RADC_MODE_IS_SAR                       0x00000020
#define DDI_0_OSC_RADCEXTCFG_RADC_MODE_IS_SAR_M                     0x00000020
#define DDI_0_OSC_RADCEXTCFG_RADC_MODE_IS_SAR_S                              5

//*****************************************************************************
//
// Register: DDI_0_OSC_O_AMPCOMPCTL
//
//*****************************************************************************
// Field:    [30] AMPCOMP_REQ_MODE
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_REQ_MODE                       0x40000000
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_REQ_MODE_M                     0x40000000
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_REQ_MODE_S                             30

// Field: [29:28] AMPCOMP_FSM_UPDATE_RATE
//
// Internal. Only to be used through TI provided API.
// ENUMs:
// 250KHZ                   Internal. Only to be used through TI provided API.
// 500KHZ                   Internal. Only to be used through TI provided API.
// 1MHZ                     Internal. Only to be used through TI provided API.
// 2MHZ                     Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_FSM_UPDATE_RATE_W                       2
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_FSM_UPDATE_RATE_M              0x30000000
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_FSM_UPDATE_RATE_S                      28
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_FSM_UPDATE_RATE_250KHZ         0x30000000
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_FSM_UPDATE_RATE_500KHZ         0x20000000
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_FSM_UPDATE_RATE_1MHZ           0x10000000
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_FSM_UPDATE_RATE_2MHZ           0x00000000

// Field:    [27] AMPCOMP_SW_CTRL
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_SW_CTRL                        0x08000000
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_SW_CTRL_M                      0x08000000
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_SW_CTRL_S                              27

// Field:    [26] AMPCOMP_SW_EN
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_SW_EN                          0x04000000
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_SW_EN_M                        0x04000000
#define DDI_0_OSC_AMPCOMPCTL_AMPCOMP_SW_EN_S                                26

// Field: [23:20] IBIAS_OFFSET
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPCTL_IBIAS_OFFSET_W                                  4
#define DDI_0_OSC_AMPCOMPCTL_IBIAS_OFFSET_M                         0x00F00000
#define DDI_0_OSC_AMPCOMPCTL_IBIAS_OFFSET_S                                 20

// Field: [19:16] IBIAS_INIT
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPCTL_IBIAS_INIT_W                                    4
#define DDI_0_OSC_AMPCOMPCTL_IBIAS_INIT_M                           0x000F0000
#define DDI_0_OSC_AMPCOMPCTL_IBIAS_INIT_S                                   16

// Field:  [15:8] LPM_IBIAS_WAIT_CNT_FINAL
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPCTL_LPM_IBIAS_WAIT_CNT_FINAL_W                      8
#define DDI_0_OSC_AMPCOMPCTL_LPM_IBIAS_WAIT_CNT_FINAL_M             0x0000FF00
#define DDI_0_OSC_AMPCOMPCTL_LPM_IBIAS_WAIT_CNT_FINAL_S                      8

// Field:   [7:4] CAP_STEP
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPCTL_CAP_STEP_W                                      4
#define DDI_0_OSC_AMPCOMPCTL_CAP_STEP_M                             0x000000F0
#define DDI_0_OSC_AMPCOMPCTL_CAP_STEP_S                                      4

// Field:   [3:0] IBIASCAP_HPTOLP_OL_CNT
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPCTL_IBIASCAP_HPTOLP_OL_CNT_W                        4
#define DDI_0_OSC_AMPCOMPCTL_IBIASCAP_HPTOLP_OL_CNT_M               0x0000000F
#define DDI_0_OSC_AMPCOMPCTL_IBIASCAP_HPTOLP_OL_CNT_S                        0

//*****************************************************************************
//
// Register: DDI_0_OSC_O_AMPCOMPTH1
//
//*****************************************************************************
// Field: [23:18] HPMRAMP3_LTH
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPTH1_HPMRAMP3_LTH_W                                  6
#define DDI_0_OSC_AMPCOMPTH1_HPMRAMP3_LTH_M                         0x00FC0000
#define DDI_0_OSC_AMPCOMPTH1_HPMRAMP3_LTH_S                                 18

// Field: [15:10] HPMRAMP3_HTH
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPTH1_HPMRAMP3_HTH_W                                  6
#define DDI_0_OSC_AMPCOMPTH1_HPMRAMP3_HTH_M                         0x0000FC00
#define DDI_0_OSC_AMPCOMPTH1_HPMRAMP3_HTH_S                                 10

// Field:   [9:6] IBIASCAP_LPTOHP_OL_CNT
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPTH1_IBIASCAP_LPTOHP_OL_CNT_W                        4
#define DDI_0_OSC_AMPCOMPTH1_IBIASCAP_LPTOHP_OL_CNT_M               0x000003C0
#define DDI_0_OSC_AMPCOMPTH1_IBIASCAP_LPTOHP_OL_CNT_S                        6

// Field:   [5:0] HPMRAMP1_TH
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPTH1_HPMRAMP1_TH_W                                   6
#define DDI_0_OSC_AMPCOMPTH1_HPMRAMP1_TH_M                          0x0000003F
#define DDI_0_OSC_AMPCOMPTH1_HPMRAMP1_TH_S                                   0

//*****************************************************************************
//
// Register: DDI_0_OSC_O_AMPCOMPTH2
//
//*****************************************************************************
// Field: [31:26] LPMUPDATE_LTH
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPTH2_LPMUPDATE_LTH_W                                 6
#define DDI_0_OSC_AMPCOMPTH2_LPMUPDATE_LTH_M                        0xFC000000
#define DDI_0_OSC_AMPCOMPTH2_LPMUPDATE_LTH_S                                26

// Field: [23:18] LPMUPDATE_HTH
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPTH2_LPMUPDATE_HTH_W                                 6
#define DDI_0_OSC_AMPCOMPTH2_LPMUPDATE_HTH_M                        0x00FC0000
#define DDI_0_OSC_AMPCOMPTH2_LPMUPDATE_HTH_S                                18

// Field: [15:10] ADC_COMP_AMPTH_LPM
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPTH2_ADC_COMP_AMPTH_LPM_W                            6
#define DDI_0_OSC_AMPCOMPTH2_ADC_COMP_AMPTH_LPM_M                   0x0000FC00
#define DDI_0_OSC_AMPCOMPTH2_ADC_COMP_AMPTH_LPM_S                           10

// Field:   [7:2] ADC_COMP_AMPTH_HPM
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_AMPCOMPTH2_ADC_COMP_AMPTH_HPM_W                            6
#define DDI_0_OSC_AMPCOMPTH2_ADC_COMP_AMPTH_HPM_M                   0x000000FC
#define DDI_0_OSC_AMPCOMPTH2_ADC_COMP_AMPTH_HPM_S                            2

//*****************************************************************************
//
// Register: DDI_0_OSC_O_ANABYPASSVAL1
//
//*****************************************************************************
// Field: [19:16] XOSC_HF_ROW_Q12
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_ANABYPASSVAL1_XOSC_HF_ROW_Q12_W                            4
#define DDI_0_OSC_ANABYPASSVAL1_XOSC_HF_ROW_Q12_M                   0x000F0000
#define DDI_0_OSC_ANABYPASSVAL1_XOSC_HF_ROW_Q12_S                           16

// Field:  [15:0] XOSC_HF_COLUMN_Q12
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_ANABYPASSVAL1_XOSC_HF_COLUMN_Q12_W                        16
#define DDI_0_OSC_ANABYPASSVAL1_XOSC_HF_COLUMN_Q12_M                0x0000FFFF
#define DDI_0_OSC_ANABYPASSVAL1_XOSC_HF_COLUMN_Q12_S                         0

//*****************************************************************************
//
// Register: DDI_0_OSC_O_ANABYPASSVAL2
//
//*****************************************************************************
// Field:  [13:0] XOSC_HF_IBIASTHERM
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_ANABYPASSVAL2_XOSC_HF_IBIASTHERM_W                        14
#define DDI_0_OSC_ANABYPASSVAL2_XOSC_HF_IBIASTHERM_M                0x00003FFF
#define DDI_0_OSC_ANABYPASSVAL2_XOSC_HF_IBIASTHERM_S                         0

//*****************************************************************************
//
// Register: DDI_0_OSC_O_ATESTCTL
//
//*****************************************************************************
// Field:    [31] SCLK_LF_AUX_EN
//
// Enable 32 kHz clock to AUX_COMPB.
#define DDI_0_OSC_ATESTCTL_SCLK_LF_AUX_EN                           0x80000000
#define DDI_0_OSC_ATESTCTL_SCLK_LF_AUX_EN_M                         0x80000000
#define DDI_0_OSC_ATESTCTL_SCLK_LF_AUX_EN_S                                 31

// Field: [15:14] TEST_RCOSCMF
//
// Test mode control for RCOSC_MF
//
// 0x0:  test modes disabled
// 0x1:  boosted bias current into self biased inverter
// 0x2:  clock qualification disabled
// 0x3:  boosted bias current into self biased inverter + clock qualification
// disabled
#define DDI_0_OSC_ATESTCTL_TEST_RCOSCMF_W                                    2
#define DDI_0_OSC_ATESTCTL_TEST_RCOSCMF_M                           0x0000C000
#define DDI_0_OSC_ATESTCTL_TEST_RCOSCMF_S                                   14

// Field: [13:12] ATEST_RCOSCMF
//
// ATEST control for RCOSC_MF
//
// 0x0:  ATEST disabled
// 0x1:  ATEST enabled, VDD_LOCAL connected,  ATEST internal to **RCOSC_MF*
// enabled to send out 2MHz clock.
// 0x2:  ATEST disabled
// 0x3:  ATEST enabled, bias current connected, ATEST internal to **RCOSC_MF*
// enabled to send out 2MHz clock.
#define DDI_0_OSC_ATESTCTL_ATEST_RCOSCMF_W                                   2
#define DDI_0_OSC_ATESTCTL_ATEST_RCOSCMF_M                          0x00003000
#define DDI_0_OSC_ATESTCTL_ATEST_RCOSCMF_S                                  12

//*****************************************************************************
//
// Register: DDI_0_OSC_O_ADCDOUBLERNANOAMPCTL
//
//*****************************************************************************
// Field:    [24] NANOAMP_BIAS_ENABLE
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_NANOAMP_BIAS_ENABLE          0x01000000
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_NANOAMP_BIAS_ENABLE_M        0x01000000
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_NANOAMP_BIAS_ENABLE_S                24

// Field:    [23] SPARE23
//
// Software should not rely on the value of a reserved. Writing any other value
// than the reset value may result in undefined behavior
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_SPARE23                      0x00800000
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_SPARE23_M                    0x00800000
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_SPARE23_S                            23

// Field:     [5] ADC_SH_MODE_EN
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_ADC_SH_MODE_EN               0x00000020
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_ADC_SH_MODE_EN_M             0x00000020
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_ADC_SH_MODE_EN_S                      5

// Field:     [4] ADC_SH_VBUF_EN
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_ADC_SH_VBUF_EN               0x00000010
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_ADC_SH_VBUF_EN_M             0x00000010
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_ADC_SH_VBUF_EN_S                      4

// Field:   [1:0] ADC_IREF_CTRL
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_ADC_IREF_CTRL_W                       2
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_ADC_IREF_CTRL_M              0x00000003
#define DDI_0_OSC_ADCDOUBLERNANOAMPCTL_ADC_IREF_CTRL_S                       0

//*****************************************************************************
//
// Register: DDI_0_OSC_O_XOSCHFCTL
//
//*****************************************************************************
// Field:    [13] TCXO_MODE_XOSC_HF_EN
//
// If this register  is 1 when TCXO_MODE  is 1, then the XOSC_HF is enabled,
// turning on the XOSC_HF bias current allowing a DC bias point to be provided
// to the clipped-sine wave clock signal on external input.
#define DDI_0_OSC_XOSCHFCTL_TCXO_MODE_XOSC_HF_EN                    0x00002000
#define DDI_0_OSC_XOSCHFCTL_TCXO_MODE_XOSC_HF_EN_M                  0x00002000
#define DDI_0_OSC_XOSCHFCTL_TCXO_MODE_XOSC_HF_EN_S                          13

// Field:    [12] TCXO_MODE
//
// If this register  is 1  when BYPASS is  1, this will enable clock
// qualification on the TCXO clock on external input.  This register has no
// effect when BYPASS is 0.
#define DDI_0_OSC_XOSCHFCTL_TCXO_MODE                               0x00001000
#define DDI_0_OSC_XOSCHFCTL_TCXO_MODE_M                             0x00001000
#define DDI_0_OSC_XOSCHFCTL_TCXO_MODE_S                                     12

// Field:   [9:8] PEAK_DET_ITRIM
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_XOSCHFCTL_PEAK_DET_ITRIM_W                                 2
#define DDI_0_OSC_XOSCHFCTL_PEAK_DET_ITRIM_M                        0x00000300
#define DDI_0_OSC_XOSCHFCTL_PEAK_DET_ITRIM_S                                 8

// Field:     [6] BYPASS
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_XOSCHFCTL_BYPASS                                  0x00000040
#define DDI_0_OSC_XOSCHFCTL_BYPASS_M                                0x00000040
#define DDI_0_OSC_XOSCHFCTL_BYPASS_S                                         6

// Field:   [4:2] HP_BUF_ITRIM
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_XOSCHFCTL_HP_BUF_ITRIM_W                                   3
#define DDI_0_OSC_XOSCHFCTL_HP_BUF_ITRIM_M                          0x0000001C
#define DDI_0_OSC_XOSCHFCTL_HP_BUF_ITRIM_S                                   2

// Field:   [1:0] LP_BUF_ITRIM
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_XOSCHFCTL_LP_BUF_ITRIM_W                                   2
#define DDI_0_OSC_XOSCHFCTL_LP_BUF_ITRIM_M                          0x00000003
#define DDI_0_OSC_XOSCHFCTL_LP_BUF_ITRIM_S                                   0

//*****************************************************************************
//
// Register: DDI_0_OSC_O_LFOSCCTL
//
//*****************************************************************************
// Field: [23:22] XOSCLF_REGULATOR_TRIM
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_LFOSCCTL_XOSCLF_REGULATOR_TRIM_W                           2
#define DDI_0_OSC_LFOSCCTL_XOSCLF_REGULATOR_TRIM_M                  0x00C00000
#define DDI_0_OSC_LFOSCCTL_XOSCLF_REGULATOR_TRIM_S                          22

// Field: [21:18] XOSCLF_CMIRRWR_RATIO
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_LFOSCCTL_XOSCLF_CMIRRWR_RATIO_W                            4
#define DDI_0_OSC_LFOSCCTL_XOSCLF_CMIRRWR_RATIO_M                   0x003C0000
#define DDI_0_OSC_LFOSCCTL_XOSCLF_CMIRRWR_RATIO_S                           18

// Field:   [9:8] RCOSCLF_RTUNE_TRIM
//
// Internal. Only to be used through TI provided API.
// ENUMs:
// 6P0MEG                   Internal. Only to be used through TI provided API.
// 6P5MEG                   Internal. Only to be used through TI provided API.
// 7P0MEG                   Internal. Only to be used through TI provided API.
// 7P5MEG                   Internal. Only to be used through TI provided API.
#define DDI_0_OSC_LFOSCCTL_RCOSCLF_RTUNE_TRIM_W                              2
#define DDI_0_OSC_LFOSCCTL_RCOSCLF_RTUNE_TRIM_M                     0x00000300
#define DDI_0_OSC_LFOSCCTL_RCOSCLF_RTUNE_TRIM_S                              8
#define DDI_0_OSC_LFOSCCTL_RCOSCLF_RTUNE_TRIM_6P0MEG                0x00000300
#define DDI_0_OSC_LFOSCCTL_RCOSCLF_RTUNE_TRIM_6P5MEG                0x00000200
#define DDI_0_OSC_LFOSCCTL_RCOSCLF_RTUNE_TRIM_7P0MEG                0x00000100
#define DDI_0_OSC_LFOSCCTL_RCOSCLF_RTUNE_TRIM_7P5MEG                0x00000000

// Field:   [7:0] RCOSCLF_CTUNE_TRIM
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_LFOSCCTL_RCOSCLF_CTUNE_TRIM_W                              8
#define DDI_0_OSC_LFOSCCTL_RCOSCLF_CTUNE_TRIM_M                     0x000000FF
#define DDI_0_OSC_LFOSCCTL_RCOSCLF_CTUNE_TRIM_S                              0

//*****************************************************************************
//
// Register: DDI_0_OSC_O_RCOSCHFCTL
//
//*****************************************************************************
// Field:  [15:8] RCOSCHF_CTRIM
//
// Internal. Only to be used through TI provided API.
#define DDI_0_OSC_RCOSCHFCTL_RCOSCHF_CTRIM_W                                 8
#define DDI_0_OSC_RCOSCHFCTL_RCOSCHF_CTRIM_M                        0x0000FF00
#define DDI_0_OSC_RCOSCHFCTL_RCOSCHF_CTRIM_S                                 8

//*****************************************************************************
//
// Register: DDI_0_OSC_O_RCOSCMFCTL
//
//*****************************************************************************
// Field:  [15:9] RCOSC_MF_CAP_ARRAY
//
// Adjust RCOSC_MF capacitor array.
//
// 0x0:  nominal frequency, 0.625pF
// 0x40:  highest frequency, 0.125pF
// 0x3F:  lowest frequency, 1.125pF
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_CAP_ARRAY_W                            7
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_CAP_ARRAY_M                   0x0000FE00
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_CAP_ARRAY_S                            9

// Field:     [8] RCOSC_MF_REG_SEL
//
// Choose regulator type.
//
// 0:  default
// 1:  alternate
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_REG_SEL                       0x00000100
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_REG_SEL_M                     0x00000100
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_REG_SEL_S                              8

// Field:   [7:6] RCOSC_MF_RES_COARSE
//
// Select coarse resistor for frequency adjustment.
//
// 0x0:  400kohms, default
// 0x1:  300kohms, min
// 0x2:  600kohms, max
// 0x3:  500kohms
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_RES_COARSE_W                           2
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_RES_COARSE_M                  0x000000C0
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_RES_COARSE_S                           6

// Field:   [5:4] RCOSC_MF_RES_FINE
//
// Select fine resistor for frequency adjustment.
//
// 0x0:  11kohms, minimum resistance, max freq
// 0x1:  13kohms
// 0x2:  16kohms
// 0x3:  20kohms, max resistance, min freq
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_RES_FINE_W                             2
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_RES_FINE_M                    0x00000030
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_RES_FINE_S                             4

// Field:   [3:0] RCOSC_MF_BIAS_ADJ
//
// Adjusts bias current to RCOSC_MF.
//
// 0x8 minimum current
// 0x0 default current
// 0x7 maximum current
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_BIAS_ADJ_W                             4
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_BIAS_ADJ_M                    0x0000000F
#define DDI_0_OSC_RCOSCMFCTL_RCOSC_MF_BIAS_ADJ_S                             0

//*****************************************************************************
//
// Register: DDI_0_OSC_O_STAT0
//
//*****************************************************************************
// Field: [30:29] SCLK_LF_SRC
//
// Indicates source for the sclk_lf
// ENUMs:
// XOSCLF                   Low frequency XOSC
// RCOSCLF                  Low frequency RCOSC
// XOSCHFDLF                Low frequency clock derived from High Frequency
//                          XOSC
// RCOSCHFDLF               Low frequency clock derived from High Frequency
//                          RCOSC
#define DDI_0_OSC_STAT0_SCLK_LF_SRC_W                                        2
#define DDI_0_OSC_STAT0_SCLK_LF_SRC_M                               0x60000000
#define DDI_0_OSC_STAT0_SCLK_LF_SRC_S                                       29
#define DDI_0_OSC_STAT0_SCLK_LF_SRC_XOSCLF                          0x60000000
#define DDI_0_OSC_STAT0_SCLK_LF_SRC_RCOSCLF                         0x40000000
#define DDI_0_OSC_STAT0_SCLK_LF_SRC_XOSCHFDLF                       0x20000000
#define DDI_0_OSC_STAT0_SCLK_LF_SRC_RCOSCHFDLF                      0x00000000

// Field:    [28] SCLK_HF_SRC
//
// Indicates source for the sclk_hf
// ENUMs:
// XOSC                     High frequency XOSC
// RCOSC                    High frequency RCOSC clock
#define DDI_0_OSC_STAT0_SCLK_HF_SRC                                 0x10000000
#define DDI_0_OSC_STAT0_SCLK_HF_SRC_M                               0x10000000
#define DDI_0_OSC_STAT0_SCLK_HF_SRC_S                                       28
#define DDI_0_OSC_STAT0_SCLK_HF_SRC_XOSC                            0x10000000
#define DDI_0_OSC_STAT0_SCLK_HF_SRC_RCOSC                           0x00000000

// Field:    [22] RCOSC_HF_EN
//
// RCOSC_HF_EN
#define DDI_0_OSC_STAT0_RCOSC_HF_EN                                 0x00400000
#define DDI_0_OSC_STAT0_RCOSC_HF_EN_M                               0x00400000
#define DDI_0_OSC_STAT0_RCOSC_HF_EN_S                                       22

// Field:    [21] RCOSC_LF_EN
//
// RCOSC_LF_EN
#define DDI_0_OSC_STAT0_RCOSC_LF_EN                                 0x00200000
#define DDI_0_OSC_STAT0_RCOSC_LF_EN_M                               0x00200000
#define DDI_0_OSC_STAT0_RCOSC_LF_EN_S                                       21

// Field:    [20] XOSC_LF_EN
//
// XOSC_LF_EN
#define DDI_0_OSC_STAT0_XOSC_LF_EN                                  0x00100000
#define DDI_0_OSC_STAT0_XOSC_LF_EN_M                                0x00100000
#define DDI_0_OSC_STAT0_XOSC_LF_EN_S                                        20

// Field:    [19] CLK_DCDC_RDY
//
// CLK_DCDC_RDY
#define DDI_0_OSC_STAT0_CLK_DCDC_RDY                                0x00080000
#define DDI_0_OSC_STAT0_CLK_DCDC_RDY_M                              0x00080000
#define DDI_0_OSC_STAT0_CLK_DCDC_RDY_S                                      19

// Field:    [18] CLK_DCDC_RDY_ACK
//
// CLK_DCDC_RDY_ACK
#define DDI_0_OSC_STAT0_CLK_DCDC_RDY_ACK                            0x00040000
#define DDI_0_OSC_STAT0_CLK_DCDC_RDY_ACK_M                          0x00040000
#define DDI_0_OSC_STAT0_CLK_DCDC_RDY_ACK_S                                  18

// Field:    [17] SCLK_HF_LOSS
//
// Indicates sclk_hf is lost
#define DDI_0_OSC_STAT0_SCLK_HF_LOSS                                0x00020000
#define DDI_0_OSC_STAT0_SCLK_HF_LOSS_M                              0x00020000
#define DDI_0_OSC_STAT0_SCLK_HF_LOSS_S                                      17

// Field:    [16] SCLK_LF_LOSS
//
// Indicates sclk_lf is lost
#define DDI_0_OSC_STAT0_SCLK_LF_LOSS                                0x00010000
#define DDI_0_OSC_STAT0_SCLK_LF_LOSS_M                              0x00010000
#define DDI_0_OSC_STAT0_SCLK_LF_LOSS_S                                      16

// Field:    [15] XOSC_HF_EN
//
// Indicates that XOSC_HF is enabled.
#define DDI_0_OSC_STAT0_XOSC_HF_EN                                  0x00008000
#define DDI_0_OSC_STAT0_XOSC_HF_EN_M                                0x00008000
#define DDI_0_OSC_STAT0_XOSC_HF_EN_S                                        15

// Field:    [13] XB_48M_CLK_EN
//
// Indicates that the 48MHz clock from the  DOUBLER is enabled.
//
// It will be enabled if 24 or 48 MHz crystal is used (enabled in doubler
// bypass for the 48MHz crystal).
#define DDI_0_OSC_STAT0_XB_48M_CLK_EN                               0x00002000
#define DDI_0_OSC_STAT0_XB_48M_CLK_EN_M                             0x00002000
#define DDI_0_OSC_STAT0_XB_48M_CLK_EN_S                                     13

// Field:    [11] XOSC_HF_LP_BUF_EN
//
// XOSC_HF_LP_BUF_EN
#define DDI_0_OSC_STAT0_XOSC_HF_LP_BUF_EN                           0x00000800
#define DDI_0_OSC_STAT0_XOSC_HF_LP_BUF_EN_M                         0x00000800
#define DDI_0_OSC_STAT0_XOSC_HF_LP_BUF_EN_S                                 11

// Field:    [10] XOSC_HF_HP_BUF_EN
//
// XOSC_HF_HP_BUF_EN
#define DDI_0_OSC_STAT0_XOSC_HF_HP_BUF_EN                           0x00000400
#define DDI_0_OSC_STAT0_XOSC_HF_HP_BUF_EN_M                         0x00000400
#define DDI_0_OSC_STAT0_XOSC_HF_HP_BUF_EN_S                                 10

// Field:     [8] ADC_THMET
//
// ADC_THMET
#define DDI_0_OSC_STAT0_ADC_THMET                                   0x00000100
#define DDI_0_OSC_STAT0_ADC_THMET_M                                 0x00000100
#define DDI_0_OSC_STAT0_ADC_THMET_S                                          8

// Field:     [7] ADC_DATA_READY
//
// indicates when adc_data is ready.
#define DDI_0_OSC_STAT0_ADC_DATA_READY                              0x00000080
#define DDI_0_OSC_STAT0_ADC_DATA_READY_M                            0x00000080
#define DDI_0_OSC_STAT0_ADC_DATA_READY_S                                     7

// Field:   [6:1] ADC_DATA
//
// adc_data
#define DDI_0_OSC_STAT0_ADC_DATA_W                                           6
#define DDI_0_OSC_STAT0_ADC_DATA_M                                  0x0000007E
#define DDI_0_OSC_STAT0_ADC_DATA_S                                           1

// Field:     [0] PENDINGSCLKHFSWITCHING
//
// Indicates when SCLK_HF clock source is ready to be switched
#define DDI_0_OSC_STAT0_PENDINGSCLKHFSWITCHING                      0x00000001
#define DDI_0_OSC_STAT0_PENDINGSCLKHFSWITCHING_M                    0x00000001
#define DDI_0_OSC_STAT0_PENDINGSCLKHFSWITCHING_S                             0

//*****************************************************************************
//
// Register: DDI_0_OSC_O_STAT1
//
//*****************************************************************************
// Field: [31:28] RAMPSTATE
//
// AMPCOMP FSM State
// ENUMs:
// FAST_START_SETTLE        FAST_START_SETTLE
// FAST_START               FAST_START
// DUMMY_TO_INIT_1          DUMMY_TO_INIT_1
// IDAC_DEC_W_MEASURE       IDAC_DECREMENT_WITH_MEASURE
// IBIAS_INC                IBIAS_INCREMENT
// LPM_UPDATE               LPM_UPDATE
// IBIAS_DEC_W_MEASURE      IBIAS_DECREMENT_WITH_MEASURE
// IBIAS_CAP_UPDATE         IBIAS_CAP_UPDATE
// IDAC_INCREMENT           IDAC_INCREMENT
// HPM_UPDATE               HPM_UPDATE
// HPM_RAMP3                HPM_RAMP3
// HPM_RAMP2                HPM_RAMP2
// HPM_RAMP1                HPM_RAMP1
// INITIALIZATION           INITIALIZATION
// RESET                    RESET
#define DDI_0_OSC_STAT1_RAMPSTATE_W                                          4
#define DDI_0_OSC_STAT1_RAMPSTATE_M                                 0xF0000000
#define DDI_0_OSC_STAT1_RAMPSTATE_S                                         28
#define DDI_0_OSC_STAT1_RAMPSTATE_FAST_START_SETTLE                 0xE0000000
#define DDI_0_OSC_STAT1_RAMPSTATE_FAST_START                        0xD0000000
#define DDI_0_OSC_STAT1_RAMPSTATE_DUMMY_TO_INIT_1                   0xC0000000
#define DDI_0_OSC_STAT1_RAMPSTATE_IDAC_DEC_W_MEASURE                0xB0000000
#define DDI_0_OSC_STAT1_RAMPSTATE_IBIAS_INC                         0xA0000000
#define DDI_0_OSC_STAT1_RAMPSTATE_LPM_UPDATE                        0x90000000
#define DDI_0_OSC_STAT1_RAMPSTATE_IBIAS_DEC_W_MEASURE               0x80000000
#define DDI_0_OSC_STAT1_RAMPSTATE_IBIAS_CAP_UPDATE                  0x70000000
#define DDI_0_OSC_STAT1_RAMPSTATE_IDAC_INCREMENT                    0x60000000
#define DDI_0_OSC_STAT1_RAMPSTATE_HPM_UPDATE                        0x50000000
#define DDI_0_OSC_STAT1_RAMPSTATE_HPM_RAMP3                         0x40000000
#define DDI_0_OSC_STAT1_RAMPSTATE_HPM_RAMP2                         0x30000000
#define DDI_0_OSC_STAT1_RAMPSTATE_HPM_RAMP1                         0x20000000
#define DDI_0_OSC_STAT1_RAMPSTATE_INITIALIZATION                    0x10000000
#define DDI_0_OSC_STAT1_RAMPSTATE_RESET                             0x00000000

// Field: [27:22] HPM_UPDATE_AMP
//
// XOSC_HF amplitude during HPM_UPDATE state.
// When amplitude compensation of XOSC_HF is enabled in high performance mode,
// this value is the amplitude of the crystal oscillations measured by the
// on-chip oscillator ADC, divided by 15 mV.  For example, a value of 0x20
// would indicate that the amplitude of the crystal is approximately 480 mV.
// To enable amplitude compensation, AON_WUC OSCCFG must be set to a non-zero
// value.
#define DDI_0_OSC_STAT1_HPM_UPDATE_AMP_W                                     6
#define DDI_0_OSC_STAT1_HPM_UPDATE_AMP_M                            0x0FC00000
#define DDI_0_OSC_STAT1_HPM_UPDATE_AMP_S                                    22

// Field: [21:16] LPM_UPDATE_AMP
//
// XOSC_HF amplitude during LPM_UPDATE state
// When amplitude compensation of XOSC_HF is enabled in low power  mode, this
// value is the amplitude of the crystal oscillations measured by the on-chip
// oscillator ADC, divided by 15 mV.  For example, a value of 0x20 would
// indicate that the amplitude of the crystal is approximately 480 mV.  To
// enable amplitude compensation, AON_WUC OSCCFG must be set to a non-zero
// value.
#define DDI_0_OSC_STAT1_LPM_UPDATE_AMP_W                                     6
#define DDI_0_OSC_STAT1_LPM_UPDATE_AMP_M                            0x003F0000
#define DDI_0_OSC_STAT1_LPM_UPDATE_AMP_S                                    16

// Field:    [15] FORCE_RCOSC_HF
//
// force_rcosc_hf
#define DDI_0_OSC_STAT1_FORCE_RCOSC_HF                              0x00008000
#define DDI_0_OSC_STAT1_FORCE_RCOSC_HF_M                            0x00008000
#define DDI_0_OSC_STAT1_FORCE_RCOSC_HF_S                                    15

// Field:    [14] SCLK_HF_EN
//
// SCLK_HF_EN
#define DDI_0_OSC_STAT1_SCLK_HF_EN                                  0x00004000
#define DDI_0_OSC_STAT1_SCLK_HF_EN_M                                0x00004000
#define DDI_0_OSC_STAT1_SCLK_HF_EN_S                                        14

// Field:    [13] SCLK_MF_EN
//
// SCLK_MF_EN
#define DDI_0_OSC_STAT1_SCLK_MF_EN                                  0x00002000
#define DDI_0_OSC_STAT1_SCLK_MF_EN_M                                0x00002000
#define DDI_0_OSC_STAT1_SCLK_MF_EN_S                                        13

// Field:    [12] ACLK_ADC_EN
//
// ACLK_ADC_EN
#define DDI_0_OSC_STAT1_ACLK_ADC_EN                                 0x00001000
#define DDI_0_OSC_STAT1_ACLK_ADC_EN_M                               0x00001000
#define DDI_0_OSC_STAT1_ACLK_ADC_EN_S                                       12

// Field:    [11] ACLK_TDC_EN
//
// ACLK_TDC_EN
#define DDI_0_OSC_STAT1_ACLK_TDC_EN                                 0x00000800
#define DDI_0_OSC_STAT1_ACLK_TDC_EN_M                               0x00000800
#define DDI_0_OSC_STAT1_ACLK_TDC_EN_S                                       11

// Field:    [10] ACLK_REF_EN
//
// ACLK_REF_EN
#define DDI_0_OSC_STAT1_ACLK_REF_EN                                 0x00000400
#define DDI_0_OSC_STAT1_ACLK_REF_EN_M                               0x00000400
#define DDI_0_OSC_STAT1_ACLK_REF_EN_S                                       10

// Field:     [9] CLK_CHP_EN
//
// CLK_CHP_EN
#define DDI_0_OSC_STAT1_CLK_CHP_EN                                  0x00000200
#define DDI_0_OSC_STAT1_CLK_CHP_EN_M                                0x00000200
#define DDI_0_OSC_STAT1_CLK_CHP_EN_S                                         9

// Field:     [8] CLK_DCDC_EN
//
// CLK_DCDC_EN
#define DDI_0_OSC_STAT1_CLK_DCDC_EN                                 0x00000100
#define DDI_0_OSC_STAT1_CLK_DCDC_EN_M                               0x00000100
#define DDI_0_OSC_STAT1_CLK_DCDC_EN_S                                        8

// Field:     [7] SCLK_HF_GOOD
//
// SCLK_HF_GOOD
#define DDI_0_OSC_STAT1_SCLK_HF_GOOD                                0x00000080
#define DDI_0_OSC_STAT1_SCLK_HF_GOOD_M                              0x00000080
#define DDI_0_OSC_STAT1_SCLK_HF_GOOD_S                                       7

// Field:     [6] SCLK_MF_GOOD
//
// SCLK_MF_GOOD
#define DDI_0_OSC_STAT1_SCLK_MF_GOOD                                0x00000040
#define DDI_0_OSC_STAT1_SCLK_MF_GOOD_M                              0x00000040
#define DDI_0_OSC_STAT1_SCLK_MF_GOOD_S                                       6

// Field:     [5] SCLK_LF_GOOD
//
// SCLK_LF_GOOD
#define DDI_0_OSC_STAT1_SCLK_LF_GOOD                                0x00000020
#define DDI_0_OSC_STAT1_SCLK_LF_GOOD_M                              0x00000020
#define DDI_0_OSC_STAT1_SCLK_LF_GOOD_S                                       5

// Field:     [4] ACLK_ADC_GOOD
//
// ACLK_ADC_GOOD
#define DDI_0_OSC_STAT1_ACLK_ADC_GOOD                               0x00000010
#define DDI_0_OSC_STAT1_ACLK_ADC_GOOD_M                             0x00000010
#define DDI_0_OSC_STAT1_ACLK_ADC_GOOD_S                                      4

// Field:     [3] ACLK_TDC_GOOD
//
// ACLK_TDC_GOOD
#define DDI_0_OSC_STAT1_ACLK_TDC_GOOD                               0x00000008
#define DDI_0_OSC_STAT1_ACLK_TDC_GOOD_M                             0x00000008
#define DDI_0_OSC_STAT1_ACLK_TDC_GOOD_S                                      3

// Field:     [2] ACLK_REF_GOOD
//
// ACLK_REF_GOOD.
#define DDI_0_OSC_STAT1_ACLK_REF_GOOD                               0x00000004
#define DDI_0_OSC_STAT1_ACLK_REF_GOOD_M                             0x00000004
#define DDI_0_OSC_STAT1_ACLK_REF_GOOD_S                                      2

// Field:     [1] CLK_CHP_GOOD
//
// CLK_CHP_GOOD
#define DDI_0_OSC_STAT1_CLK_CHP_GOOD                                0x00000002
#define DDI_0_OSC_STAT1_CLK_CHP_GOOD_M                              0x00000002
#define DDI_0_OSC_STAT1_CLK_CHP_GOOD_S                                       1

// Field:     [0] CLK_DCDC_GOOD
//
// CLK_DCDC_GOOD
#define DDI_0_OSC_STAT1_CLK_DCDC_GOOD                               0x00000001
#define DDI_0_OSC_STAT1_CLK_DCDC_GOOD_M                             0x00000001
#define DDI_0_OSC_STAT1_CLK_DCDC_GOOD_S                                      0

//*****************************************************************************
//
// Register: DDI_0_OSC_O_STAT2
//
//*****************************************************************************
// Field: [31:26] ADC_DCBIAS
//
// DC Bias read by RADC during SAR mode
// The value is an unsigned integer. It is used for debug only.
#define DDI_0_OSC_STAT2_ADC_DCBIAS_W                                         6
#define DDI_0_OSC_STAT2_ADC_DCBIAS_M                                0xFC000000
#define DDI_0_OSC_STAT2_ADC_DCBIAS_S                                        26

// Field:    [25] HPM_RAMP1_THMET
//
// Indication of threshold is met for hpm_ramp1
#define DDI_0_OSC_STAT2_HPM_RAMP1_THMET                             0x02000000
#define DDI_0_OSC_STAT2_HPM_RAMP1_THMET_M                           0x02000000
#define DDI_0_OSC_STAT2_HPM_RAMP1_THMET_S                                   25

// Field:    [24] HPM_RAMP2_THMET
//
// Indication of threshold is met for hpm_ramp2
#define DDI_0_OSC_STAT2_HPM_RAMP2_THMET                             0x01000000
#define DDI_0_OSC_STAT2_HPM_RAMP2_THMET_M                           0x01000000
#define DDI_0_OSC_STAT2_HPM_RAMP2_THMET_S                                   24

// Field:    [23] HPM_RAMP3_THMET
//
// Indication of threshold is met for hpm_ramp3
#define DDI_0_OSC_STAT2_HPM_RAMP3_THMET                             0x00800000
#define DDI_0_OSC_STAT2_HPM_RAMP3_THMET_M                           0x00800000
#define DDI_0_OSC_STAT2_HPM_RAMP3_THMET_S                                   23

// Field: [15:12] RAMPSTATE
//
// xosc_hf amplitude compensation FSM
//
// This is identical to STAT1.RAMPSTATE. See that description for encoding.
#define DDI_0_OSC_STAT2_RAMPSTATE_W                                          4
#define DDI_0_OSC_STAT2_RAMPSTATE_M                                 0x0000F000
#define DDI_0_OSC_STAT2_RAMPSTATE_S                                         12

// Field:     [3] AMPCOMP_REQ
//
// ampcomp_req
#define DDI_0_OSC_STAT2_AMPCOMP_REQ                                 0x00000008
#define DDI_0_OSC_STAT2_AMPCOMP_REQ_M                               0x00000008
#define DDI_0_OSC_STAT2_AMPCOMP_REQ_S                                        3

// Field:     [2] XOSC_HF_AMPGOOD
//
// amplitude of xosc_hf is within the required threshold (set by DDI). Not used
// for anything just for debug/status
#define DDI_0_OSC_STAT2_XOSC_HF_AMPGOOD                             0x00000004
#define DDI_0_OSC_STAT2_XOSC_HF_AMPGOOD_M                           0x00000004
#define DDI_0_OSC_STAT2_XOSC_HF_AMPGOOD_S                                    2

// Field:     [1] XOSC_HF_FREQGOOD
//
// frequency of xosc_hf is good to use for the digital clocks
#define DDI_0_OSC_STAT2_XOSC_HF_FREQGOOD                            0x00000002
#define DDI_0_OSC_STAT2_XOSC_HF_FREQGOOD_M                          0x00000002
#define DDI_0_OSC_STAT2_XOSC_HF_FREQGOOD_S                                   1

// Field:     [0] XOSC_HF_RF_FREQGOOD
//
// frequency of xosc_hf is within +/- 20 ppm and xosc_hf is good for radio
// operations. Used for SW to start synthesizer.
#define DDI_0_OSC_STAT2_XOSC_HF_RF_FREQGOOD                         0x00000001
#define DDI_0_OSC_STAT2_XOSC_HF_RF_FREQGOOD_M                       0x00000001
#define DDI_0_OSC_STAT2_XOSC_HF_RF_FREQGOOD_S                                0

#endif // __HW_DDI_0_OSC_H__

#ifndef __HW_UART_H__
#define __HW_UART_H__

//*****************************************************************************
//
// This section defines the register offsets of
// UART component
//
//*****************************************************************************
// Data
#define UART_O_DR                                                   0x00000000

// Status
#define UART_O_RSR                                                  0x00000004

// Error Clear
#define UART_O_ECR                                                  0x00000004

// Flag
#define UART_O_FR                                                   0x00000018

// Integer Baud-Rate Divisor
#define UART_O_IBRD                                                 0x00000024

// Fractional Baud-Rate Divisor
#define UART_O_FBRD                                                 0x00000028

// Line Control
#define UART_O_LCRH                                                 0x0000002C

// Control
#define UART_O_CTL                                                  0x00000030

// Interrupt FIFO Level Select
#define UART_O_IFLS                                                 0x00000034

// Interrupt Mask Set/Clear
#define UART_O_IMSC                                                 0x00000038

// Raw Interrupt Status
#define UART_O_RIS                                                  0x0000003C

// Masked Interrupt Status
#define UART_O_MIS                                                  0x00000040

// Interrupt Clear
#define UART_O_ICR                                                  0x00000044

// DMA Control
#define UART_O_DMACTL                                               0x00000048

//*****************************************************************************
//
// Register: UART_O_DR
//
//*****************************************************************************
// Field:    [11] OE
//
// UART Overrun Error:
// This bit is set to 1 if data is received and the receive FIFO is already
// full. The FIFO contents remain valid because no more data is written when
// the FIFO is full, , only the contents of the shift register are overwritten.
// This is cleared to 0 once there is an empty space in the FIFO and a new
// character can be written to it.
#define UART_DR_OE                                                  0x00000800
#define UART_DR_OE_BITN                                                     11
#define UART_DR_OE_M                                                0x00000800
#define UART_DR_OE_S                                                        11

// Field:    [10] BE
//
// UART Break Error:
// This bit is set to 1 if a break condition was detected, indicating that the
// received data input (UARTRXD input pin) was held LOW for longer than a
// full-word transmission time (defined as start, data, parity and stop bits).
// In FIFO mode, this error is associated with the character at the top of the
// FIFO (that is., the oldest received data character since last read). When a
// break occurs, a 0 character is loaded into the FIFO. The next character is
// enabled after the receive data input (UARTRXD input pin) goes to a 1
// (marking state), and the next valid start bit is received.
#define UART_DR_BE                                                  0x00000400
#define UART_DR_BE_BITN                                                     10
#define UART_DR_BE_M                                                0x00000400
#define UART_DR_BE_S                                                        10

// Field:     [9] PE
//
// UART Parity Error:
// When set to 1, it indicates that the parity of the received data character
// does not match the parity that the LCRH.EPS and LCRH.SPS select.
// In FIFO mode, this error is associated with the character at the top of the
// FIFO (that is, the oldest received data character since last read).
#define UART_DR_PE                                                  0x00000200
#define UART_DR_PE_BITN                                                      9
#define UART_DR_PE_M                                                0x00000200
#define UART_DR_PE_S                                                         9

// Field:     [8] FE
//
// UART Framing Error:
// When set to 1, it indicates that the received character did not have a valid
// stop bit (a valid stop bit is 1).
// In FIFO mode, this error is associated with the character at the top of the
// FIFO (that is., the oldest received data character since last read).
#define UART_DR_FE                                                  0x00000100
#define UART_DR_FE_BITN                                                      8
#define UART_DR_FE_M                                                0x00000100
#define UART_DR_FE_S                                                         8

// Field:   [7:0] DATA
//
// Data transmitted or received:
// On writes, the transmit data character is pushed into the FIFO.
// On reads, the oldest received data character since the last read is
// returned.
#define UART_DR_DATA_W                                                       8
#define UART_DR_DATA_M                                              0x000000FF
#define UART_DR_DATA_S                                                       0

//*****************************************************************************
//
// Register: UART_O_RSR
//
//*****************************************************************************
// Field:     [3] OE
//
// UART Overrun Error:
// This bit is set to 1 if data is received and the receive FIFO is already
// full. The FIFO contents remain valid because no more data is written when
// the FIFO is full, , only the contents of the shift register are overwritten.
// This is cleared to 0 once there is an empty space in the FIFO and a new
// character can be written to it.
#define UART_RSR_OE                                                 0x00000008
#define UART_RSR_OE_BITN                                                     3
#define UART_RSR_OE_M                                               0x00000008
#define UART_RSR_OE_S                                                        3

// Field:     [2] BE
//
// UART Break Error:
// This bit is set to 1 if a break condition was detected, indicating that the
// received data input (UARTRXD input pin) was held LOW for longer than a
// full-word transmission time (defined as start, data, parity and stop bits).
// When a break occurs, a 0 character is loaded into the FIFO. The next
// character is enabled after the receive data input (UARTRXD input pin) goes
// to a 1 (marking state), and the next valid start bit is received.
#define UART_RSR_BE                                                 0x00000004
#define UART_RSR_BE_BITN                                                     2
#define UART_RSR_BE_M                                               0x00000004
#define UART_RSR_BE_S                                                        2

// Field:     [1] PE
//
// UART Parity Error:
// When set to 1, it indicates that the parity of the received data character
// does not match the parity that the LCRH.EPS and LCRH.SPS select.
#define UART_RSR_PE                                                 0x00000002
#define UART_RSR_PE_BITN                                                     1
#define UART_RSR_PE_M                                               0x00000002
#define UART_RSR_PE_S                                                        1

// Field:     [0] FE
//
// UART Framing Error:
// When set to 1, it indicates that the received character did not have a valid
// stop bit (a valid stop bit is 1).
#define UART_RSR_FE                                                 0x00000001
#define UART_RSR_FE_BITN                                                     0
#define UART_RSR_FE_M                                               0x00000001
#define UART_RSR_FE_S                                                        0

//*****************************************************************************
//
// Register: UART_O_ECR
//
//*****************************************************************************
// Field:     [3] OE
//
// The framing (FE), parity (PE), break (BE) and overrun (OE) errors are
// cleared to 0 by any write to this register.
#define UART_ECR_OE                                                 0x00000008
#define UART_ECR_OE_BITN                                                     3
#define UART_ECR_OE_M                                               0x00000008
#define UART_ECR_OE_S                                                        3

// Field:     [2] BE
//
// The framing (FE), parity (PE), break (BE) and overrun (OE) errors are
// cleared to 0 by any write to this register.
#define UART_ECR_BE                                                 0x00000004
#define UART_ECR_BE_BITN                                                     2
#define UART_ECR_BE_M                                               0x00000004
#define UART_ECR_BE_S                                                        2

// Field:     [1] PE
//
// The framing (FE), parity (PE), break (BE) and overrun (OE) errors are
// cleared to 0 by any write to this register.
#define UART_ECR_PE                                                 0x00000002
#define UART_ECR_PE_BITN                                                     1
#define UART_ECR_PE_M                                               0x00000002
#define UART_ECR_PE_S                                                        1

// Field:     [0] FE
//
// The framing (FE), parity (PE), break (BE) and overrun (OE) errors are
// cleared to 0 by any write to this register.
#define UART_ECR_FE                                                 0x00000001
#define UART_ECR_FE_BITN                                                     0
#define UART_ECR_FE_M                                               0x00000001
#define UART_ECR_FE_S                                                        0

//*****************************************************************************
//
// Register: UART_O_FR
//
//*****************************************************************************
// Field:     [7] TXFE
//
// UART Transmit FIFO Empty:
// The meaning of this bit depends on the state of LCRH.FEN .
//   - If the FIFO is disabled, this bit is set when the transmit holding
// register is empty.
//   - If the FIFO is enabled, this bit is set when the transmit FIFO is empty.
// This bit does not indicate if there is data in the transmit shift register.
#define UART_FR_TXFE                                                0x00000080
#define UART_FR_TXFE_BITN                                                    7
#define UART_FR_TXFE_M                                              0x00000080
#define UART_FR_TXFE_S                                                       7

// Field:     [6] RXFF
//
// UART Receive FIFO Full:
// The meaning of this bit depends on the state of LCRH.FEN.
//   - If the FIFO is disabled, this bit is set when the receive holding
// register is full.
//   - If the FIFO is enabled, this bit is set when the receive FIFO is full.
#define UART_FR_RXFF                                                0x00000040
#define UART_FR_RXFF_BITN                                                    6
#define UART_FR_RXFF_M                                              0x00000040
#define UART_FR_RXFF_S                                                       6

// Field:     [5] TXFF
//
// UART Transmit FIFO Full:
// Transmit FIFO full. The meaning of this bit depends on the state of
// LCRH.FEN.
//   - If the FIFO is disabled, this bit is set when the transmit holding
// register is full.
//   - If the FIFO is enabled, this bit is set when the transmit FIFO is full.
#define UART_FR_TXFF                                                0x00000020
#define UART_FR_TXFF_BITN                                                    5
#define UART_FR_TXFF_M                                              0x00000020
#define UART_FR_TXFF_S                                                       5

// Field:     [4] RXFE
//
// UART Receive FIFO Empty:
// Receive FIFO empty. The meaning of this bit depends on the state of
// LCRH.FEN.
//   - If the FIFO is disabled, this bit is set when the receive holding
// register is empty.
//   - If the FIFO is enabled, this bit is set when the receive FIFO is empty.
#define UART_FR_RXFE                                                0x00000010
#define UART_FR_RXFE_BITN                                                    4
#define UART_FR_RXFE_M                                              0x00000010
#define UART_FR_RXFE_S                                                       4

// Field:     [3] BUSY
//
// UART Busy:
// If this bit is set to 1, the UART is busy transmitting data. This bit
// remains set until the complete byte, including all the stop bits, has been
// sent from the shift register.
// This bit is set as soon as the transmit FIFO becomes non-empty, regardless
// of whether the UART is enabled or not.
#define UART_FR_BUSY                                                0x00000008
#define UART_FR_BUSY_BITN                                                    3
#define UART_FR_BUSY_M                                              0x00000008
#define UART_FR_BUSY_S                                                       3

// Field:     [0] CTS
//
// Clear To Send:
// This bit is the complement of the active-low UART CTS input pin.
// That is, the bit is 1 when CTS input pin is LOW.
#define UART_FR_CTS                                                 0x00000001
#define UART_FR_CTS_BITN                                                     0
#define UART_FR_CTS_M                                               0x00000001
#define UART_FR_CTS_S                                                        0

//*****************************************************************************
//
// Register: UART_O_IBRD
//
//*****************************************************************************
// Field:  [15:0] DIVINT
//
// The integer baud rate divisor:
// The baud rate divisor is calculated using the formula below:
// Baud rate divisor = (UART reference clock frequency) / (16 * Baud rate)
// Baud rate divisor must be minimum 1 and maximum 65535.
// That is, DIVINT=0 does not give a valid baud rate.
// Similarly, if DIVINT=0xFFFF, any non-zero values in FBRD.DIVFRAC will be
// illegal.
// A valid value must be written to this field before the UART can be used for
// RX or TX operations.
#define UART_IBRD_DIVINT_W                                                  16
#define UART_IBRD_DIVINT_M                                          0x0000FFFF
#define UART_IBRD_DIVINT_S                                                   0

//*****************************************************************************
//
// Register: UART_O_FBRD
//
//*****************************************************************************
// Field:   [5:0] DIVFRAC
//
// Fractional Baud-Rate Divisor:
// The baud rate divisor is calculated using the formula below:
// Baud rate divisor = (UART reference clock frequency) / (16 * Baud rate)
// Baud rate divisor must be minimum 1 and maximum 65535.
// That is, IBRD.DIVINT=0 does not give a valid baud rate.
// Similarly, if IBRD.DIVINT=0xFFFF, any non-zero values in DIVFRAC will be
// illegal.
// A valid value must be written to this field before the UART can be used for
// RX or TX operations.
#define UART_FBRD_DIVFRAC_W                                                  6
#define UART_FBRD_DIVFRAC_M                                         0x0000003F
#define UART_FBRD_DIVFRAC_S                                                  0

//*****************************************************************************
//
// Register: UART_O_LCRH
//
//*****************************************************************************
// Field:     [7] SPS
//
// UART Stick Parity Select:
//
// 0: Stick parity is disabled
// 1: The parity bit is transmitted and checked as invert of EPS field (i.e.
// the parity bit is transmitted and checked as 1 when EPS = 0).
//
// This bit has no effect when PEN disables parity checking and generation.
#define UART_LCRH_SPS                                               0x00000080
#define UART_LCRH_SPS_BITN                                                   7
#define UART_LCRH_SPS_M                                             0x00000080
#define UART_LCRH_SPS_S                                                      7

// Field:   [6:5] WLEN
//
// UART Word Length:
// These bits indicate the number of data bits transmitted or received in a
// frame.
// ENUMs:
// 8                        Word Length 8 bits
// 7                        Word Length 7 bits
// 6                        Word Length 6 bits
// 5                        Word Length 5 bits
#define UART_LCRH_WLEN_W                                                     2
#define UART_LCRH_WLEN_M                                            0x00000060
#define UART_LCRH_WLEN_S                                                     5
#define UART_LCRH_WLEN_8                                            0x00000060
#define UART_LCRH_WLEN_7                                            0x00000040
#define UART_LCRH_WLEN_6                                            0x00000020
#define UART_LCRH_WLEN_5                                            0x00000000

// Field:     [4] FEN
//
// UART Enable FIFOs
// ENUMs:
// EN                       Transmit and receive FIFO buffers are enabled
//                          (FIFO mode)
// DIS                      FIFOs are disabled (character mode) that is, the
//                          FIFOs become 1-byte-deep holding registers.
#define UART_LCRH_FEN                                               0x00000010
#define UART_LCRH_FEN_BITN                                                   4
#define UART_LCRH_FEN_M                                             0x00000010
#define UART_LCRH_FEN_S                                                      4
#define UART_LCRH_FEN_EN                                            0x00000010
#define UART_LCRH_FEN_DIS                                           0x00000000

// Field:     [3] STP2
//
// UART Two Stop Bits Select:
// If this bit is set to 1, two stop bits are transmitted at the end of the
// frame. The receive logic does not check for two stop bits being received.
#define UART_LCRH_STP1                                              0x00000000
#define UART_LCRH_STP2                                              0x00000008
#define UART_LCRH_STP2_BITN                                                  3
#define UART_LCRH_STP2_M                                            0x00000008
#define UART_LCRH_STP2_S                                                     3

// Field:     [2] EPS
//
// UART Even Parity Select
// ENUMs:
// EVEN                     Even parity: The UART generates or checks for an
//                          even number of 1s in the data and parity bits.
// ODD                      Odd parity: The UART generates or checks for an
//                          odd number of 1s in the data and parity bits.
#define UART_LCRH_EPS                                               0x00000004
#define UART_LCRH_EPS_BITN                                                   2
#define UART_LCRH_EPS_M                                             0x00000004
#define UART_LCRH_EPS_S                                                      2
#define UART_LCRH_EPS_EVEN                                          0x00000004
#define UART_LCRH_EPS_ODD                                           0x00000000

// Field:     [1] PEN
//
// UART Parity Enable
// This bit controls generation and checking of parity bit.
// ENUMs:
// EN                       Parity checking and generation is enabled.
// DIS                      Parity is disabled and no parity bit is added to
//                          the data frame
#define UART_LCRH_NO_PARITY                                         0x00000000
#define UART_LCRH_PEN                                               0x00000002
#define UART_LCRH_PEN_BITN                                                   1
#define UART_LCRH_PEN_M                                             0x00000002
#define UART_LCRH_PEN_S                                                      1
#define UART_LCRH_PEN_EN                                            0x00000002
#define UART_LCRH_PEN_DIS                                           0x00000000

// Field:     [0] BRK
//
// UART Send Break
// If this bit is set to 1, a low-level is continually output on the UARTTXD
// output pin, after completing transmission of the current character. For the
// proper execution of the break command, the
// software must set this bit for at least two complete frames. For normal use,
// this bit must be cleared to 0.
#define UART_LCRH_BRK                                               0x00000001
#define UART_LCRH_BRK_BITN                                                   0
#define UART_LCRH_BRK_M                                             0x00000001
#define UART_LCRH_BRK_S                                                      0

//*****************************************************************************
//
// Register: UART_O_CTL
//
//*****************************************************************************
// Field:    [15] CTSEN
//
// CTS hardware flow control enable
// ENUMs:
// EN                       CTS hardware flow control enabled
// DIS                      CTS hardware flow control disabled
#define UART_CTL_CTSEN                                              0x00008000
#define UART_CTL_CTSEN_BITN                                                 15
#define UART_CTL_CTSEN_M                                            0x00008000
#define UART_CTL_CTSEN_S                                                    15
#define UART_CTL_CTSEN_EN                                           0x00008000
#define UART_CTL_CTSEN_DIS                                          0x00000000

// Field:    [14] RTSEN
//
// RTS hardware flow control enable
// ENUMs:
// EN                       RTS hardware flow control enabled
// DIS                      RTS hardware flow control disabled
#define UART_CTL_RTSEN                                              0x00004000
#define UART_CTL_RTSEN_BITN                                                 14
#define UART_CTL_RTSEN_M                                            0x00004000
#define UART_CTL_RTSEN_S                                                    14
#define UART_CTL_RTSEN_EN                                           0x00004000
#define UART_CTL_RTSEN_DIS                                          0x00000000

// Field:    [11] RTS
//
// Request to Send
// This bit is the complement of the active-low UART RTS output. That is, when
// the bit is programmed to a 1 then RTS output on the pins is LOW.
#define UART_CTL_RTS                                                0x00000800
#define UART_CTL_RTS_BITN                                                   11
#define UART_CTL_RTS_M                                              0x00000800
#define UART_CTL_RTS_S                                                      11

// Field:     [9] RXE
//
// UART Receive Enable
// If the UART is disabled in the middle of reception, it completes the current
// character before stopping.
// ENUMs:
// EN                       UART Receive enabled
// DIS                      UART Receive disabled
#define UART_CTL_RXE                                                0x00000200
#define UART_CTL_RXE_BITN                                                    9
#define UART_CTL_RXE_M                                              0x00000200
#define UART_CTL_RXE_S                                                       9
#define UART_CTL_RXE_EN                                             0x00000200
#define UART_CTL_RXE_DIS                                            0x00000000

// Field:     [8] TXE
//
// UART Transmit Enable
// If the UART is disabled in the middle of transmission, it completes the
// current character before stopping.
// ENUMs:
// EN                       UART Transmit enabled
// DIS                      UART Transmit disabled
#define UART_CTL_TXE                                                0x00000100
#define UART_CTL_TXE_BITN                                                    8
#define UART_CTL_TXE_M                                              0x00000100
#define UART_CTL_TXE_S                                                       8
#define UART_CTL_TXE_EN                                             0x00000100
#define UART_CTL_TXE_DIS                                            0x00000000

// Field:     [7] LBE
//
// UART Loop Back Enable:
// Enabling the loop-back mode connects the UARTTXD output from the UART to
// UARTRXD input of the UART.
// ENUMs:
// EN                       Loop Back enabled
// DIS                      Loop Back disabled
#define UART_CTL_LBE                                                0x00000080
#define UART_CTL_LBE_BITN                                                    7
#define UART_CTL_LBE_M                                              0x00000080
#define UART_CTL_LBE_S                                                       7
#define UART_CTL_LBE_EN                                             0x00000080
#define UART_CTL_LBE_DIS                                            0x00000000

// Field:     [0] UARTEN
//
// UART Enable
// ENUMs:
// EN                       UART enabled
// DIS                      UART disabled
#define UART_CTL_UARTEN                                             0x00000001
#define UART_CTL_UARTEN_BITN                                                 0
#define UART_CTL_UARTEN_M                                           0x00000001
#define UART_CTL_UARTEN_S                                                    0
#define UART_CTL_UARTEN_EN                                          0x00000001
#define UART_CTL_UARTEN_DIS                                         0x00000000

//*****************************************************************************
//
// Register: UART_O_IFLS
//
//*****************************************************************************
// Field:   [5:3] RXSEL
//
// Receive interrupt FIFO level select:
// This field sets the trigger points for the receive interrupt. Values
// 0b101-0b111 are reserved.
// ENUMs:
// 7_8                      Receive FIFO becomes >= 7/8 full
// 6_8                      Receive FIFO becomes >= 3/4 full
// 4_8                      Receive FIFO becomes >= 1/2 full
// 2_8                      Receive FIFO becomes >= 1/4 full
// 1_8                      Receive FIFO becomes >= 1/8 full
#define UART_IFLS_RXSEL_W                                                    3
#define UART_IFLS_RXSEL_M                                           0x00000038
#define UART_IFLS_RXSEL_S                                                    3
#define UART_IFLS_RXSEL_7_8                                         0x00000020
#define UART_IFLS_RXSEL_6_8                                         0x00000018
#define UART_IFLS_RXSEL_4_8                                         0x00000010
#define UART_IFLS_RXSEL_2_8                                         0x00000008
#define UART_IFLS_RXSEL_1_8                                         0x00000000

// Field:   [2:0] TXSEL
//
// Transmit interrupt FIFO level select:
// This field sets the trigger points for the transmit interrupt. Values
// 0b101-0b111 are reserved.
// ENUMs:
// 7_8                      Transmit FIFO becomes <= 7/8 full
// 6_8                      Transmit FIFO becomes <= 3/4 full
// 4_8                      Transmit FIFO becomes <= 1/2 full
// 2_8                      Transmit FIFO becomes <= 1/4 full
// 1_8                      Transmit FIFO becomes <= 1/8 full
#define UART_IFLS_TXSEL_W                                                    3
#define UART_IFLS_TXSEL_M                                           0x00000007
#define UART_IFLS_TXSEL_S                                                    0
#define UART_IFLS_TXSEL_7_8                                         0x00000004
#define UART_IFLS_TXSEL_6_8                                         0x00000003
#define UART_IFLS_TXSEL_4_8                                         0x00000002
#define UART_IFLS_TXSEL_2_8                                         0x00000001
#define UART_IFLS_TXSEL_1_8                                         0x00000000

//*****************************************************************************
//
// Register: UART_O_IMSC
//
//*****************************************************************************
// Field:    [11] EOTIM
//
// End of Transmission interrupt mask. A read returns the current mask for
// UART's EoT interrupt. On a write of 1, the mask of the EoT interrupt is set
// which means the interrupt state will be reflected in MIS.EOTMIS. A write of
// 0 clears the mask which means MIS.EOTMIS will not reflect the interrupt.
#define UART_IMSC_EOTIM                                             0x00000800
#define UART_IMSC_EOTIM_BITN                                                11
#define UART_IMSC_EOTIM_M                                           0x00000800
#define UART_IMSC_EOTIM_S                                                   11

// Field:    [10] OEIM
//
// Overrun error interrupt mask. A read returns the current mask for UART's
// overrun error interrupt. On a write of 1, the mask of the overrun error
// interrupt is set which means the interrupt state will be reflected in
// MIS.OEMIS. A write of 0 clears the mask which means MIS.OEMIS will not
// reflect the interrupt.
#define UART_IMSC_OEIM                                              0x00000400
#define UART_IMSC_OEIM_BITN                                                 10
#define UART_IMSC_OEIM_M                                            0x00000400
#define UART_IMSC_OEIM_S                                                    10

// Field:     [9] BEIM
//
// Break error interrupt mask. A read returns the current mask for UART's break
// error interrupt. On a write of 1, the mask of the overrun error interrupt is
// set which means the interrupt state will be reflected in MIS.BEMIS. A write
// of 0 clears the mask which means MIS.BEMIS will not reflect the interrupt.
#define UART_IMSC_BEIM                                              0x00000200
#define UART_IMSC_BEIM_BITN                                                  9
#define UART_IMSC_BEIM_M                                            0x00000200
#define UART_IMSC_BEIM_S                                                     9

// Field:     [8] PEIM
//
// Parity error interrupt mask. A read returns the current mask for UART's
// parity error interrupt. On a write of 1, the mask of the overrun error
// interrupt is set which means the interrupt state will be reflected in
// MIS.PEMIS. A write of 0 clears the mask which means MIS.PEMIS will not
// reflect the interrupt.
#define UART_IMSC_PEIM                                              0x00000100
#define UART_IMSC_PEIM_BITN                                                  8
#define UART_IMSC_PEIM_M                                            0x00000100
#define UART_IMSC_PEIM_S                                                     8

// Field:     [7] FEIM
//
// Framing error interrupt mask. A read returns the current mask for UART's
// framing error interrupt. On a write of 1, the mask of the overrun error
// interrupt is set which means the interrupt state will be reflected in
// MIS.FEMIS. A write of 0 clears the mask which means MIS.FEMIS will not
// reflect the interrupt.
#define UART_IMSC_FEIM                                              0x00000080
#define UART_IMSC_FEIM_BITN                                                  7
#define UART_IMSC_FEIM_M                                            0x00000080
#define UART_IMSC_FEIM_S                                                     7

// Field:     [6] RTIM
//
// Receive timeout interrupt mask. A read returns the current mask for UART's
// receive timeout interrupt. On a write of 1, the mask of the overrun error
// interrupt is set which means the interrupt state will be reflected in
// MIS.RTMIS. A write of 0 clears the mask which means this bitfield will not
// reflect the interrupt.
// The raw interrupt for receive timeout RIS.RTRIS cannot be set unless the
// mask is set (RTIM = 1). This is because the mask acts as an enable for power
// saving. That is, the same status can be read from MIS.RTMIS and RIS.RTRIS.
#define UART_IMSC_RTIM                                              0x00000040
#define UART_IMSC_RTIM_BITN                                                  6
#define UART_IMSC_RTIM_M                                            0x00000040
#define UART_IMSC_RTIM_S                                                     6

// Field:     [5] TXIM
//
// Transmit interrupt mask. A read returns the current mask for UART's transmit
// interrupt. On a write of 1, the mask of the overrun error interrupt is set
// which means the interrupt state will be reflected in MIS.TXMIS. A write of 0
// clears the mask which means MIS.TXMIS will not reflect the interrupt.
#define UART_IMSC_TXIM                                              0x00000020
#define UART_IMSC_TXIM_BITN                                                  5
#define UART_IMSC_TXIM_M                                            0x00000020
#define UART_IMSC_TXIM_S                                                     5

// Field:     [4] RXIM
//
// Receive interrupt mask. A read returns the current mask for UART's receive
// interrupt. On a write of 1, the mask of the overrun error interrupt is set
// which means the interrupt state will be reflected in MIS.RXMIS. A write of 0
// clears the mask which means MIS.RXMIS will not reflect the interrupt.
#define UART_IMSC_RXIM                                              0x00000010
#define UART_IMSC_RXIM_BITN                                                  4
#define UART_IMSC_RXIM_M                                            0x00000010
#define UART_IMSC_RXIM_S                                                     4

// Field:     [1] CTSMIM
//
// Clear to Send (CTS) modem interrupt mask. A read returns the current mask
// for UART's clear to send interrupt. On a write of 1, the mask of the overrun
// error interrupt is set which means the interrupt state will be reflected in
// MIS.CTSMMIS. A write of 0 clears the mask which means MIS.CTSMMIS will not
// reflect the interrupt.
#define UART_IMSC_CTSMIM                                            0x00000002
#define UART_IMSC_CTSMIM_BITN                                                1
#define UART_IMSC_CTSMIM_M                                          0x00000002
#define UART_IMSC_CTSMIM_S                                                   1

//*****************************************************************************
//
// Register: UART_O_RIS
//
//*****************************************************************************
// Field:    [11] EOTRIS
//
// End of Transmission interrupt status:
// This field returns the raw interrupt state of UART's end of transmission
// interrupt. End of transmission flag is set when all the Transmit data in the
// FIFO and on the TX Line is tranmitted.
#define UART_RIS_EOTRIS                                             0x00000800
#define UART_RIS_EOTRIS_BITN                                                11
#define UART_RIS_EOTRIS_M                                           0x00000800
#define UART_RIS_EOTRIS_S                                                   11

// Field:    [10] OERIS
//
// Overrun error interrupt status:
// This field returns the raw interrupt state of UART's overrun error
// interrupt. Overrun error occurs if data is received and the receive FIFO is
// full.
#define UART_RIS_OERIS                                              0x00000400
#define UART_RIS_OERIS_BITN                                                 10
#define UART_RIS_OERIS_M                                            0x00000400
#define UART_RIS_OERIS_S                                                    10

// Field:     [9] BERIS
//
// Break error interrupt status:
// This field returns the raw interrupt state of UART's break error interrupt.
// Break error is set when a break condition is detected, indicating that the
// received data input (UARTRXD input pin) was held LOW for longer than a
// full-word transmission time (defined as start, data, parity and stop bits).
#define UART_RIS_BERIS                                              0x00000200
#define UART_RIS_BERIS_BITN                                                  9
#define UART_RIS_BERIS_M                                            0x00000200
#define UART_RIS_BERIS_S                                                     9

// Field:     [8] PERIS
//
// Parity error interrupt status:
// This field returns the raw interrupt state of UART's parity error interrupt.
// Parity error is set if the parity of the received data character does not
// match the parity that the LCRH.EPS and LCRH.SPS select.
#define UART_RIS_PERIS                                              0x00000100
#define UART_RIS_PERIS_BITN                                                  8
#define UART_RIS_PERIS_M                                            0x00000100
#define UART_RIS_PERIS_S                                                     8

// Field:     [7] FERIS
//
// Framing error interrupt status:
// This field returns the raw interrupt state of UART's framing error
// interrupt. Framing error is set if the received character does not have a
// valid stop bit (a valid stop bit is 1).
#define UART_RIS_FERIS                                              0x00000080
#define UART_RIS_FERIS_BITN                                                  7
#define UART_RIS_FERIS_M                                            0x00000080
#define UART_RIS_FERIS_S                                                     7

// Field:     [6] RTRIS
//
// Receive timeout interrupt status:
// This field returns the raw interrupt state of UART's receive timeout
// interrupt. The receive timeout interrupt is asserted when the receive FIFO
// is not empty, and no more data is received during a 32-bit period. The
// receive timeout interrupt is cleared either when the FIFO becomes empty
// through reading all the data, or when a 1 is written to ICR.RTIC.
// The raw interrupt for receive timeout cannot be set unless the mask is set
// (IMSC.RTIM = 1). This is because the mask acts as an enable for power
// saving. That is, the same status can be read from MIS.RTMIS and RTRIS.
#define UART_RIS_RTRIS                                              0x00000040
#define UART_RIS_RTRIS_BITN                                                  6
#define UART_RIS_RTRIS_M                                            0x00000040
#define UART_RIS_RTRIS_S                                                     6

// Field:     [5] TXRIS
//
// Transmit interrupt status:
// This field returns the raw interrupt state of UART's transmit interrupt.
// When FIFOs are enabled (LCRH.FEN = 1), the transmit interrupt is asserted if
// the number of bytes in transmit FIFO is equal to or lower than the
// programmed trigger level (IFLS.TXSEL). The transmit interrupt is cleared by
// writing data to the transmit FIFO until it becomes greater than the trigger
// level, or by clearing the interrupt through ICR.TXIC.
// When FIFOs are disabled (LCRH.FEN = 0), that is they have a depth of one
// location, the transmit interrupt is asserted if there is no data present in
// the transmitters single location. It is cleared by performing a single write
// to the transmit FIFO, or by clearing the interrupt through ICR.TXIC.
#define UART_RIS_TXRIS                                              0x00000020
#define UART_RIS_TXRIS_BITN                                                  5
#define UART_RIS_TXRIS_M                                            0x00000020
#define UART_RIS_TXRIS_S                                                     5

// Field:     [4] RXRIS
//
// Receive interrupt status:
// This field returns the raw interrupt state of UART's receive interrupt.
// When FIFOs are enabled (LCRH.FEN = 1), the receive interrupt is asserted if
// the receive FIFO reaches the programmed trigger
// level (IFLS.RXSEL). The receive interrupt is cleared by reading data from
// the receive FIFO until it becomes less than the trigger level, or by
// clearing the interrupt through ICR.RXIC.
// When FIFOs are disabled (LCRH.FEN = 0), that is they have a depth of one
// location, the receive interrupt is asserted if data is received
// thereby filling the location. The receive interrupt is cleared by performing
// a single read of the receive FIFO, or by clearing the interrupt through
// ICR.RXIC.
#define UART_RIS_RXRIS                                              0x00000010
#define UART_RIS_RXRIS_BITN                                                  4
#define UART_RIS_RXRIS_M                                            0x00000010
#define UART_RIS_RXRIS_S                                                     4

// Field:     [1] CTSRMIS
//
// Clear to Send (CTS) modem interrupt status:
// This field returns the raw interrupt state of UART's clear to send
// interrupt.
#define UART_RIS_CTSRMIS                                            0x00000002
#define UART_RIS_CTSRMIS_BITN                                                1
#define UART_RIS_CTSRMIS_M                                          0x00000002
#define UART_RIS_CTSRMIS_S                                                   1

//*****************************************************************************
//
// Register: UART_O_MIS
//
//*****************************************************************************
// Field:    [11] EOTMIS
//
// End of Transmission interrupt status:
// This field returns the masked interrupt state of the overrun interrupt which
// is the AND product of raw interrupt state RIS.EOTRIS and the mask setting
// IMSC.EOTIM.
#define UART_MIS_EOTMIS                                             0x00000800
#define UART_MIS_EOTMIS_BITN                                                11
#define UART_MIS_EOTMIS_M                                           0x00000800
#define UART_MIS_EOTMIS_S                                                   11

// Field:    [10] OEMIS
//
// Overrun error masked interrupt status:
// This field returns the masked interrupt state of the overrun interrupt which
// is the AND product of raw interrupt state RIS.OERIS and the mask setting
// IMSC.OEIM.
#define UART_MIS_OEMIS                                              0x00000400
#define UART_MIS_OEMIS_BITN                                                 10
#define UART_MIS_OEMIS_M                                            0x00000400
#define UART_MIS_OEMIS_S                                                    10

// Field:     [9] BEMIS
//
// Break error masked interrupt status:
// This field returns the masked interrupt state of the break error interrupt
// which is the AND product of raw interrupt state RIS.BERIS and the mask
// setting IMSC.BEIM.
#define UART_MIS_BEMIS                                              0x00000200
#define UART_MIS_BEMIS_BITN                                                  9
#define UART_MIS_BEMIS_M                                            0x00000200
#define UART_MIS_BEMIS_S                                                     9

// Field:     [8] PEMIS
//
// Parity error masked interrupt status:
// This field returns the masked interrupt state of the parity error interrupt
// which is the AND product of raw interrupt state RIS.PERIS and the mask
// setting IMSC.PEIM.
#define UART_MIS_PEMIS                                              0x00000100
#define UART_MIS_PEMIS_BITN                                                  8
#define UART_MIS_PEMIS_M                                            0x00000100
#define UART_MIS_PEMIS_S                                                     8

// Field:     [7] FEMIS
//
// Framing error masked interrupt status: Returns the masked interrupt state of
// the framing error interrupt which is the AND product of raw interrupt state
// RIS.FERIS and the mask setting IMSC.FEIM.
#define UART_MIS_FEMIS                                              0x00000080
#define UART_MIS_FEMIS_BITN                                                  7
#define UART_MIS_FEMIS_M                                            0x00000080
#define UART_MIS_FEMIS_S                                                     7

// Field:     [6] RTMIS
//
// Receive timeout masked interrupt status:
// Returns the masked interrupt state of the receive timeout interrupt.
// The raw interrupt for receive timeout cannot be set unless the mask is set
// (IMSC.RTIM = 1). This is because the mask acts as an enable for power
// saving. That is, the same status can be read from RTMIS and RIS.RTRIS.
#define UART_MIS_RTMIS                                              0x00000040
#define UART_MIS_RTMIS_BITN                                                  6
#define UART_MIS_RTMIS_M                                            0x00000040
#define UART_MIS_RTMIS_S                                                     6

// Field:     [5] TXMIS
//
// Transmit masked interrupt status:
// This field returns the masked interrupt state of the transmit interrupt
// which is the AND product of raw interrupt state RIS.TXRIS and the mask
// setting IMSC.TXIM.
#define UART_MIS_TXMIS                                              0x00000020
#define UART_MIS_TXMIS_BITN                                                  5
#define UART_MIS_TXMIS_M                                            0x00000020
#define UART_MIS_TXMIS_S                                                     5

// Field:     [4] RXMIS
//
// Receive masked interrupt status:
// This field returns the masked interrupt state of the receive interrupt
// which is the AND product of raw interrupt state RIS.RXRIS and the mask
// setting IMSC.RXIM.
#define UART_MIS_RXMIS                                              0x00000010
#define UART_MIS_RXMIS_BITN                                                  4
#define UART_MIS_RXMIS_M                                            0x00000010
#define UART_MIS_RXMIS_S                                                     4

// Field:     [1] CTSMMIS
//
// Clear to Send (CTS) modem masked interrupt status:
// This field returns the masked interrupt state of the clear to send interrupt
// which is the AND product of raw interrupt state RIS.CTSRMIS and the mask
// setting IMSC.CTSMIM.
#define UART_MIS_CTSMMIS                                            0x00000002
#define UART_MIS_CTSMMIS_BITN                                                1
#define UART_MIS_CTSMMIS_M                                          0x00000002
#define UART_MIS_CTSMMIS_S                                                   1

//*****************************************************************************
//
// Register: UART_O_ICR
//
//*****************************************************************************
// Field:    [11] EOTIC
//
// End of Transmission interrupt clear:
// Writing 1 to this field clears the overrun error interrupt (RIS.EOTRIS).
// Writing 0 has no effect.
#define UART_ICR_EOTIC                                              0x00000800
#define UART_ICR_EOTIC_BITN                                                 11
#define UART_ICR_EOTIC_M                                            0x00000800
#define UART_ICR_EOTIC_S                                                    11

// Field:    [10] OEIC
//
// Overrun error interrupt clear:
// Writing 1 to this field clears the overrun error interrupt (RIS.OERIS).
// Writing 0 has no effect.
#define UART_ICR_OEIC                                               0x00000400
#define UART_ICR_OEIC_BITN                                                  10
#define UART_ICR_OEIC_M                                             0x00000400
#define UART_ICR_OEIC_S                                                     10

// Field:     [9] BEIC
//
// Break error interrupt clear:
// Writing 1 to this field clears the break error interrupt (RIS.BERIS).
// Writing 0 has no effect.
#define UART_ICR_BEIC                                               0x00000200
#define UART_ICR_BEIC_BITN                                                   9
#define UART_ICR_BEIC_M                                             0x00000200
#define UART_ICR_BEIC_S                                                      9

// Field:     [8] PEIC
//
// Parity error interrupt clear:
// Writing 1 to this field clears the parity error interrupt (RIS.PERIS).
// Writing 0 has no effect.
#define UART_ICR_PEIC                                               0x00000100
#define UART_ICR_PEIC_BITN                                                   8
#define UART_ICR_PEIC_M                                             0x00000100
#define UART_ICR_PEIC_S                                                      8

// Field:     [7] FEIC
//
// Framing error interrupt clear:
// Writing 1 to this field clears the framing error interrupt (RIS.FERIS).
// Writing 0 has no effect.
#define UART_ICR_FEIC                                               0x00000080
#define UART_ICR_FEIC_BITN                                                   7
#define UART_ICR_FEIC_M                                             0x00000080
#define UART_ICR_FEIC_S                                                      7

// Field:     [6] RTIC
//
// Receive timeout interrupt clear:
// Writing 1 to this field clears the receive timeout interrupt (RIS.RTRIS).
// Writing 0 has no effect.
#define UART_ICR_RTIC                                               0x00000040
#define UART_ICR_RTIC_BITN                                                   6
#define UART_ICR_RTIC_M                                             0x00000040
#define UART_ICR_RTIC_S                                                      6

// Field:     [5] TXIC
//
// Transmit interrupt clear:
// Writing 1 to this field clears the transmit interrupt (RIS.TXRIS). Writing 0
// has no effect.
#define UART_ICR_TXIC                                               0x00000020
#define UART_ICR_TXIC_BITN                                                   5
#define UART_ICR_TXIC_M                                             0x00000020
#define UART_ICR_TXIC_S                                                      5

// Field:     [4] RXIC
//
// Receive interrupt clear:
// Writing 1 to this field clears the receive interrupt (RIS.RXRIS). Writing 0
// has no effect.
#define UART_ICR_RXIC                                               0x00000010
#define UART_ICR_RXIC_BITN                                                   4
#define UART_ICR_RXIC_M                                             0x00000010
#define UART_ICR_RXIC_S                                                      4

// Field:     [1] CTSMIC
//
// Clear to Send (CTS) modem interrupt clear:
// Writing 1 to this field clears the clear to send interrupt (RIS.CTSRMIS).
// Writing 0 has no effect.
#define UART_ICR_CTSMIC                                             0x00000002
#define UART_ICR_CTSMIC_BITN                                                 1
#define UART_ICR_CTSMIC_M                                           0x00000002
#define UART_ICR_CTSMIC_S                                                    1

//*****************************************************************************
//
// Register: UART_O_DMACTL
//
//*****************************************************************************
// Field:     [2] DMAONERR
//
// DMA on error. If this bit is set to 1, the DMA receive request outputs (for
// single and burst requests) are disabled when the UART error interrupt is
// asserted (more specifically if any of the error interrupts RIS.PERIS,
// RIS.BERIS, RIS.FERIS or RIS.OERIS are asserted).
#define UART_DMACTL_DMAONERR                                        0x00000004
#define UART_DMACTL_DMAONERR_BITN                                            2
#define UART_DMACTL_DMAONERR_M                                      0x00000004
#define UART_DMACTL_DMAONERR_S                                               2

// Field:     [1] TXDMAE
//
// Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is
// enabled.
#define UART_DMACTL_TXDMAE                                          0x00000002
#define UART_DMACTL_TXDMAE_BITN                                              1
#define UART_DMACTL_TXDMAE_M                                        0x00000002
#define UART_DMACTL_TXDMAE_S                                                 1

// Field:     [0] RXDMAE
//
// Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is
// enabled.
#define UART_DMACTL_RXDMAE                                          0x00000001
#define UART_DMACTL_RXDMAE_BITN                                              0
#define UART_DMACTL_RXDMAE_M                                        0x00000001
#define UART_DMACTL_RXDMAE_S                                                 0


#define UART_DMA_TX_CONTROL_OPTS  (\
			UDMA_SIZE_8 \
		|	UDMA_SRC_INC_8 \
		|	UDMA_DST_INC_NONE \
		|	UDMA_ARB_4 \
		|	UDMA_MODE_BASIC\
	)
	
#define UART_DMA_RX_CONTROL_OPTS  (\
			UDMA_SIZE_8 \
		|	UDMA_SRC_INC_NONE \
		|	UDMA_DST_INC_8 \
		|	UDMA_ARB_4 \
		|	UDMA_MODE_BASIC\
	)


void
UARTDisable (uint32_t ui32Base) {

	// Wait for end of TX.
	while (HWREG (ui32Base + UART_O_FR) & UART_FR_BUSY) {
	}

	// Disable the FIFO.
	HWREG(ui32Base + UART_O_LCRH) &= ~(UART_LCRH_FEN);

	// Disable the UART.
	HWREG(ui32Base + UART_O_CTL) &= ~(
			UART_CTL_UARTEN 
		|	UART_CTL_TXE 
		|	UART_CTL_RXE
	);
}

void
UARTEnable (uint32_t ui32Base) {
	// Enable the FIFO.
	//HWREG(ui32Base + UART_O_LCRH) |= UART_LCRH_FEN;

	// Enable RX, TX, and the UART.
	HWREG(ui32Base + UART_O_CTL) |= (
			UART_CTL_UARTEN 
		|	UART_CTL_TXE
		|	UART_CTL_RXE
	);
}

bool
UARTisEnabled (uint32_t ui32Base) {
	return (HWREG(ui32Base + UART_O_CTL) & UART_CTL_UARTEN) != 0;
}

void
UARTCharPut (uint32_t ui32Base, uint8_t ui8Data) {

	// to block, wait until space is available.
	while (HWREG(ui32Base + UART_O_FR) & UART_FR_TXFF);

	// Send the char.
	HWREG(ui32Base + UART_O_DR) = ui8Data;
	
	// to block..
	//while (!(HWREG(ui32Base + UART_O_FR) & UART_FR_TXFE));
	
}

#endif // __HW_UART_H__

#ifndef __PRCM_H__
#define __PRCM_H__

// from: simplelink_cc13x2_26x2_sdk_3_40_00_02/source/ti/devices/cc13x2_cc26x2/driverlib/prcm.h

#define PRCM_DOMAIN_RFCORE      0x00000001  // RF Core domain ID for
                                            // clock/power control.
#define PRCM_DOMAIN_SERIAL      0x00000002  // Serial domain ID for
                                            // clock/power control.
#define PRCM_DOMAIN_PERIPH      0x00000004  // Peripheral domain ID for
                                            // clock/power control.
#define PRCM_DOMAIN_SYSBUS      0x00000008  // Bus domain ID for clock/power
                                            // control.
#define PRCM_DOMAIN_VIMS        0x00000010  // VIMS domain ID for clock/power
                                            // control.
#define PRCM_DOMAIN_VIMS_OFF_NO_WAKEUP                                        \
                                0x00020010  // For function PRCMPowerDomainOff() it is an option to
                                            // select that VIMS power domain shall not power up
                                            // during the next wake up from uLDO (VIMS_MODE=0b10).
#define PRCM_DOMAIN_CPU         0x00000020  // CPU domain ID for clock/power
                                            // control.
#define PRCM_DOMAIN_TIMER       0x00000040  // GPT domain ID for clock
                                            // control.
#define PRCM_DOMAIN_CLKCTRL     0x00000080  // Clock Control domain ID for
                                            // clock/power control.
#define PRCM_DOMAIN_MCU         0x00000100  // Reset control for entire MCU
                                            // domain.
#define PRCM_DOMAIN_POWER_OFF   0x00000002  // The domain is powered off
#define PRCM_DOMAIN_POWER_ON    0x00000001  // The domain is powered on
#define PRCM_DOMAIN_POWER_DOWN_READY                                          \
                                0x00000000  // The domain is ready to be
                                            // powered down.

//*****************************************************************************
//
// Defines used for enabling and disabling peripheral modules in the MCU domain
// bits[11:8] Defines the index into the register offset constant tables:
//            g_pui32RCGCRegs, g_pui32SCGCRegs and g_pui32DCGCRegs
// bits[4:0]  Defines the bit position within the register pointet on in [11:8]
//
//*****************************************************************************
#define PRCM_PERIPH_TIMER0 ( 0x00000000 | ( PRCM_GPTCLKGR_CLK_EN_S           )) // Peripheral ID for GPT module 0
#define PRCM_PERIPH_TIMER1 ( 0x00000000 | ( PRCM_GPTCLKGR_CLK_EN_S       + 1 )) // Peripheral ID for GPT module 1
#define PRCM_PERIPH_TIMER2 ( 0x00000000 | ( PRCM_GPTCLKGR_CLK_EN_S       + 2 )) // Peripheral ID for GPT module 2
#define PRCM_PERIPH_TIMER3 ( 0x00000000 | ( PRCM_GPTCLKGR_CLK_EN_S       + 3 )) // Peripheral ID for GPT module 3
#define PRCM_PERIPH_SSI0   ( 0x00000100 | ( PRCM_SSICLKGR_CLK_EN_S           )) // Peripheral ID for SSI module 0
#define PRCM_PERIPH_SSI1   ( 0x00000100 | ( PRCM_SSICLKGR_CLK_EN_S       + 1 )) // Peripheral ID for SSI module 1
#define PRCM_PERIPH_UART0  ( 0x00000200 | ( PRCM_UARTCLKGR_CLK_EN_S          )) // Peripheral ID for UART module 0
#define PRCM_PERIPH_UART1  ( 0x00000200 | ( PRCM_UARTCLKGR_CLK_EN_S      + 1 )) // Peripheral ID for UART module 1
#define PRCM_PERIPH_I2C0   ( 0x00000300 | ( PRCM_I2CCLKGR_CLK_EN_S           )) // Peripheral ID for I2C module 0
#define PRCM_PERIPH_CRYPTO ( 0x00000400 | ( PRCM_SECDMACLKGR_CRYPTO_CLK_EN_S )) // Peripheral ID for CRYPTO module
#define PRCM_PERIPH_TRNG   ( 0x00000400 | ( PRCM_SECDMACLKGR_TRNG_CLK_EN_S   )) // Peripheral ID for TRNG module
#define PRCM_PERIPH_PKA    ( 0x00000400 | ( PRCM_SECDMACLKGR_PKA_CLK_EN_S    )) // Peripheral ID for PKA module
#define PRCM_PERIPH_UDMA   ( 0x00000400 | ( PRCM_SECDMACLKGR_DMA_CLK_EN_S    )) // Peripheral ID for UDMA module
#define PRCM_PERIPH_GPIO   ( 0x00000500 | ( PRCM_GPIOCLKGR_CLK_EN_S          )) // Peripheral ID for GPIO module
#define PRCM_PERIPH_I2S    ( 0x00000600 | ( PRCM_I2SCLKGR_CLK_EN_S           )) // Peripheral ID for I2S module

#endif // __PRCM_H__

#ifndef __HW_PRCM_H__
#define __HW_PRCM_H__

//*****************************************************************************
//
// This section defines the register offsets of
// PRCM component
//
//*****************************************************************************
// Infrastructure Clock Division Factor For Run Mode
#define PRCM_O_INFRCLKDIVR                                          0x00000000

// Infrastructure Clock Division Factor For Sleep Mode
#define PRCM_O_INFRCLKDIVS                                          0x00000004

// Infrastructure Clock Division Factor For DeepSleep Mode
#define PRCM_O_INFRCLKDIVDS                                         0x00000008

// MCU Voltage Domain Control
#define PRCM_O_VDCTL                                                0x0000000C

// Load PRCM Settings To CLKCTRL Power Domain
#define PRCM_O_CLKLOADCTL                                           0x00000028

// RFC Clock Gate
#define PRCM_O_RFCCLKG                                              0x0000002C

// VIMS Clock Gate
#define PRCM_O_VIMSCLKG                                             0x00000030

// SEC (PKA And TRNG And CRYPTO) And UDMA Clock Gate For Run And All Modes
#define PRCM_O_SECDMACLKGR                                          0x0000003C

// SEC (PKA And TRNG And CRYPTO) And UDMA Clock Gate For Sleep Mode
#define PRCM_O_SECDMACLKGS                                          0x00000040

// SEC (PKA And TRNG and CRYPTO) And UDMA Clock Gate For Deep Sleep Mode
#define PRCM_O_SECDMACLKGDS                                         0x00000044

// GPIO Clock Gate For Run And All Modes
#define PRCM_O_GPIOCLKGR                                            0x00000048

// GPIO Clock Gate For Sleep Mode
#define PRCM_O_GPIOCLKGS                                            0x0000004C

// GPIO Clock Gate For Deep Sleep Mode
#define PRCM_O_GPIOCLKGDS                                           0x00000050

// GPT Clock Gate For Run And All Modes
#define PRCM_O_GPTCLKGR                                             0x00000054

// GPT Clock Gate For Sleep Mode
#define PRCM_O_GPTCLKGS                                             0x00000058

// GPT Clock Gate For Deep Sleep Mode
#define PRCM_O_GPTCLKGDS                                            0x0000005C

// I2C Clock Gate For Run And All Modes
#define PRCM_O_I2CCLKGR                                             0x00000060

// I2C Clock Gate For Sleep Mode
#define PRCM_O_I2CCLKGS                                             0x00000064

// I2C Clock Gate For Deep Sleep Mode
#define PRCM_O_I2CCLKGDS                                            0x00000068

// UART Clock Gate For Run And All Modes
#define PRCM_O_UARTCLKGR                                            0x0000006C

// UART Clock Gate For Sleep Mode
#define PRCM_O_UARTCLKGS                                            0x00000070

// UART Clock Gate For Deep Sleep Mode
#define PRCM_O_UARTCLKGDS                                           0x00000074

// SSI Clock Gate For Run And All Modes
#define PRCM_O_SSICLKGR                                             0x00000078

// SSI Clock Gate For Sleep Mode
#define PRCM_O_SSICLKGS                                             0x0000007C

// SSI Clock Gate For Deep Sleep Mode
#define PRCM_O_SSICLKGDS                                            0x00000080

// I2S Clock Gate For Run And All Modes
#define PRCM_O_I2SCLKGR                                             0x00000084

// I2S Clock Gate For Sleep Mode
#define PRCM_O_I2SCLKGS                                             0x00000088

// I2S Clock Gate For Deep Sleep Mode
#define PRCM_O_I2SCLKGDS                                            0x0000008C

// Internal
#define PRCM_O_SYSBUSCLKDIV                                         0x000000B4

// Internal
#define PRCM_O_CPUCLKDIV                                            0x000000B8

// Internal
#define PRCM_O_PERBUSCPUCLKDIV                                      0x000000BC

// Internal
#define PRCM_O_PERDMACLKDIV                                         0x000000C4

// I2S Clock Control
#define PRCM_O_I2SBCLKSEL                                           0x000000C8

// GPT Scalar
#define PRCM_O_GPTCLKDIV                                            0x000000CC

// I2S Clock Control
#define PRCM_O_I2SCLKCTL                                            0x000000D0

// MCLK Division Ratio
#define PRCM_O_I2SMCLKDIV                                           0x000000D4

// BCLK Division Ratio
#define PRCM_O_I2SBCLKDIV                                           0x000000D8

// WCLK Division Ratio
#define PRCM_O_I2SWCLKDIV                                           0x000000DC

// RESET For SEC (PKA And TRNG And CRYPTO) And UDMA
#define PRCM_O_RESETSECDMA                                          0x000000F0

// RESET For GPIO IPs
#define PRCM_O_RESETGPIO                                            0x000000F4

// RESET For GPT Ips
#define PRCM_O_RESETGPT                                             0x000000F8

// RESET For I2C IPs
#define PRCM_O_RESETI2C                                             0x000000FC

// RESET For UART IPs
#define PRCM_O_RESETUART                                            0x00000100

// RESET For SSI IPs
#define PRCM_O_RESETSSI                                             0x00000104

// RESET For I2S IP
#define PRCM_O_RESETI2S                                             0x00000108

// Power Domain Control
#define PRCM_O_PDCTL0                                               0x0000012C

// RFC Power Domain Control
#define PRCM_O_PDCTL0RFC                                            0x00000130

// SERIAL Power Domain Control
#define PRCM_O_PDCTL0SERIAL                                         0x00000134

// PERIPH Power Domain Control
#define PRCM_O_PDCTL0PERIPH                                         0x00000138

// Power Domain Status
#define PRCM_O_PDSTAT0                                              0x00000140

// RFC Power Domain Status
#define PRCM_O_PDSTAT0RFC                                           0x00000144

// SERIAL Power Domain Status
#define PRCM_O_PDSTAT0SERIAL                                        0x00000148

// PERIPH Power Domain Status
#define PRCM_O_PDSTAT0PERIPH                                        0x0000014C

// Power Domain Control
#define PRCM_O_PDCTL1                                               0x0000017C

// CPU Power Domain Direct Control
#define PRCM_O_PDCTL1CPU                                            0x00000184

// RFC Power Domain Direct Control
#define PRCM_O_PDCTL1RFC                                            0x00000188

// VIMS Mode Direct Control
#define PRCM_O_PDCTL1VIMS                                           0x0000018C

// Power Manager Status
#define PRCM_O_PDSTAT1                                              0x00000194

// BUS Power Domain Direct Read Status
#define PRCM_O_PDSTAT1BUS                                           0x00000198

// RFC Power Domain Direct Read Status
#define PRCM_O_PDSTAT1RFC                                           0x0000019C

// CPU Power Domain Direct Read Status
#define PRCM_O_PDSTAT1CPU                                           0x000001A0

// VIMS Mode Direct Read Status
#define PRCM_O_PDSTAT1VIMS                                          0x000001A4

// Control To RFC
#define PRCM_O_RFCBITS                                              0x000001CC

// Selected RFC Mode
#define PRCM_O_RFCMODESEL                                           0x000001D0

// Allowed RFC Modes
#define PRCM_O_RFCMODEHWOPT                                         0x000001D4

// Power Profiler Register
#define PRCM_O_PWRPROFSTAT                                          0x000001E0

// MCU SRAM configuration
#define PRCM_O_MCUSRAMCFG                                           0x0000021C

// Memory Retention Control
#define PRCM_O_RAMRETEN                                             0x00000224

// Oscillator Interrupt Mask
#define PRCM_O_OSCIMSC                                              0x00000290

// Oscillator Raw Interrupt Status
#define PRCM_O_OSCRIS                                               0x00000294

// Oscillator Raw Interrupt Clear
#define PRCM_O_OSCICR                                               0x00000298

//*****************************************************************************
//
// Register: PRCM_O_INFRCLKDIVR
//
//*****************************************************************************
// Field:   [1:0] RATIO
//
// Division rate for clocks driving modules in the MCU_AON domain when system
// CPU is in run mode. Division ratio affects both infrastructure clock and
// perbusull clock.
// ENUMs:
// DIV32                    Divide by 32
// DIV8                     Divide by 8
// DIV2                     Divide by 2
// DIV1                     Divide by 1
#define PRCM_INFRCLKDIVR_RATIO_W                                             2
#define PRCM_INFRCLKDIVR_RATIO_M                                    0x00000003
#define PRCM_INFRCLKDIVR_RATIO_S                                             0
#define PRCM_INFRCLKDIVR_RATIO_DIV32                                0x00000003
#define PRCM_INFRCLKDIVR_RATIO_DIV8                                 0x00000002
#define PRCM_INFRCLKDIVR_RATIO_DIV2                                 0x00000001
#define PRCM_INFRCLKDIVR_RATIO_DIV1                                 0x00000000

//*****************************************************************************
//
// Register: PRCM_O_INFRCLKDIVS
//
//*****************************************************************************
// Field:   [1:0] RATIO
//
// Division rate for clocks driving modules in the MCU_AON domain when system
// CPU is in sleep mode. Division ratio affects both infrastructure clock and
// perbusull clock.
// ENUMs:
// DIV32                    Divide by 32
// DIV8                     Divide by 8
// DIV2                     Divide by 2
// DIV1                     Divide by 1
#define PRCM_INFRCLKDIVS_RATIO_W                                             2
#define PRCM_INFRCLKDIVS_RATIO_M                                    0x00000003
#define PRCM_INFRCLKDIVS_RATIO_S                                             0
#define PRCM_INFRCLKDIVS_RATIO_DIV32                                0x00000003
#define PRCM_INFRCLKDIVS_RATIO_DIV8                                 0x00000002
#define PRCM_INFRCLKDIVS_RATIO_DIV2                                 0x00000001
#define PRCM_INFRCLKDIVS_RATIO_DIV1                                 0x00000000

//*****************************************************************************
//
// Register: PRCM_O_INFRCLKDIVDS
//
//*****************************************************************************
// Field:   [1:0] RATIO
//
// Division rate for clocks driving modules in the MCU_AON domain when system
// CPU is in seepsleep mode. Division ratio affects both infrastructure clock
// and perbusull clock.
// ENUMs:
// DIV32                    Divide by 32
// DIV8                     Divide by 8
// DIV2                     Divide by 2
// DIV1                     Divide by 1
#define PRCM_INFRCLKDIVDS_RATIO_W                                            2
#define PRCM_INFRCLKDIVDS_RATIO_M                                   0x00000003
#define PRCM_INFRCLKDIVDS_RATIO_S                                            0
#define PRCM_INFRCLKDIVDS_RATIO_DIV32                               0x00000003
#define PRCM_INFRCLKDIVDS_RATIO_DIV8                                0x00000002
#define PRCM_INFRCLKDIVDS_RATIO_DIV2                                0x00000001
#define PRCM_INFRCLKDIVDS_RATIO_DIV1                                0x00000000

//*****************************************************************************
//
// Register: PRCM_O_VDCTL
//
//*****************************************************************************
// Field:     [0] ULDO
//
// Request PMCTL to switch to uLDO.
//
// 0: No request
// 1: Assert request when possible
//
// The bit will have no effect before the following requirements are met:
// 1. PDCTL1.CPU_ON = 0
// 2. PDCTL1.VIMS_MODE = x0
// 3. SECDMACLKGDS.DMA_CLK_EN = 0 and S.CRYPTO_CLK_EN] = 0 and
// SECDMACLKGR.DMA_AM_CLK_EN = 0 (Note: Settings must be loaded with
// CLKLOADCTL.LOAD)
// 4. SECDMACLKGDS.CRYPTO_CLK_EN = 0 and  SECDMACLKGR.CRYPTO_AM_CLK_EN = 0
// (Note: Settings must be loaded with CLKLOADCTL.LOAD)
// 5. I2SCLKGDS.CLK_EN = 0 and I2SCLKGR.AM_CLK_EN = 0 (Note: Settings must be
// loaded with CLKLOADCTL.LOAD)
// 6. RFC do no request access to BUS
// 7. System CPU in deepsleep
#define PRCM_VDCTL_ULDO                                             0x00000001
#define PRCM_VDCTL_ULDO_BITN                                                 0
#define PRCM_VDCTL_ULDO_M                                           0x00000001
#define PRCM_VDCTL_ULDO_S                                                    0

//*****************************************************************************
//
// Register: PRCM_O_CLKLOADCTL
//
//*****************************************************************************
// Field:     [1] LOAD_DONE
//
// Status of LOAD.
// Will be cleared to 0 when any of the registers requiring a LOAD is written
// to, and be set to 1 when a LOAD is done.
// Note that writing no change to a register will result in the LOAD_DONE being
// cleared.
//
// 0 : One or more registers have been write accessed after last LOAD
// 1 : No registers are write accessed after last LOAD
#define PRCM_CLKLOADCTL_LOAD_DONE                                   0x00000002
#define PRCM_CLKLOADCTL_LOAD_DONE_BITN                                       1
#define PRCM_CLKLOADCTL_LOAD_DONE_M                                 0x00000002
#define PRCM_CLKLOADCTL_LOAD_DONE_S                                          1

// Field:     [0] LOAD
//
//
// 0: No action
// 1: Load settings to CLKCTRL. Bit is HW cleared.
//
// Multiple changes to settings may be done before LOAD is written once so all
// changes takes place at the same time. LOAD can also be done after single
// setting updates.
//
// Registers that needs to be followed by LOAD before settings being applied
// are:
// - SYSBUSCLKDIV
// - CPUCLKDIV
// - PERBUSCPUCLKDIV
// - PERDMACLKDIV
// - PERBUSCPUCLKG
// - RFCCLKG
// - VIMSCLKG
// - SECDMACLKGR
// - SECDMACLKGS
// - SECDMACLKGDS
// - GPIOCLKGR
// - GPIOCLKGS
// - GPIOCLKGDS
// - GPTCLKGR
// - GPTCLKGS
// - GPTCLKGDS
// - GPTCLKDIV
// - I2CCLKGR
// - I2CCLKGS
// - I2CCLKGDS
// - SSICLKGR
// - SSICLKGS
// - SSICLKGDS
// - UARTCLKGR
// - UARTCLKGS
// - UARTCLKGDS
// - I2SCLKGR
// - I2SCLKGS
// - I2SCLKGDS
// - I2SBCLKSEL
// - I2SCLKCTL
// - I2SMCLKDIV
// - I2SBCLKDIV
// - I2SWCLKDIV
#define PRCM_CLKLOADCTL_LOAD                                        0x00000001
#define PRCM_CLKLOADCTL_LOAD_BITN                                            0
#define PRCM_CLKLOADCTL_LOAD_M                                      0x00000001
#define PRCM_CLKLOADCTL_LOAD_S                                               0

//*****************************************************************************
//
// Register: PRCM_O_RFCCLKG
//
//*****************************************************************************
// Field:     [0] CLK_EN
//
//
// 0: Disable Clock
// 1: Enable clock if RFC power domain is on
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_RFCCLKG_CLK_EN                                         0x00000001
#define PRCM_RFCCLKG_CLK_EN_BITN                                             0
#define PRCM_RFCCLKG_CLK_EN_M                                       0x00000001
#define PRCM_RFCCLKG_CLK_EN_S                                                0

//*****************************************************************************
//
// Register: PRCM_O_VIMSCLKG
//
//*****************************************************************************
// Field:   [1:0] CLK_EN
//
// 00: Disable clock
// 01: Disable clock when SYSBUS clock is disabled
// 11: Enable clock
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_VIMSCLKG_CLK_EN_W                                               2
#define PRCM_VIMSCLKG_CLK_EN_M                                      0x00000003
#define PRCM_VIMSCLKG_CLK_EN_S                                               0

//*****************************************************************************
//
// Register: PRCM_O_SECDMACLKGR
//
//*****************************************************************************
// Field:    [24] DMA_AM_CLK_EN
//
//
// 0: No force
// 1: Force clock on for all modes (Run, Sleep and Deep Sleep)
//
// Overrides DMA_CLK_EN, SECDMACLKGS.DMA_CLK_EN and SECDMACLKGDS.DMA_CLK_EN
// when enabled.
//
// SYSBUS clock will always run when enabled
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGR_DMA_AM_CLK_EN                              0x01000000
#define PRCM_SECDMACLKGR_DMA_AM_CLK_EN_BITN                                 24
#define PRCM_SECDMACLKGR_DMA_AM_CLK_EN_M                            0x01000000
#define PRCM_SECDMACLKGR_DMA_AM_CLK_EN_S                                    24

// Field:    [19] PKA_ZERIOZE_RESET_N
//
// Zeroization logic hardware reset.
//
// 0: pka_zeroize logic inactive.
// 1: pka_zeroize of memory  is enabled.
//
// This register must remain active until the memory are completely zeroized
// which requires 256 periods on systembus clock.
#define PRCM_SECDMACLKGR_PKA_ZERIOZE_RESET_N                        0x00080000
#define PRCM_SECDMACLKGR_PKA_ZERIOZE_RESET_N_BITN                           19
#define PRCM_SECDMACLKGR_PKA_ZERIOZE_RESET_N_M                      0x00080000
#define PRCM_SECDMACLKGR_PKA_ZERIOZE_RESET_N_S                              19

// Field:    [18] PKA_AM_CLK_EN
//
//
// 0: No force
// 1: Force clock on for all modes (Run, Sleep and Deep Sleep)
//
// Overrides PKA_CLK_EN, SECDMACLKGS.PKA_CLK_EN and SECDMACLKGDS.PKA_CLK_EN
// when enabled.
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGR_PKA_AM_CLK_EN                              0x00040000
#define PRCM_SECDMACLKGR_PKA_AM_CLK_EN_BITN                                 18
#define PRCM_SECDMACLKGR_PKA_AM_CLK_EN_M                            0x00040000
#define PRCM_SECDMACLKGR_PKA_AM_CLK_EN_S                                    18

// Field:    [17] TRNG_AM_CLK_EN
//
//
// 0: No force
// 1: Force clock on for all modes (Run, Sleep and Deep Sleep)
//
// Overrides TRNG_CLK_EN, SECDMACLKGS.TRNG_CLK_EN and SECDMACLKGDS.TRNG_CLK_EN
// when enabled.
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGR_TRNG_AM_CLK_EN                             0x00020000
#define PRCM_SECDMACLKGR_TRNG_AM_CLK_EN_BITN                                17
#define PRCM_SECDMACLKGR_TRNG_AM_CLK_EN_M                           0x00020000
#define PRCM_SECDMACLKGR_TRNG_AM_CLK_EN_S                                   17

// Field:    [16] CRYPTO_AM_CLK_EN
//
//
// 0: No force
// 1: Force clock on for all modes (Run, Sleep and Deep Sleep)
//
// Overrides CRYPTO_CLK_EN, SECDMACLKGS.CRYPTO_CLK_EN and
// SECDMACLKGDS.CRYPTO_CLK_EN when enabled.
//
// SYSBUS clock will always run when enabled
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGR_CRYPTO_AM_CLK_EN                           0x00010000
#define PRCM_SECDMACLKGR_CRYPTO_AM_CLK_EN_BITN                              16
#define PRCM_SECDMACLKGR_CRYPTO_AM_CLK_EN_M                         0x00010000
#define PRCM_SECDMACLKGR_CRYPTO_AM_CLK_EN_S                                 16

// Field:     [8] DMA_CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by DMA_AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGR_DMA_CLK_EN                                 0x00000100
#define PRCM_SECDMACLKGR_DMA_CLK_EN_BITN                                     8
#define PRCM_SECDMACLKGR_DMA_CLK_EN_M                               0x00000100
#define PRCM_SECDMACLKGR_DMA_CLK_EN_S                                        8

// Field:     [2] PKA_CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by PKA_AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGR_PKA_CLK_EN                                 0x00000004
#define PRCM_SECDMACLKGR_PKA_CLK_EN_BITN                                     2
#define PRCM_SECDMACLKGR_PKA_CLK_EN_M                               0x00000004
#define PRCM_SECDMACLKGR_PKA_CLK_EN_S                                        2

// Field:     [1] TRNG_CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by TRNG_AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGR_TRNG_CLK_EN                                0x00000002
#define PRCM_SECDMACLKGR_TRNG_CLK_EN_BITN                                    1
#define PRCM_SECDMACLKGR_TRNG_CLK_EN_M                              0x00000002
#define PRCM_SECDMACLKGR_TRNG_CLK_EN_S                                       1

// Field:     [0] CRYPTO_CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by CRYPTO_AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGR_CRYPTO_CLK_EN                              0x00000001
#define PRCM_SECDMACLKGR_CRYPTO_CLK_EN_BITN                                  0
#define PRCM_SECDMACLKGR_CRYPTO_CLK_EN_M                            0x00000001
#define PRCM_SECDMACLKGR_CRYPTO_CLK_EN_S                                     0

//*****************************************************************************
//
// Register: PRCM_O_SECDMACLKGS
//
//*****************************************************************************
// Field:     [8] DMA_CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by SECDMACLKGR.DMA_AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGS_DMA_CLK_EN                                 0x00000100
#define PRCM_SECDMACLKGS_DMA_CLK_EN_BITN                                     8
#define PRCM_SECDMACLKGS_DMA_CLK_EN_M                               0x00000100
#define PRCM_SECDMACLKGS_DMA_CLK_EN_S                                        8

// Field:     [2] PKA_CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by SECDMACLKGR.PKA_AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGS_PKA_CLK_EN                                 0x00000004
#define PRCM_SECDMACLKGS_PKA_CLK_EN_BITN                                     2
#define PRCM_SECDMACLKGS_PKA_CLK_EN_M                               0x00000004
#define PRCM_SECDMACLKGS_PKA_CLK_EN_S                                        2

// Field:     [1] TRNG_CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by SECDMACLKGR.TRNG_AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGS_TRNG_CLK_EN                                0x00000002
#define PRCM_SECDMACLKGS_TRNG_CLK_EN_BITN                                    1
#define PRCM_SECDMACLKGS_TRNG_CLK_EN_M                              0x00000002
#define PRCM_SECDMACLKGS_TRNG_CLK_EN_S                                       1

// Field:     [0] CRYPTO_CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by SECDMACLKGR.CRYPTO_AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGS_CRYPTO_CLK_EN                              0x00000001
#define PRCM_SECDMACLKGS_CRYPTO_CLK_EN_BITN                                  0
#define PRCM_SECDMACLKGS_CRYPTO_CLK_EN_M                            0x00000001
#define PRCM_SECDMACLKGS_CRYPTO_CLK_EN_S                                     0

//*****************************************************************************
//
// Register: PRCM_O_SECDMACLKGDS
//
//*****************************************************************************
// Field:     [8] DMA_CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by SECDMACLKGR.DMA_AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGDS_DMA_CLK_EN                                0x00000100
#define PRCM_SECDMACLKGDS_DMA_CLK_EN_BITN                                    8
#define PRCM_SECDMACLKGDS_DMA_CLK_EN_M                              0x00000100
#define PRCM_SECDMACLKGDS_DMA_CLK_EN_S                                       8

// Field:     [2] PKA_CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by SECDMACLKGR.PKA_AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGDS_PKA_CLK_EN                                0x00000004
#define PRCM_SECDMACLKGDS_PKA_CLK_EN_BITN                                    2
#define PRCM_SECDMACLKGDS_PKA_CLK_EN_M                              0x00000004
#define PRCM_SECDMACLKGDS_PKA_CLK_EN_S                                       2

// Field:     [1] TRNG_CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// SYSBUS clock will always run when enabled
//
// Can be forced on by SECDMACLKGR.TRNG_AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGDS_TRNG_CLK_EN                               0x00000002
#define PRCM_SECDMACLKGDS_TRNG_CLK_EN_BITN                                   1
#define PRCM_SECDMACLKGDS_TRNG_CLK_EN_M                             0x00000002
#define PRCM_SECDMACLKGDS_TRNG_CLK_EN_S                                      1

// Field:     [0] CRYPTO_CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// SYSBUS clock will always run when enabled
//
// Can be forced on by SECDMACLKGR.CRYPTO_AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_SECDMACLKGDS_CRYPTO_CLK_EN                             0x00000001
#define PRCM_SECDMACLKGDS_CRYPTO_CLK_EN_BITN                                 0
#define PRCM_SECDMACLKGDS_CRYPTO_CLK_EN_M                           0x00000001
#define PRCM_SECDMACLKGDS_CRYPTO_CLK_EN_S                                    0

//*****************************************************************************
//
// Register: PRCM_O_GPIOCLKGR
//
//*****************************************************************************
// Field:     [8] AM_CLK_EN
//
//
// 0: No force
// 1: Force clock on for all modes (Run, Sleep and Deep Sleep)
//
// Overrides CLK_EN,  GPIOCLKGS.CLK_EN and  GPIOCLKGDS.CLK_EN when enabled.
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_GPIOCLKGR_AM_CLK_EN                                    0x00000100
#define PRCM_GPIOCLKGR_AM_CLK_EN_BITN                                        8
#define PRCM_GPIOCLKGR_AM_CLK_EN_M                                  0x00000100
#define PRCM_GPIOCLKGR_AM_CLK_EN_S                                           8

// Field:     [0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_GPIOCLKGR_CLK_EN                                       0x00000001
#define PRCM_GPIOCLKGR_CLK_EN_BITN                                           0
#define PRCM_GPIOCLKGR_CLK_EN_M                                     0x00000001
#define PRCM_GPIOCLKGR_CLK_EN_S                                              0

//*****************************************************************************
//
// Register: PRCM_O_GPIOCLKGS
//
//*****************************************************************************
// Field:     [0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by GPIOCLKGR.AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_GPIOCLKGS_CLK_EN                                       0x00000001
#define PRCM_GPIOCLKGS_CLK_EN_BITN                                           0
#define PRCM_GPIOCLKGS_CLK_EN_M                                     0x00000001
#define PRCM_GPIOCLKGS_CLK_EN_S                                              0

//*****************************************************************************
//
// Register: PRCM_O_GPIOCLKGDS
//
//*****************************************************************************
// Field:     [0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by GPIOCLKGR.AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_GPIOCLKGDS_CLK_EN                                      0x00000001
#define PRCM_GPIOCLKGDS_CLK_EN_BITN                                          0
#define PRCM_GPIOCLKGDS_CLK_EN_M                                    0x00000001
#define PRCM_GPIOCLKGDS_CLK_EN_S                                             0

//*****************************************************************************
//
// Register: PRCM_O_GPTCLKGR
//
//*****************************************************************************
// Field:  [11:8] AM_CLK_EN
//
// Each bit below has the following meaning:
//
// 0: No force
// 1: Force clock on for all modes (Run, Sleep and Deep Sleep)
//
// Overrides CLK_EN,  GPTCLKGS.CLK_EN and  GPTCLKGDS.CLK_EN when enabled.
//
// ENUMs can be combined
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
// ENUMs:
// AM_GPT3                  Enable clock for GPT3  in all modes
// AM_GPT2                  Enable clock for GPT2  in all modes
// AM_GPT1                  Enable clock for GPT1  in all modes
// AM_GPT0                  Enable clock for GPT0 in all modes
#define PRCM_GPTCLKGR_AM_CLK_EN_W                                            4
#define PRCM_GPTCLKGR_AM_CLK_EN_M                                   0x00000F00
#define PRCM_GPTCLKGR_AM_CLK_EN_S                                            8
#define PRCM_GPTCLKGR_AM_CLK_EN_AM_GPT3                             0x00000800
#define PRCM_GPTCLKGR_AM_CLK_EN_AM_GPT2                             0x00000400
#define PRCM_GPTCLKGR_AM_CLK_EN_AM_GPT1                             0x00000200
#define PRCM_GPTCLKGR_AM_CLK_EN_AM_GPT0                             0x00000100

// Field:   [3:0] CLK_EN
//
// Each bit below has the following meaning:
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by AM_CLK_EN
//
// ENUMs can be combined
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
// ENUMs:
// GPT3                     Enable clock for GPT3
// GPT2                     Enable clock for GPT2
// GPT1                     Enable clock for GPT1
// GPT0                     Enable clock for GPT0
#define PRCM_GPTCLKGR_CLK_EN_W                                               4
#define PRCM_GPTCLKGR_CLK_EN_M                                      0x0000000F
#define PRCM_GPTCLKGR_CLK_EN_S                                               0
#define PRCM_GPTCLKGR_CLK_EN_GPT3                                   0x00000008
#define PRCM_GPTCLKGR_CLK_EN_GPT2                                   0x00000004
#define PRCM_GPTCLKGR_CLK_EN_GPT1                                   0x00000002
#define PRCM_GPTCLKGR_CLK_EN_GPT0                                   0x00000001

//*****************************************************************************
//
// Register: PRCM_O_GPTCLKGS
//
//*****************************************************************************
// Field:   [3:0] CLK_EN
//
// Each bit below has the following meaning:
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by GPTCLKGR.AM_CLK_EN
//
// ENUMs can be combined
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
// ENUMs:
// GPT3                     Enable clock for GPT3
// GPT2                     Enable clock for GPT2
// GPT1                     Enable clock for GPT1
// GPT0                     Enable clock for GPT0
#define PRCM_GPTCLKGS_CLK_EN_W                                               4
#define PRCM_GPTCLKGS_CLK_EN_M                                      0x0000000F
#define PRCM_GPTCLKGS_CLK_EN_S                                               0
#define PRCM_GPTCLKGS_CLK_EN_GPT3                                   0x00000008
#define PRCM_GPTCLKGS_CLK_EN_GPT2                                   0x00000004
#define PRCM_GPTCLKGS_CLK_EN_GPT1                                   0x00000002
#define PRCM_GPTCLKGS_CLK_EN_GPT0                                   0x00000001

//*****************************************************************************
//
// Register: PRCM_O_GPTCLKGDS
//
//*****************************************************************************
// Field:   [3:0] CLK_EN
//
// Each bit below has the following meaning:
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by GPTCLKGR.AM_CLK_EN
//
// ENUMs can be combined
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
// ENUMs:
// GPT3                     Enable clock for GPT3
// GPT2                     Enable clock for GPT2
// GPT1                     Enable clock for GPT1
// GPT0                     Enable clock for GPT0
#define PRCM_GPTCLKGDS_CLK_EN_W                                              4
#define PRCM_GPTCLKGDS_CLK_EN_M                                     0x0000000F
#define PRCM_GPTCLKGDS_CLK_EN_S                                              0
#define PRCM_GPTCLKGDS_CLK_EN_GPT3                                  0x00000008
#define PRCM_GPTCLKGDS_CLK_EN_GPT2                                  0x00000004
#define PRCM_GPTCLKGDS_CLK_EN_GPT1                                  0x00000002
#define PRCM_GPTCLKGDS_CLK_EN_GPT0                                  0x00000001

//*****************************************************************************
//
// Register: PRCM_O_I2CCLKGR
//
//*****************************************************************************
// Field:     [8] AM_CLK_EN
//
//
// 0: No force
// 1: Force clock on for all modes (Run, Sleep and Deep Sleep)
//
// Overrides CLK_EN,  I2CCLKGS.CLK_EN and  I2CCLKGDS.CLK_EN when enabled.
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2CCLKGR_AM_CLK_EN                                     0x00000100
#define PRCM_I2CCLKGR_AM_CLK_EN_BITN                                         8
#define PRCM_I2CCLKGR_AM_CLK_EN_M                                   0x00000100
#define PRCM_I2CCLKGR_AM_CLK_EN_S                                            8

// Field:     [0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2CCLKGR_CLK_EN                                        0x00000001
#define PRCM_I2CCLKGR_CLK_EN_BITN                                            0
#define PRCM_I2CCLKGR_CLK_EN_M                                      0x00000001
#define PRCM_I2CCLKGR_CLK_EN_S                                               0

//*****************************************************************************
//
// Register: PRCM_O_I2CCLKGS
//
//*****************************************************************************
// Field:     [0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by I2CCLKGR.AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2CCLKGS_CLK_EN                                        0x00000001
#define PRCM_I2CCLKGS_CLK_EN_BITN                                            0
#define PRCM_I2CCLKGS_CLK_EN_M                                      0x00000001
#define PRCM_I2CCLKGS_CLK_EN_S                                               0

//*****************************************************************************
//
// Register: PRCM_O_I2CCLKGDS
//
//*****************************************************************************
// Field:     [0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by I2CCLKGR.AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2CCLKGDS_CLK_EN                                       0x00000001
#define PRCM_I2CCLKGDS_CLK_EN_BITN                                           0
#define PRCM_I2CCLKGDS_CLK_EN_M                                     0x00000001
#define PRCM_I2CCLKGDS_CLK_EN_S                                              0

//*****************************************************************************
//
// Register: PRCM_O_UARTCLKGR
//
//*****************************************************************************
// Field:   [9:8] AM_CLK_EN
//
//
// 0: No force
// 1: Force clock on for all modes (Run, Sleep and Deep Sleep)
//
// Overrides CLK_EN,  UARTCLKGS.CLK_EN and  UARTCLKGDS.CLK_EN when enabled.
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
// ENUMs:
// AM_UART1                 Enable clock for UART1
// AM_UART0                 Enable clock for UART0
#define PRCM_UARTCLKGR_AM_CLK_EN_W                                           2
#define PRCM_UARTCLKGR_AM_CLK_EN_M                                  0x00000300
#define PRCM_UARTCLKGR_AM_CLK_EN_S                                           8
#define PRCM_UARTCLKGR_AM_CLK_EN_AM_UART1                           0x00000200
#define PRCM_UARTCLKGR_AM_CLK_EN_AM_UART0                           0x00000100

// Field:   [1:0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
// ENUMs:
// UART1                    Enable clock for UART1
// UART0                    Enable clock for UART0
#define PRCM_UARTCLKGR_CLK_EN_W                                              2
#define PRCM_UARTCLKGR_CLK_EN_M                                     0x00000003
#define PRCM_UARTCLKGR_CLK_EN_S                                              0
#define PRCM_UARTCLKGR_CLK_EN_UART1                                 0x00000002
#define PRCM_UARTCLKGR_CLK_EN_UART0                                 0x00000001

//*****************************************************************************
//
// Register: PRCM_O_UARTCLKGS
//
//*****************************************************************************
// Field:   [1:0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by UARTCLKGR.AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
// ENUMs:
// AM_UART1                 Enable clock for UART1
// AM_UART0                 Enable clock for UART0
#define PRCM_UARTCLKGS_CLK_EN_W                                              2
#define PRCM_UARTCLKGS_CLK_EN_M                                     0x00000003
#define PRCM_UARTCLKGS_CLK_EN_S                                              0
#define PRCM_UARTCLKGS_CLK_EN_AM_UART1                              0x00000002
#define PRCM_UARTCLKGS_CLK_EN_AM_UART0                              0x00000001

//*****************************************************************************
//
// Register: PRCM_O_UARTCLKGDS
//
//*****************************************************************************
// Field:   [1:0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by UARTCLKGR.AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
// ENUMs:
// AM_UART1                 Enable clock for UART1
// AM_UART0                 Enable clock for UART0
#define PRCM_UARTCLKGDS_CLK_EN_W                                             2
#define PRCM_UARTCLKGDS_CLK_EN_M                                    0x00000003
#define PRCM_UARTCLKGDS_CLK_EN_S                                             0
#define PRCM_UARTCLKGDS_CLK_EN_AM_UART1                             0x00000002
#define PRCM_UARTCLKGDS_CLK_EN_AM_UART0                             0x00000001

//*****************************************************************************
//
// Register: PRCM_O_SSICLKGR
//
//*****************************************************************************
// Field:   [9:8] AM_CLK_EN
//
//
// 0: No force
// 1: Force clock on for all modes (Run, Sleep and Deep Sleep)
//
// Overrides CLK_EN,  SSICLKGS.CLK_EN and  SSICLKGDS.CLK_EN when enabled.
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
// ENUMs:
// SSI1                     Enable clock for SSI1
// SSI0                     Enable clock for SSI0
#define PRCM_SSICLKGR_AM_CLK_EN_W                                            2
#define PRCM_SSICLKGR_AM_CLK_EN_M                                   0x00000300
#define PRCM_SSICLKGR_AM_CLK_EN_S                                            8
#define PRCM_SSICLKGR_AM_CLK_EN_SSI1                                0x00000200
#define PRCM_SSICLKGR_AM_CLK_EN_SSI0                                0x00000100

// Field:   [1:0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
// ENUMs:
// SSI1                     Enable clock for SSI1
// SSI0                     Enable clock for SSI0
#define PRCM_SSICLKGR_CLK_EN_W                                               2
#define PRCM_SSICLKGR_CLK_EN_M                                      0x00000003
#define PRCM_SSICLKGR_CLK_EN_S                                               0
#define PRCM_SSICLKGR_CLK_EN_SSI1                                   0x00000002
#define PRCM_SSICLKGR_CLK_EN_SSI0                                   0x00000001

//*****************************************************************************
//
// Register: PRCM_O_SSICLKGS
//
//*****************************************************************************
// Field:   [1:0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by SSICLKGR.AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
// ENUMs:
// SSI1                     Enable clock for SSI1
// SSI0                     Enable clock for SSI0
#define PRCM_SSICLKGS_CLK_EN_W                                               2
#define PRCM_SSICLKGS_CLK_EN_M                                      0x00000003
#define PRCM_SSICLKGS_CLK_EN_S                                               0
#define PRCM_SSICLKGS_CLK_EN_SSI1                                   0x00000002
#define PRCM_SSICLKGS_CLK_EN_SSI0                                   0x00000001

//*****************************************************************************
//
// Register: PRCM_O_SSICLKGDS
//
//*****************************************************************************
// Field:   [1:0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by SSICLKGR.AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
// ENUMs:
// SSI1                     Enable clock for SSI1
// SSI0                     Enable clock for SSI0
#define PRCM_SSICLKGDS_CLK_EN_W                                              2
#define PRCM_SSICLKGDS_CLK_EN_M                                     0x00000003
#define PRCM_SSICLKGDS_CLK_EN_S                                              0
#define PRCM_SSICLKGDS_CLK_EN_SSI1                                  0x00000002
#define PRCM_SSICLKGDS_CLK_EN_SSI0                                  0x00000001

//*****************************************************************************
//
// Register: PRCM_O_I2SCLKGR
//
//*****************************************************************************
// Field:     [8] AM_CLK_EN
//
//
// 0: No force
// 1: Force clock on for all modes (Run, Sleep and Deep Sleep)
//
// Overrides CLK_EN,  I2SCLKGS.CLK_EN and  I2SCLKGDS.CLK_EN when enabled.
// SYSBUS clock will always run when enabled
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2SCLKGR_AM_CLK_EN                                     0x00000100
#define PRCM_I2SCLKGR_AM_CLK_EN_BITN                                         8
#define PRCM_I2SCLKGR_AM_CLK_EN_M                                   0x00000100
#define PRCM_I2SCLKGR_AM_CLK_EN_S                                            8

// Field:     [0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2SCLKGR_CLK_EN                                        0x00000001
#define PRCM_I2SCLKGR_CLK_EN_BITN                                            0
#define PRCM_I2SCLKGR_CLK_EN_M                                      0x00000001
#define PRCM_I2SCLKGR_CLK_EN_S                                               0

//*****************************************************************************
//
// Register: PRCM_O_I2SCLKGS
//
//*****************************************************************************
// Field:     [0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// Can be forced on by I2SCLKGR.AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2SCLKGS_CLK_EN                                        0x00000001
#define PRCM_I2SCLKGS_CLK_EN_BITN                                            0
#define PRCM_I2SCLKGS_CLK_EN_M                                      0x00000001
#define PRCM_I2SCLKGS_CLK_EN_S                                               0

//*****************************************************************************
//
// Register: PRCM_O_I2SCLKGDS
//
//*****************************************************************************
// Field:     [0] CLK_EN
//
//
// 0: Disable clock
// 1: Enable clock
//
// SYSBUS clock will always run when enabled
//
// Can be forced on by I2SCLKGR.AM_CLK_EN
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2SCLKGDS_CLK_EN                                       0x00000001
#define PRCM_I2SCLKGDS_CLK_EN_BITN                                           0
#define PRCM_I2SCLKGDS_CLK_EN_M                                     0x00000001
#define PRCM_I2SCLKGDS_CLK_EN_S                                              0

//*****************************************************************************
//
// Register: PRCM_O_SYSBUSCLKDIV
//
//*****************************************************************************
// Field:   [2:0] RATIO
//
// Internal. Only to be used through TI provided API.
// ENUMs:
// DIV2                     Internal. Only to be used through TI provided API.
// DIV1                     Internal. Only to be used through TI provided API.
#define PRCM_SYSBUSCLKDIV_RATIO_W                                            3
#define PRCM_SYSBUSCLKDIV_RATIO_M                                   0x00000007
#define PRCM_SYSBUSCLKDIV_RATIO_S                                            0
#define PRCM_SYSBUSCLKDIV_RATIO_DIV2                                0x00000001
#define PRCM_SYSBUSCLKDIV_RATIO_DIV1                                0x00000000

//*****************************************************************************
//
// Register: PRCM_O_CPUCLKDIV
//
//*****************************************************************************
// Field:     [0] RATIO
//
// Internal. Only to be used through TI provided API.
// ENUMs:
// DIV2                     Internal. Only to be used through TI provided API.
// DIV1                     Internal. Only to be used through TI provided API.
#define PRCM_CPUCLKDIV_RATIO                                        0x00000001
#define PRCM_CPUCLKDIV_RATIO_BITN                                            0
#define PRCM_CPUCLKDIV_RATIO_M                                      0x00000001
#define PRCM_CPUCLKDIV_RATIO_S                                               0
#define PRCM_CPUCLKDIV_RATIO_DIV2                                   0x00000001
#define PRCM_CPUCLKDIV_RATIO_DIV1                                   0x00000000

//*****************************************************************************
//
// Register: PRCM_O_PERBUSCPUCLKDIV
//
//*****************************************************************************
// Field:   [3:0] RATIO
//
// Internal. Only to be used through TI provided API.
// ENUMs:
// DIV256                   Internal. Only to be used through TI provided API.
// DIV128                   Internal. Only to be used through TI provided API.
// DIV64                    Internal. Only to be used through TI provided API.
// DIV32                    Internal. Only to be used through TI provided API.
// DIV16                    Internal. Only to be used through TI provided API.
// DIV8                     Internal. Only to be used through TI provided API.
// DIV4                     Internal. Only to be used through TI provided API.
// DIV2                     Internal. Only to be used through TI provided API.
// DIV1                     Internal. Only to be used through TI provided API.
#define PRCM_PERBUSCPUCLKDIV_RATIO_W                                         4
#define PRCM_PERBUSCPUCLKDIV_RATIO_M                                0x0000000F
#define PRCM_PERBUSCPUCLKDIV_RATIO_S                                         0
#define PRCM_PERBUSCPUCLKDIV_RATIO_DIV256                           0x00000008
#define PRCM_PERBUSCPUCLKDIV_RATIO_DIV128                           0x00000007
#define PRCM_PERBUSCPUCLKDIV_RATIO_DIV64                            0x00000006
#define PRCM_PERBUSCPUCLKDIV_RATIO_DIV32                            0x00000005
#define PRCM_PERBUSCPUCLKDIV_RATIO_DIV16                            0x00000004
#define PRCM_PERBUSCPUCLKDIV_RATIO_DIV8                             0x00000003
#define PRCM_PERBUSCPUCLKDIV_RATIO_DIV4                             0x00000002
#define PRCM_PERBUSCPUCLKDIV_RATIO_DIV2                             0x00000001
#define PRCM_PERBUSCPUCLKDIV_RATIO_DIV1                             0x00000000

//*****************************************************************************
//
// Register: PRCM_O_PERDMACLKDIV
//
//*****************************************************************************
// Field:   [3:0] RATIO
//
// Internal. Only to be used through TI provided API.
// ENUMs:
// DIV256                   Internal. Only to be used through TI provided API.
// DIV128                   Internal. Only to be used through TI provided API.
// DIV64                    Internal. Only to be used through TI provided API.
// DIV32                    Internal. Only to be used through TI provided API.
// DIV16                    Internal. Only to be used through TI provided API.
// DIV8                     Internal. Only to be used through TI provided API.
// DIV4                     Internal. Only to be used through TI provided API.
// DIV2                     Internal. Only to be used through TI provided API.
// DIV1                     Internal. Only to be used through TI provided API.
#define PRCM_PERDMACLKDIV_RATIO_W                                            4
#define PRCM_PERDMACLKDIV_RATIO_M                                   0x0000000F
#define PRCM_PERDMACLKDIV_RATIO_S                                            0
#define PRCM_PERDMACLKDIV_RATIO_DIV256                              0x00000008
#define PRCM_PERDMACLKDIV_RATIO_DIV128                              0x00000007
#define PRCM_PERDMACLKDIV_RATIO_DIV64                               0x00000006
#define PRCM_PERDMACLKDIV_RATIO_DIV32                               0x00000005
#define PRCM_PERDMACLKDIV_RATIO_DIV16                               0x00000004
#define PRCM_PERDMACLKDIV_RATIO_DIV8                                0x00000003
#define PRCM_PERDMACLKDIV_RATIO_DIV4                                0x00000002
#define PRCM_PERDMACLKDIV_RATIO_DIV2                                0x00000001
#define PRCM_PERDMACLKDIV_RATIO_DIV1                                0x00000000

//*****************************************************************************
//
// Register: PRCM_O_I2SBCLKSEL
//
//*****************************************************************************
// Field:     [0] SRC
//
// BCLK source selector
//
// 0: Use external BCLK
// 1: Use internally generated clock
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2SBCLKSEL_SRC                                         0x00000001
#define PRCM_I2SBCLKSEL_SRC_BITN                                             0
#define PRCM_I2SBCLKSEL_SRC_M                                       0x00000001
#define PRCM_I2SBCLKSEL_SRC_S                                                0

//*****************************************************************************
//
// Register: PRCM_O_GPTCLKDIV
//
//*****************************************************************************
// Field:   [3:0] RATIO
//
// Scalar used for GPTs. The division rate will be constant and ungated for Run
// / Sleep / DeepSleep mode.   For changes to take effect, CLKLOADCTL.LOAD
// needs to be written Other values are not supported.
// ENUMs:
// DIV256                   Divide by 256
// DIV128                   Divide by 128
// DIV64                    Divide by 64
// DIV32                    Divide by 32
// DIV16                    Divide by 16
// DIV8                     Divide by 8
// DIV4                     Divide by 4
// DIV2                     Divide by 2
// DIV1                     Divide by 1
#define PRCM_GPTCLKDIV_RATIO_W                                               4
#define PRCM_GPTCLKDIV_RATIO_M                                      0x0000000F
#define PRCM_GPTCLKDIV_RATIO_S                                               0
#define PRCM_GPTCLKDIV_RATIO_DIV256                                 0x00000008
#define PRCM_GPTCLKDIV_RATIO_DIV128                                 0x00000007
#define PRCM_GPTCLKDIV_RATIO_DIV64                                  0x00000006
#define PRCM_GPTCLKDIV_RATIO_DIV32                                  0x00000005
#define PRCM_GPTCLKDIV_RATIO_DIV16                                  0x00000004
#define PRCM_GPTCLKDIV_RATIO_DIV8                                   0x00000003
#define PRCM_GPTCLKDIV_RATIO_DIV4                                   0x00000002
#define PRCM_GPTCLKDIV_RATIO_DIV2                                   0x00000001
#define PRCM_GPTCLKDIV_RATIO_DIV1                                   0x00000000

//*****************************************************************************
//
// Register: PRCM_O_I2SCLKCTL
//
//*****************************************************************************
// Field:     [3] SMPL_ON_POSEDGE
//
// On the I2S serial interface, data and WCLK is sampled and clocked out on
// opposite edges of BCLK.
//
// 0 - data and WCLK are sampled on the negative edge and clocked out on the
// positive edge.
// 1 - data and WCLK are sampled on the positive edge and clocked out on the
// negative edge.
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2SCLKCTL_SMPL_ON_POSEDGE                              0x00000008
#define PRCM_I2SCLKCTL_SMPL_ON_POSEDGE_BITN                                  3
#define PRCM_I2SCLKCTL_SMPL_ON_POSEDGE_M                            0x00000008
#define PRCM_I2SCLKCTL_SMPL_ON_POSEDGE_S                                     3

// Field:   [2:1] WCLK_PHASE
//
// Decides how the WCLK division ratio is calculated and used to generate
// different duty cycles (See I2SWCLKDIV.WDIV).
//
// 0: Single phase
// 1: Dual phase
// 2: User Defined
// 3: Reserved/Undefined
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2SCLKCTL_WCLK_PHASE_W                                          2
#define PRCM_I2SCLKCTL_WCLK_PHASE_M                                 0x00000006
#define PRCM_I2SCLKCTL_WCLK_PHASE_S                                          1

// Field:     [0] EN
//
//
// 0: MCLK, BCLK and WCLK will be static low
// 1: Enables the generation of  MCLK, BCLK and WCLK
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2SCLKCTL_EN                                           0x00000001
#define PRCM_I2SCLKCTL_EN_BITN                                               0
#define PRCM_I2SCLKCTL_EN_M                                         0x00000001
#define PRCM_I2SCLKCTL_EN_S                                                  0

//*****************************************************************************
//
// Register: PRCM_O_I2SMCLKDIV
//
//*****************************************************************************
// Field:   [9:0] MDIV
//
// An unsigned factor of the division ratio used to generate MCLK [2-1024]:
//
// MCLK = MCUCLK/MDIV[Hz]
// MCUCLK is 48MHz.
//
// A value of 0 is interpreted as 1024.
// A value of 1 is invalid.
// If MDIV is odd the low phase of the clock is one MCUCLK period longer than
// the high phase.
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2SMCLKDIV_MDIV_W                                              10
#define PRCM_I2SMCLKDIV_MDIV_M                                      0x000003FF
#define PRCM_I2SMCLKDIV_MDIV_S                                               0

//*****************************************************************************
//
// Register: PRCM_O_I2SBCLKDIV
//
//*****************************************************************************
// Field:   [9:0] BDIV
//
// An unsigned factor of the division ratio used to generate I2S BCLK [2-1024]:
//
// BCLK = MCUCLK/BDIV[Hz]
// MCUCLK is 48MHz.
//
// A value of 0 is interpreted as 1024.
// A value of 1 is invalid.
// If BDIV is odd and I2SCLKCTL.SMPL_ON_POSEDGE = 0, the low phase of the clock
// is one MCUCLK period longer than the high phase.
// If BDIV is odd and I2SCLKCTL.SMPL_ON_POSEDGE = 1 , the high phase of the
// clock is one MCUCLK period longer than the low phase.
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2SBCLKDIV_BDIV_W                                              10
#define PRCM_I2SBCLKDIV_BDIV_M                                      0x000003FF
#define PRCM_I2SBCLKDIV_BDIV_S                                               0

//*****************************************************************************
//
// Register: PRCM_O_I2SWCLKDIV
//
//*****************************************************************************
// Field:  [15:0] WDIV
//
// If I2SCLKCTL.WCLK_PHASE = 0, Single phase.
// WCLK is high one BCLK period and low WDIV[9:0] (unsigned, [1-1023]) BCLK
// periods.
//
// WCLK = MCUCLK / BDIV*(WDIV[9:0] + 1) [Hz]
// MCUCLK is 48MHz.
//
// If I2SCLKCTL.WCLK_PHASE = 1, Dual phase.
// Each phase on WCLK (50% duty cycle) is WDIV[9:0] (unsigned, [1-1023]) BCLK
// periods.
//
// WCLK = MCUCLK / BDIV*(2*WDIV[9:0]) [Hz]
//
// If I2SCLKCTL.WCLK_PHASE = 2, User defined.
// WCLK is high WDIV[7:0] (unsigned, [1-255]) BCLK periods and low WDIV[15:8]
// (unsigned, [1-255]) BCLK periods.
//
// WCLK = MCUCLK / (BDIV*(WDIV[7:0] + WDIV[15:8]) [Hz]
//
// For changes to take effect, CLKLOADCTL.LOAD needs to be written
#define PRCM_I2SWCLKDIV_WDIV_W                                              16
#define PRCM_I2SWCLKDIV_WDIV_M                                      0x0000FFFF
#define PRCM_I2SWCLKDIV_WDIV_S                                               0

//*****************************************************************************
//
// Register: PRCM_O_RESETSECDMA
//
//*****************************************************************************
// Field:     [8] DMA
//
// Write 1 to reset. HW cleared.
// Acess will only have effect when PERIPH power domain is on,
// PDSTAT0.PERIPH_ON = 1
// Before writing set FLASH:CFG.DIS_READACCESS = 1 to ensure the reset is not
// activated while executing from flash. This means one cannot execute from
// flash when using the SW reset.
#define PRCM_RESETSECDMA_DMA                                        0x00000100
#define PRCM_RESETSECDMA_DMA_BITN                                            8
#define PRCM_RESETSECDMA_DMA_M                                      0x00000100
#define PRCM_RESETSECDMA_DMA_S                                               8

// Field:     [2] PKA
//
// Write 1 to reset. HW cleared.
// Acess will only have effect when PERIPH power domain is on,
// PDSTAT0.PERIPH_ON = 1
// Before writing set FLASH:CFG.DIS_READACCESS = 1 to ensure the reset is not
// activated while executing from flash. This means one cannot execute from
// flash when using the SW reset.
#define PRCM_RESETSECDMA_PKA                                        0x00000004
#define PRCM_RESETSECDMA_PKA_BITN                                            2
#define PRCM_RESETSECDMA_PKA_M                                      0x00000004
#define PRCM_RESETSECDMA_PKA_S                                               2

// Field:     [1] TRNG
//
// Write 1 to reset. HW cleared.
// Acess will only have effect when PERIPH power domain is on,
// PDSTAT0.PERIPH_ON = 1
// Before writing set FLASH:CFG.DIS_READACCESS = 1 to ensure the reset is not
// activated while executing from flash. This means one cannot execute from
// flash when using the SW reset.
#define PRCM_RESETSECDMA_TRNG                                       0x00000002
#define PRCM_RESETSECDMA_TRNG_BITN                                           1
#define PRCM_RESETSECDMA_TRNG_M                                     0x00000002
#define PRCM_RESETSECDMA_TRNG_S                                              1

// Field:     [0] CRYPTO
//
// Write 1 to reset. HW cleared.
// Acess will only have effect when PERIPH power domain is on,
// PDSTAT0.PERIPH_ON = 1
// Before writing set FLASH:CFG.DIS_READACCESS = 1 to ensure the reset is not
// activated while executing from flash. This means one cannot execute from
// flash when using the SW reset.
#define PRCM_RESETSECDMA_CRYPTO                                     0x00000001
#define PRCM_RESETSECDMA_CRYPTO_BITN                                         0
#define PRCM_RESETSECDMA_CRYPTO_M                                   0x00000001
#define PRCM_RESETSECDMA_CRYPTO_S                                            0

//*****************************************************************************
//
// Register: PRCM_O_RESETGPIO
//
//*****************************************************************************
// Field:     [0] GPIO
//
//
// 0: No action
// 1: Reset GPIO. HW cleared.
//
// Acess will only have effect when PERIPH power domain is on,
// PDSTAT0.PERIPH_ON = 1
// Before writing set FLASH:CFG.DIS_READACCESS = 1 to ensure the reset is not
// activated while executing from flash. This means one cannot execute from
// flash when using the SW reset.
#define PRCM_RESETGPIO_GPIO                                         0x00000001
#define PRCM_RESETGPIO_GPIO_BITN                                             0
#define PRCM_RESETGPIO_GPIO_M                                       0x00000001
#define PRCM_RESETGPIO_GPIO_S                                                0

//*****************************************************************************
//
// Register: PRCM_O_RESETGPT
//
//*****************************************************************************
// Field:     [0] GPT
//
//
// 0: No action
// 1: Reset all GPTs. HW cleared.
//
// Acess will only have effect when PERIPH power domain is on,
// PDSTAT0.PERIPH_ON = 1
// Before writing set FLASH:CFG.DIS_READACCESS = 1 to ensure the reset is not
// activated while executing from flash. This means one cannot execute from
// flash when using the SW reset.
#define PRCM_RESETGPT_GPT                                           0x00000001
#define PRCM_RESETGPT_GPT_BITN                                               0
#define PRCM_RESETGPT_GPT_M                                         0x00000001
#define PRCM_RESETGPT_GPT_S                                                  0

//*****************************************************************************
//
// Register: PRCM_O_RESETI2C
//
//*****************************************************************************
// Field:     [0] I2C
//
//
// 0: No action
// 1: Reset I2C. HW cleared.
//
// Acess will only have effect when SERIAL power domain is on,
// PDSTAT0.SERIAL_ON = 1
// Before writing set FLASH:CFG.DIS_READACCESS = 1 to ensure the reset is not
// activated while executing from flash. This means one cannot execute from
// flash when using the SW reset.
#define PRCM_RESETI2C_I2C                                           0x00000001
#define PRCM_RESETI2C_I2C_BITN                                               0
#define PRCM_RESETI2C_I2C_M                                         0x00000001
#define PRCM_RESETI2C_I2C_S                                                  0

//*****************************************************************************
//
// Register: PRCM_O_RESETUART
//
//*****************************************************************************
// Field:     [1] UART1
//
//
// 0: No action
// 1: Reset UART1. HW cleared.
//
// Acess will only have effect when PERIPH power domain is on,
// PDSTAT0.PERIPH_ON = 1
// Before writing set FLASH:CFG.DIS_READACCESS = 1 to ensure the reset is not
// activated while executing from flash. This means one cannot execute from
// flash when using the SW reset.
#define PRCM_RESETUART_UART1                                        0x00000002
#define PRCM_RESETUART_UART1_BITN                                            1
#define PRCM_RESETUART_UART1_M                                      0x00000002
#define PRCM_RESETUART_UART1_S                                               1

// Field:     [0] UART0
//
//
// 0: No action
// 1: Reset UART0. HW cleared.
//
// Acess will only have effect when SERIAL power domain is on,
// PDSTAT0.SERIAL_ON = 1
// Before writing set FLASH:CFG.DIS_READACCESS = 1 to ensure the reset is not
// activated while executing from flash. This means one cannot execute from
// flash when using the SW reset.
#define PRCM_RESETUART_UART0                                        0x00000001
#define PRCM_RESETUART_UART0_BITN                                            0
#define PRCM_RESETUART_UART0_M                                      0x00000001
#define PRCM_RESETUART_UART0_S                                               0

//*****************************************************************************
//
// Register: PRCM_O_RESETSSI
//
//*****************************************************************************
// Field:   [1:0] SSI
//
// SSI 0:
//
// 0: No action
// 1: Reset SSI. HW cleared.
//
// Acess will only have effect when SERIAL power domain is on,
// PDSTAT0.SERIAL_ON = 1
// Before writing set FLASH:CFG.DIS_READACCESS = 1 to ensure the reset is not
// activated while executing from flash. This means one cannot execute from
// flash when using the SW reset.
//
// SSI 1:
//
// 0: No action
// 1: Reset SSI. HW cleared.
//
// Acess will only have effect when PERIPH power domain is on,
// PDSTAT0.PERIPH_ON = 1
// Before writing set FLASH:CFG.DIS_READACCESS = 1 to ensure the reset is not
// activated while executing from flash. This means one cannot execute from
// flash when using the SW reset.
#define PRCM_RESETSSI_SSI_W                                                  2
#define PRCM_RESETSSI_SSI_M                                         0x00000003
#define PRCM_RESETSSI_SSI_S                                                  0

//*****************************************************************************
//
// Register: PRCM_O_RESETI2S
//
//*****************************************************************************
// Field:     [0] I2S
//
//
// 0: No action
// 1: Reset module. HW cleared.
//
// Acess will only have effect when PERIPH power domain is on,
// PDSTAT0.PERIPH_ON = 1
// Before writing set FLASH:CFG.DIS_READACCESS = 1 to ensure the reset is not
// activated while executing from flash. This means one cannot execute from
// flash when using the SW reset.
#define PRCM_RESETI2S_I2S                                           0x00000001
#define PRCM_RESETI2S_I2S_BITN                                               0
#define PRCM_RESETI2S_I2S_M                                         0x00000001
#define PRCM_RESETI2S_I2S_S                                                  0

//*****************************************************************************
//
// Register: PRCM_O_PDCTL0
//
//*****************************************************************************
// Field:     [2] PERIPH_ON
//
// PERIPH Power domain.
//
// 0: PERIPH power domain is powered down
// 1: PERIPH power domain is powered up
#define PRCM_PDCTL0_PERIPH_ON                                       0x00000004
#define PRCM_PDCTL0_PERIPH_ON_BITN                                           2
#define PRCM_PDCTL0_PERIPH_ON_M                                     0x00000004
#define PRCM_PDCTL0_PERIPH_ON_S                                              2

// Field:     [1] SERIAL_ON
//
// SERIAL Power domain.
//
// 0: SERIAL power domain is powered down
// 1: SERIAL power domain is powered up
#define PRCM_PDCTL0_SERIAL_ON                                       0x00000002
#define PRCM_PDCTL0_SERIAL_ON_BITN                                           1
#define PRCM_PDCTL0_SERIAL_ON_M                                     0x00000002
#define PRCM_PDCTL0_SERIAL_ON_S                                              1

// Field:     [0] RFC_ON
//
//
// 0: RFC power domain powered off if also PDCTL1.RFC_ON = 0
// 1: RFC power domain powered on
#define PRCM_PDCTL0_RFC_ON                                          0x00000001
#define PRCM_PDCTL0_RFC_ON_BITN                                              0
#define PRCM_PDCTL0_RFC_ON_M                                        0x00000001
#define PRCM_PDCTL0_RFC_ON_S                                                 0

//*****************************************************************************
//
// Register: PRCM_O_PDCTL0RFC
//
//*****************************************************************************
// Field:     [0] ON
//
// Alias for PDCTL0.RFC_ON
#define PRCM_PDCTL0RFC_ON                                           0x00000001
#define PRCM_PDCTL0RFC_ON_BITN                                               0
#define PRCM_PDCTL0RFC_ON_M                                         0x00000001
#define PRCM_PDCTL0RFC_ON_S                                                  0

//*****************************************************************************
//
// Register: PRCM_O_PDCTL0SERIAL
//
//*****************************************************************************
// Field:     [0] ON
//
// Alias for PDCTL0.SERIAL_ON
#define PRCM_PDCTL0SERIAL_ON                                        0x00000001
#define PRCM_PDCTL0SERIAL_ON_BITN                                            0
#define PRCM_PDCTL0SERIAL_ON_M                                      0x00000001
#define PRCM_PDCTL0SERIAL_ON_S                                               0

//*****************************************************************************
//
// Register: PRCM_O_PDCTL0PERIPH
//
//*****************************************************************************
// Field:     [0] ON
//
// Alias for PDCTL0.PERIPH_ON
#define PRCM_PDCTL0PERIPH_ON                                        0x00000001
#define PRCM_PDCTL0PERIPH_ON_BITN                                            0
#define PRCM_PDCTL0PERIPH_ON_M                                      0x00000001
#define PRCM_PDCTL0PERIPH_ON_S                                               0

//*****************************************************************************
//
// Register: PRCM_O_PDSTAT0
//
//*****************************************************************************
// Field:     [2] PERIPH_ON
//
// PERIPH Power domain.
//
// 0: Domain may be powered down
// 1: Domain powered up (guaranteed)
#define PRCM_PDSTAT0_PERIPH_ON                                      0x00000004
#define PRCM_PDSTAT0_PERIPH_ON_BITN                                          2
#define PRCM_PDSTAT0_PERIPH_ON_M                                    0x00000004
#define PRCM_PDSTAT0_PERIPH_ON_S                                             2

// Field:     [1] SERIAL_ON
//
// SERIAL Power domain.
//
// 0: Domain may be powered down
// 1: Domain powered up (guaranteed)
#define PRCM_PDSTAT0_SERIAL_ON                                      0x00000002
#define PRCM_PDSTAT0_SERIAL_ON_BITN                                          1
#define PRCM_PDSTAT0_SERIAL_ON_M                                    0x00000002
#define PRCM_PDSTAT0_SERIAL_ON_S                                             1

// Field:     [0] RFC_ON
//
// RFC Power domain
//
// 0: Domain may be powered down
// 1: Domain powered up (guaranteed)
#define PRCM_PDSTAT0_RFC_ON                                         0x00000001
#define PRCM_PDSTAT0_RFC_ON_BITN                                             0
#define PRCM_PDSTAT0_RFC_ON_M                                       0x00000001
#define PRCM_PDSTAT0_RFC_ON_S                                                0

//*****************************************************************************
//
// Register: PRCM_O_PDSTAT0RFC
//
//*****************************************************************************
// Field:     [0] ON
//
// Alias for PDSTAT0.RFC_ON
#define PRCM_PDSTAT0RFC_ON                                          0x00000001
#define PRCM_PDSTAT0RFC_ON_BITN                                              0
#define PRCM_PDSTAT0RFC_ON_M                                        0x00000001
#define PRCM_PDSTAT0RFC_ON_S                                                 0

//*****************************************************************************
//
// Register: PRCM_O_PDSTAT0SERIAL
//
//*****************************************************************************
// Field:     [0] ON
//
// Alias for PDSTAT0.SERIAL_ON
#define PRCM_PDSTAT0SERIAL_ON                                       0x00000001
#define PRCM_PDSTAT0SERIAL_ON_BITN                                           0
#define PRCM_PDSTAT0SERIAL_ON_M                                     0x00000001
#define PRCM_PDSTAT0SERIAL_ON_S                                              0

//*****************************************************************************
//
// Register: PRCM_O_PDSTAT0PERIPH
//
//*****************************************************************************
// Field:     [0] ON
//
// Alias for PDSTAT0.PERIPH_ON
#define PRCM_PDSTAT0PERIPH_ON                                       0x00000001
#define PRCM_PDSTAT0PERIPH_ON_BITN                                           0
#define PRCM_PDSTAT0PERIPH_ON_M                                     0x00000001
#define PRCM_PDSTAT0PERIPH_ON_S                                              0

//*****************************************************************************
//
// Register: PRCM_O_PDCTL1
//
//*****************************************************************************
// Field:   [4:3] VIMS_MODE
//
//
// 00: VIMS power domain is only powered when CPU power domain is powered.
// 01: VIMS power domain is powered whenever the BUS power domain is powered.
// 1X: Block power up of VIMS power domain at next wake up. This mode only has
// effect when VIMS power domain is not powered. Used for Autonomous RF Core.
#define PRCM_PDCTL1_VIMS_MODE_W                                              2
#define PRCM_PDCTL1_VIMS_MODE_M                                     0x00000018
#define PRCM_PDCTL1_VIMS_MODE_S                                              3

// Field:     [2] RFC_ON
//
//  0: RFC power domain powered off if also PDCTL0.RFC_ON = 0 1: RFC power
// domain powered on  Bit shall be used by RFC in autonomous mode but there is
// no HW restrictions fom system CPU to access the bit.
#define PRCM_PDCTL1_RFC_ON                                          0x00000004
#define PRCM_PDCTL1_RFC_ON_BITN                                              2
#define PRCM_PDCTL1_RFC_ON_M                                        0x00000004
#define PRCM_PDCTL1_RFC_ON_S                                                 2

// Field:     [1] CPU_ON
//
//
// 0: Causes a power down of the CPU power domain when system CPU indicates it
// is idle.
// 1: Initiates power-on of the CPU power domain.
//
// This bit is automatically set by a WIC power-on event.
#define PRCM_PDCTL1_CPU_ON                                          0x00000002
#define PRCM_PDCTL1_CPU_ON_BITN                                              1
#define PRCM_PDCTL1_CPU_ON_M                                        0x00000002
#define PRCM_PDCTL1_CPU_ON_S                                                 1

//*****************************************************************************
//
// Register: PRCM_O_PDCTL1CPU
//
//*****************************************************************************
// Field:     [0] ON
//
// This is an alias for PDCTL1.CPU_ON
#define PRCM_PDCTL1CPU_ON                                           0x00000001
#define PRCM_PDCTL1CPU_ON_BITN                                               0
#define PRCM_PDCTL1CPU_ON_M                                         0x00000001
#define PRCM_PDCTL1CPU_ON_S                                                  0

//*****************************************************************************
//
// Register: PRCM_O_PDCTL1RFC
//
//*****************************************************************************
// Field:     [0] ON
//
// This is an alias for PDCTL1.RFC_ON
#define PRCM_PDCTL1RFC_ON                                           0x00000001
#define PRCM_PDCTL1RFC_ON_BITN                                               0
#define PRCM_PDCTL1RFC_ON_M                                         0x00000001
#define PRCM_PDCTL1RFC_ON_S                                                  0

//*****************************************************************************
//
// Register: PRCM_O_PDCTL1VIMS
//
//*****************************************************************************
// Field:   [1:0] MODE
//
// This is an alias for PDCTL1.VIMS_MODE
#define PRCM_PDCTL1VIMS_MODE_W                                               2
#define PRCM_PDCTL1VIMS_MODE_M                                      0x00000003
#define PRCM_PDCTL1VIMS_MODE_S                                               0

//*****************************************************************************
//
// Register: PRCM_O_PDSTAT1
//
//*****************************************************************************
// Field:     [4] BUS_ON
//
//
// 0: BUS domain not accessible
// 1: BUS domain is currently accessible
#define PRCM_PDSTAT1_BUS_ON                                         0x00000010
#define PRCM_PDSTAT1_BUS_ON_BITN                                             4
#define PRCM_PDSTAT1_BUS_ON_M                                       0x00000010
#define PRCM_PDSTAT1_BUS_ON_S                                                4

// Field:     [3] VIMS_ON
//
//
// 0: VIMS domain not accessible
// 1: VIMS domain is currently accessible
#define PRCM_PDSTAT1_VIMS_ON                                        0x00000008
#define PRCM_PDSTAT1_VIMS_ON_BITN                                            3
#define PRCM_PDSTAT1_VIMS_ON_M                                      0x00000008
#define PRCM_PDSTAT1_VIMS_ON_S                                               3

// Field:     [2] RFC_ON
//
//
// 0: RFC domain not accessible
// 1: RFC domain is currently accessible
#define PRCM_PDSTAT1_RFC_ON                                         0x00000004
#define PRCM_PDSTAT1_RFC_ON_BITN                                             2
#define PRCM_PDSTAT1_RFC_ON_M                                       0x00000004
#define PRCM_PDSTAT1_RFC_ON_S                                                2

// Field:     [1] CPU_ON
//
//
// 0: CPU and BUS domain not accessible
// 1: CPU and BUS domains are both currently accessible
#define PRCM_PDSTAT1_CPU_ON                                         0x00000002
#define PRCM_PDSTAT1_CPU_ON_BITN                                             1
#define PRCM_PDSTAT1_CPU_ON_M                                       0x00000002
#define PRCM_PDSTAT1_CPU_ON_S                                                1

//*****************************************************************************
//
// Register: PRCM_O_PDSTAT1BUS
//
//*****************************************************************************
// Field:     [0] ON
//
// This is an alias for PDSTAT1.BUS_ON
#define PRCM_PDSTAT1BUS_ON                                          0x00000001
#define PRCM_PDSTAT1BUS_ON_BITN                                              0
#define PRCM_PDSTAT1BUS_ON_M                                        0x00000001
#define PRCM_PDSTAT1BUS_ON_S                                                 0

//*****************************************************************************
//
// Register: PRCM_O_PDSTAT1RFC
//
//*****************************************************************************
// Field:     [0] ON
//
// This is an alias for PDSTAT1.RFC_ON
#define PRCM_PDSTAT1RFC_ON                                          0x00000001
#define PRCM_PDSTAT1RFC_ON_BITN                                              0
#define PRCM_PDSTAT1RFC_ON_M                                        0x00000001
#define PRCM_PDSTAT1RFC_ON_S                                                 0

//*****************************************************************************
//
// Register: PRCM_O_PDSTAT1CPU
//
//*****************************************************************************
// Field:     [0] ON
//
// This is an alias for PDSTAT1.CPU_ON
#define PRCM_PDSTAT1CPU_ON                                          0x00000001
#define PRCM_PDSTAT1CPU_ON_BITN                                              0
#define PRCM_PDSTAT1CPU_ON_M                                        0x00000001
#define PRCM_PDSTAT1CPU_ON_S                                                 0

//*****************************************************************************
//
// Register: PRCM_O_PDSTAT1VIMS
//
//*****************************************************************************
// Field:     [0] ON
//
// This is an alias for PDSTAT1.VIMS_ON
#define PRCM_PDSTAT1VIMS_ON                                         0x00000001
#define PRCM_PDSTAT1VIMS_ON_BITN                                             0
#define PRCM_PDSTAT1VIMS_ON_M                                       0x00000001
#define PRCM_PDSTAT1VIMS_ON_S                                                0

//*****************************************************************************
//
// Register: PRCM_O_RFCBITS
//
//*****************************************************************************
// Field:  [31:0] READ
//
// Control bits for RFC. The RF core CPE processor will automatically check
// this register when it boots, and it can be used to immediately instruct CPE
// to perform some tasks at its start-up. The supported functionality is
// ROM-defined and may vary. See the technical reference manual for more
// details.
#define PRCM_RFCBITS_READ_W                                                 32
#define PRCM_RFCBITS_READ_M                                         0xFFFFFFFF
#define PRCM_RFCBITS_READ_S                                                  0

//*****************************************************************************
//
// Register: PRCM_O_RFCMODESEL
//
//*****************************************************************************
// Field:   [2:0] CURR
//
// Selects the set of commands that the RFC will accept. Only modes permitted
// by RFCMODEHWOPT.AVAIL are writeable. See the technical reference manual for
// details.
// ENUMs:
// MODE7                    Select Mode 7
// MODE6                    Select Mode 6
// MODE5                    Select Mode 5
// MODE4                    Select Mode 4
// MODE3                    Select Mode 3
// MODE2                    Select Mode 2
// MODE1                    Select Mode 1
// MODE0                    Select Mode 0
#define PRCM_RFCMODESEL_CURR_W                                               3
#define PRCM_RFCMODESEL_CURR_M                                      0x00000007
#define PRCM_RFCMODESEL_CURR_S                                               0
#define PRCM_RFCMODESEL_CURR_MODE7                                  0x00000007
#define PRCM_RFCMODESEL_CURR_MODE6                                  0x00000006
#define PRCM_RFCMODESEL_CURR_MODE5                                  0x00000005
#define PRCM_RFCMODESEL_CURR_MODE4                                  0x00000004
#define PRCM_RFCMODESEL_CURR_MODE3                                  0x00000003
#define PRCM_RFCMODESEL_CURR_MODE2                                  0x00000002
#define PRCM_RFCMODESEL_CURR_MODE1                                  0x00000001
#define PRCM_RFCMODESEL_CURR_MODE0                                  0x00000000

//*****************************************************************************
//
// Register: PRCM_O_RFCMODEHWOPT
//
//*****************************************************************************
// Field:   [7:0] AVAIL
//
// Permitted RFC modes. More than one mode can be permitted.
// ENUMs:
// MODE7                    Mode 7 permitted
// MODE6                    Mode 6 permitted
// MODE5                    Mode 5 permitted
// MODE4                    Mode 4 permitted
// MODE3                    Mode 3 permitted
// MODE2                    Mode 2 permitted
// MODE1                    Mode 1 permitted
// MODE0                    Mode 0 permitted
#define PRCM_RFCMODEHWOPT_AVAIL_W                                            8
#define PRCM_RFCMODEHWOPT_AVAIL_M                                   0x000000FF
#define PRCM_RFCMODEHWOPT_AVAIL_S                                            0
#define PRCM_RFCMODEHWOPT_AVAIL_MODE7                               0x00000080
#define PRCM_RFCMODEHWOPT_AVAIL_MODE6                               0x00000040
#define PRCM_RFCMODEHWOPT_AVAIL_MODE5                               0x00000020
#define PRCM_RFCMODEHWOPT_AVAIL_MODE4                               0x00000010
#define PRCM_RFCMODEHWOPT_AVAIL_MODE3                               0x00000008
#define PRCM_RFCMODEHWOPT_AVAIL_MODE2                               0x00000004
#define PRCM_RFCMODEHWOPT_AVAIL_MODE1                               0x00000002
#define PRCM_RFCMODEHWOPT_AVAIL_MODE0                               0x00000001

//*****************************************************************************
//
// Register: PRCM_O_PWRPROFSTAT
//
//*****************************************************************************
// Field:   [7:0] VALUE
//
// SW can use these bits to timestamp the application. These bits are also
// available through the testtap and can thus be used by the emulator to
// profile in real time.
#define PRCM_PWRPROFSTAT_VALUE_W                                             8
#define PRCM_PWRPROFSTAT_VALUE_M                                    0x000000FF
#define PRCM_PWRPROFSTAT_VALUE_S                                             0

//*****************************************************************************
//
// Register: PRCM_O_MCUSRAMCFG
//
//*****************************************************************************
// Field:     [5] BM_OFF
//
// Burst Mode disable
//
// 0: Burst Mode enabled.
// 1: Burst Mode off.
#define PRCM_MCUSRAMCFG_BM_OFF                                      0x00000020
#define PRCM_MCUSRAMCFG_BM_OFF_BITN                                          5
#define PRCM_MCUSRAMCFG_BM_OFF_M                                    0x00000020
#define PRCM_MCUSRAMCFG_BM_OFF_S                                             5

// Field:     [4] PAGE
//
// Page Mode select
//
// 0: Page Mode disabled. Memory works in standard mode
// 1: Page Mode enabled. Only one  half of butterfly array selected. Page Mode
// will select either LSB half or MSB half of the word based on PGS setting.
//
// This mode can be used for additional power saving
#define PRCM_MCUSRAMCFG_PAGE                                        0x00000010
#define PRCM_MCUSRAMCFG_PAGE_BITN                                            4
#define PRCM_MCUSRAMCFG_PAGE_M                                      0x00000010
#define PRCM_MCUSRAMCFG_PAGE_S                                               4

// Field:     [3] PGS
//
// 0: Select LSB half of word during Page Mode, PAGE = 1
// 1: Select MSB half of word during Page Mode, PAGE = 1
#define PRCM_MCUSRAMCFG_PGS                                         0x00000008
#define PRCM_MCUSRAMCFG_PGS_BITN                                             3
#define PRCM_MCUSRAMCFG_PGS_M                                       0x00000008
#define PRCM_MCUSRAMCFG_PGS_S                                                3

// Field:     [2] BM
//
// Burst Mode Enable
//
// 0: Burst Mode Disable. Memory works in standard mode.
// 1: Burst Mode Enable
//
// When in Burst Mode bitline precharge and wordline firing depends on PCH_F
// and PCH_L.
// Burst Mode results in reduction in active power.
#define PRCM_MCUSRAMCFG_BM                                          0x00000004
#define PRCM_MCUSRAMCFG_BM_BITN                                              2
#define PRCM_MCUSRAMCFG_BM_M                                        0x00000004
#define PRCM_MCUSRAMCFG_BM_S                                                 2

// Field:     [1] PCH_F
//
// 0: No bitline precharge in second half of cycle
// 1: Bitline precharge in second half of cycle when in Burst Mode, BM = 1
#define PRCM_MCUSRAMCFG_PCH_F                                       0x00000002
#define PRCM_MCUSRAMCFG_PCH_F_BITN                                           1
#define PRCM_MCUSRAMCFG_PCH_F_M                                     0x00000002
#define PRCM_MCUSRAMCFG_PCH_F_S                                              1

// Field:     [0] PCH_L
//
// 0: No bitline precharge in first half of cycle
// 1: Bitline precharge in first half of cycle when in Burst Mode, BM = 1
#define PRCM_MCUSRAMCFG_PCH_L                                       0x00000001
#define PRCM_MCUSRAMCFG_PCH_L_BITN                                           0
#define PRCM_MCUSRAMCFG_PCH_L_M                                     0x00000001
#define PRCM_MCUSRAMCFG_PCH_L_S                                              0

//*****************************************************************************
//
// Register: PRCM_O_RAMRETEN
//
//*****************************************************************************
// Field:     [3] RFCULL
//
// 0: Retention for RFC ULL SRAM disabled
// 1: Retention for RFC ULL SRAM enabled
//
// Memories controlled:
// CPEULLRAM
#define PRCM_RAMRETEN_RFCULL                                        0x00000008
#define PRCM_RAMRETEN_RFCULL_BITN                                            3
#define PRCM_RAMRETEN_RFCULL_M                                      0x00000008
#define PRCM_RAMRETEN_RFCULL_S                                               3

// Field:     [2] RFC
//
// 0: Retention for RFC SRAM disabled
// 1: Retention for RFC SRAM enabled
//
// Memories controlled: CPERAM  MCERAM  RFERAM  DSBRAM
#define PRCM_RAMRETEN_RFC                                           0x00000004
#define PRCM_RAMRETEN_RFC_BITN                                               2
#define PRCM_RAMRETEN_RFC_M                                         0x00000004
#define PRCM_RAMRETEN_RFC_S                                                  2

// Field:   [1:0] VIMS
//
//
// 0: Memory retention disabled
// 1: Memory retention enabled
//
// Bit 0: VIMS_TRAM
// Bit 1: VIMS_CRAM
//
// Legal modes depend on settings in VIMS:CTL.MODE
//
// 00: VIMS:CTL.MODE must be OFF before DEEPSLEEP is asserted - must be set to
// CACHE or SPLIT mode after waking up again
// 01: VIMS:CTL.MODE must be GPRAM before DEEPSLEEP is asserted. Must remain in
// GPRAM mode after wake up, alternatively select OFF mode first and then CACHE
// or SPILT mode.
// 10: Illegal mode
// 11: No restrictions
#define PRCM_RAMRETEN_VIMS_W                                                 2
#define PRCM_RAMRETEN_VIMS_M                                        0x00000003
#define PRCM_RAMRETEN_VIMS_S                                                 0

//*****************************************************************************
//
// Register: PRCM_O_OSCIMSC
//
//*****************************************************************************
// Field:     [7] HFSRCPENDIM
//
// 0: Disable interrupt generation when HFSRCPEND is qualified
// 1: Enable interrupt generation when HFSRCPEND is qualified
#define PRCM_OSCIMSC_HFSRCPENDIM                                    0x00000080
#define PRCM_OSCIMSC_HFSRCPENDIM_BITN                                        7
#define PRCM_OSCIMSC_HFSRCPENDIM_M                                  0x00000080
#define PRCM_OSCIMSC_HFSRCPENDIM_S                                           7

// Field:     [6] LFSRCDONEIM
//
// 0: Disable interrupt generation when LFSRCDONE is qualified
// 1: Enable interrupt generation when LFSRCDONE is qualified
#define PRCM_OSCIMSC_LFSRCDONEIM                                    0x00000040
#define PRCM_OSCIMSC_LFSRCDONEIM_BITN                                        6
#define PRCM_OSCIMSC_LFSRCDONEIM_M                                  0x00000040
#define PRCM_OSCIMSC_LFSRCDONEIM_S                                           6

// Field:     [5] XOSCDLFIM
//
// 0: Disable interrupt generation when XOSCDLF is qualified
// 1: Enable interrupt generation when XOSCDLF is qualified
#define PRCM_OSCIMSC_XOSCDLFIM                                      0x00000020
#define PRCM_OSCIMSC_XOSCDLFIM_BITN                                          5
#define PRCM_OSCIMSC_XOSCDLFIM_M                                    0x00000020
#define PRCM_OSCIMSC_XOSCDLFIM_S                                             5

// Field:     [4] XOSCLFIM
//
// 0: Disable interrupt generation when XOSCLF is qualified
// 1: Enable interrupt generation when XOSCLF is qualified
#define PRCM_OSCIMSC_XOSCLFIM                                       0x00000010
#define PRCM_OSCIMSC_XOSCLFIM_BITN                                           4
#define PRCM_OSCIMSC_XOSCLFIM_M                                     0x00000010
#define PRCM_OSCIMSC_XOSCLFIM_S                                              4

// Field:     [3] RCOSCDLFIM
//
// 0: Disable interrupt generation when RCOSCDLF is qualified
// 1: Enable interrupt generation when RCOSCDLF is qualified
#define PRCM_OSCIMSC_RCOSCDLFIM                                     0x00000008
#define PRCM_OSCIMSC_RCOSCDLFIM_BITN                                         3
#define PRCM_OSCIMSC_RCOSCDLFIM_M                                   0x00000008
#define PRCM_OSCIMSC_RCOSCDLFIM_S                                            3

// Field:     [2] RCOSCLFIM
//
// 0: Disable interrupt generation when RCOSCLF is qualified
// 1: Enable interrupt generation when RCOSCLF is qualified
#define PRCM_OSCIMSC_RCOSCLFIM                                      0x00000004
#define PRCM_OSCIMSC_RCOSCLFIM_BITN                                          2
#define PRCM_OSCIMSC_RCOSCLFIM_M                                    0x00000004
#define PRCM_OSCIMSC_RCOSCLFIM_S                                             2

// Field:     [1] XOSCHFIM
//
// 0: Disable interrupt generation when XOSCHF is qualified
// 1: Enable interrupt generation when XOSCHF is qualified
#define PRCM_OSCIMSC_XOSCHFIM                                       0x00000002
#define PRCM_OSCIMSC_XOSCHFIM_BITN                                           1
#define PRCM_OSCIMSC_XOSCHFIM_M                                     0x00000002
#define PRCM_OSCIMSC_XOSCHFIM_S                                              1

// Field:     [0] RCOSCHFIM
//
// 0: Disable interrupt generation when RCOSCHF is qualified
// 1: Enable interrupt generation when RCOSCHF is qualified
#define PRCM_OSCIMSC_RCOSCHFIM                                      0x00000001
#define PRCM_OSCIMSC_RCOSCHFIM_BITN                                          0
#define PRCM_OSCIMSC_RCOSCHFIM_M                                    0x00000001
#define PRCM_OSCIMSC_RCOSCHFIM_S                                             0

//*****************************************************************************
//
// Register: PRCM_O_OSCRIS
//
//*****************************************************************************
// Field:     [7] HFSRCPENDRIS
//
// 0: HFSRCPEND has not been qualified
// 1: HFSRCPEND has been qualified since last clear
//
// Interrupt is qualified regardless of OSCIMSC.HFSRCPENDIM setting. The order
// of qualifying raw interrupt and enable of interrupt mask is indifferent for
// generating an OSC Interrupt.
//
// Set by HW. Cleared by writing to OSCICR.HFSRCPENDC
#define PRCM_OSCRIS_HFSRCPENDRIS                                    0x00000080
#define PRCM_OSCRIS_HFSRCPENDRIS_BITN                                        7
#define PRCM_OSCRIS_HFSRCPENDRIS_M                                  0x00000080
#define PRCM_OSCRIS_HFSRCPENDRIS_S                                           7

// Field:     [6] LFSRCDONERIS
//
// 0: LFSRCDONE has not been qualified
// 1: LFSRCDONE has been qualified since last clear
//
// Interrupt is qualified regardless of OSCIMSC.LFSRCDONEIM setting. The order
// of qualifying raw interrupt and enable of interrupt mask is indifferent for
// generating an OSC Interrupt.
//
// Set by HW. Cleared by writing to OSCICR.LFSRCDONEC
#define PRCM_OSCRIS_LFSRCDONERIS                                    0x00000040
#define PRCM_OSCRIS_LFSRCDONERIS_BITN                                        6
#define PRCM_OSCRIS_LFSRCDONERIS_M                                  0x00000040
#define PRCM_OSCRIS_LFSRCDONERIS_S                                           6

// Field:     [5] XOSCDLFRIS
//
// 0: XOSCDLF has not been qualified
// 1: XOSCDLF has been qualified since last clear.
//
// Interrupt is qualified regardless of OSCIMSC.XOSCDLFIM setting. The order of
// qualifying raw interrupt and enable of interrupt mask is indifferent for
// generating an OSC Interrupt.
//
// Set by HW. Cleared by writing to OSCICR.XOSCDLFC
#define PRCM_OSCRIS_XOSCDLFRIS                                      0x00000020
#define PRCM_OSCRIS_XOSCDLFRIS_BITN                                          5
#define PRCM_OSCRIS_XOSCDLFRIS_M                                    0x00000020
#define PRCM_OSCRIS_XOSCDLFRIS_S                                             5

// Field:     [4] XOSCLFRIS
//
// 0: XOSCLF has not been qualified
// 1: XOSCLF has been qualified since last clear.
//
// Interrupt is qualified regardless of OSCIMSC.XOSCLFIM setting. The order of
// qualifying raw interrupt and enable of interrupt mask is indifferent for
// generating an OSC Interrupt.
//
// Set by HW. Cleared by writing to OSCICR.XOSCLFC
#define PRCM_OSCRIS_XOSCLFRIS                                       0x00000010
#define PRCM_OSCRIS_XOSCLFRIS_BITN                                           4
#define PRCM_OSCRIS_XOSCLFRIS_M                                     0x00000010
#define PRCM_OSCRIS_XOSCLFRIS_S                                              4

// Field:     [3] RCOSCDLFRIS
//
// 0: RCOSCDLF has not been qualified
// 1: RCOSCDLF has been qualified since last clear.
//
// Interrupt is qualified regardless of OSCIMSC.RCOSCDLFIM setting. The order
// of qualifying raw interrupt and enable of interrupt mask is indifferent for
// generating an OSC Interrupt.
//
// Set by HW. Cleared by writing to OSCICR.RCOSCDLFC
#define PRCM_OSCRIS_RCOSCDLFRIS                                     0x00000008
#define PRCM_OSCRIS_RCOSCDLFRIS_BITN                                         3
#define PRCM_OSCRIS_RCOSCDLFRIS_M                                   0x00000008
#define PRCM_OSCRIS_RCOSCDLFRIS_S                                            3

// Field:     [2] RCOSCLFRIS
//
// 0: RCOSCLF has not been qualified
// 1: RCOSCLF has been qualified since last clear.
//
// Interrupt is qualified regardless of OSCIMSC.RCOSCLFIM setting. The order of
// qualifying raw interrupt and enable of interrupt mask is indifferent for
// generating an OSC Interrupt.
//
// Set by HW. Cleared by writing to OSCICR.RCOSCLFC
#define PRCM_OSCRIS_RCOSCLFRIS                                      0x00000004
#define PRCM_OSCRIS_RCOSCLFRIS_BITN                                          2
#define PRCM_OSCRIS_RCOSCLFRIS_M                                    0x00000004
#define PRCM_OSCRIS_RCOSCLFRIS_S                                             2

// Field:     [1] XOSCHFRIS
//
// 0: XOSCHF has not been qualified
// 1: XOSCHF has been qualified since last clear.
//
// Interrupt is qualified regardless of OSCIMSC.XOSCHFIM setting. The order of
// qualifying raw interrupt and enable of interrupt mask is indifferent for
// generating an OSC Interrupt.
//
// Set by HW. Cleared by writing to OSCICR.XOSCHFC
#define PRCM_OSCRIS_XOSCHFRIS                                       0x00000002
#define PRCM_OSCRIS_XOSCHFRIS_BITN                                           1
#define PRCM_OSCRIS_XOSCHFRIS_M                                     0x00000002
#define PRCM_OSCRIS_XOSCHFRIS_S                                              1

// Field:     [0] RCOSCHFRIS
//
// 0: RCOSCHF has not been qualified
// 1: RCOSCHF has been qualified since last clear.
//
// Interrupt is qualified regardless of OSCIMSC.RCOSCHFIM setting. The order of
// qualifying raw interrupt and enable of interrupt mask is indifferent for
// generating an OSC Interrupt.
//
// Set by HW. Cleared by writing to OSCICR.RCOSCHFC
#define PRCM_OSCRIS_RCOSCHFRIS                                      0x00000001
#define PRCM_OSCRIS_RCOSCHFRIS_BITN                                          0
#define PRCM_OSCRIS_RCOSCHFRIS_M                                    0x00000001
#define PRCM_OSCRIS_RCOSCHFRIS_S                                             0

//*****************************************************************************
//
// Register: PRCM_O_OSCICR
//
//*****************************************************************************
// Field:     [7] HFSRCPENDC
//
// Writing 1 to this field clears the HFSRCPEND raw interrupt status. Writing 0
// has no effect.
#define PRCM_OSCICR_HFSRCPENDC                                      0x00000080
#define PRCM_OSCICR_HFSRCPENDC_BITN                                          7
#define PRCM_OSCICR_HFSRCPENDC_M                                    0x00000080
#define PRCM_OSCICR_HFSRCPENDC_S                                             7

// Field:     [6] LFSRCDONEC
//
// Writing 1 to this field clears the LFSRCDONE raw interrupt status. Writing 0
// has no effect.
#define PRCM_OSCICR_LFSRCDONEC                                      0x00000040
#define PRCM_OSCICR_LFSRCDONEC_BITN                                          6
#define PRCM_OSCICR_LFSRCDONEC_M                                    0x00000040
#define PRCM_OSCICR_LFSRCDONEC_S                                             6

// Field:     [5] XOSCDLFC
//
// Writing 1 to this field clears the XOSCDLF raw interrupt status. Writing 0
// has no effect.
#define PRCM_OSCICR_XOSCDLFC                                        0x00000020
#define PRCM_OSCICR_XOSCDLFC_BITN                                            5
#define PRCM_OSCICR_XOSCDLFC_M                                      0x00000020
#define PRCM_OSCICR_XOSCDLFC_S                                               5

// Field:     [4] XOSCLFC
//
// Writing 1 to this field clears the XOSCLF raw interrupt status. Writing 0
// has no effect.
#define PRCM_OSCICR_XOSCLFC                                         0x00000010
#define PRCM_OSCICR_XOSCLFC_BITN                                             4
#define PRCM_OSCICR_XOSCLFC_M                                       0x00000010
#define PRCM_OSCICR_XOSCLFC_S                                                4

// Field:     [3] RCOSCDLFC
//
// Writing 1 to this field clears the RCOSCDLF raw interrupt status. Writing 0
// has no effect.
#define PRCM_OSCICR_RCOSCDLFC                                       0x00000008
#define PRCM_OSCICR_RCOSCDLFC_BITN                                           3
#define PRCM_OSCICR_RCOSCDLFC_M                                     0x00000008
#define PRCM_OSCICR_RCOSCDLFC_S                                              3

// Field:     [2] RCOSCLFC
//
// Writing 1 to this field clears the RCOSCLF raw interrupt status. Writing 0
// has no effect.
#define PRCM_OSCICR_RCOSCLFC                                        0x00000004
#define PRCM_OSCICR_RCOSCLFC_BITN                                            2
#define PRCM_OSCICR_RCOSCLFC_M                                      0x00000004
#define PRCM_OSCICR_RCOSCLFC_S                                               2

// Field:     [1] XOSCHFC
//
// Writing 1 to this field clears the XOSCHF raw interrupt status. Writing 0
// has no effect.
#define PRCM_OSCICR_XOSCHFC                                         0x00000002
#define PRCM_OSCICR_XOSCHFC_BITN                                             1
#define PRCM_OSCICR_XOSCHFC_M                                       0x00000002
#define PRCM_OSCICR_XOSCHFC_S                                                1

// Field:     [0] RCOSCHFC
//
// Writing 1 to this field clears the RCOSCHF raw interrupt status. Writing 0
// has no effect.
#define PRCM_OSCICR_RCOSCHFC                                        0x00000001
#define PRCM_OSCICR_RCOSCHFC_BITN                                            0
#define PRCM_OSCICR_RCOSCHFC_M                                      0x00000001
#define PRCM_OSCICR_RCOSCHFC_S                                               0


#endif // __HW_PRCM_H__

#ifndef __IOC_H__
#define __IOC_H__
// from: simplelink_cc13x2_26x2_sdk_3_40_00_02/source/ti/devices/cc13x2_cc26x2/driverlib/iov.h

#define IOID_0                  0x00000000  // IO Id 0
#define IOID_1                  0x00000001  // IO Id 1
#define IOID_2                  0x00000002  // IO Id 2
#define IOID_3                  0x00000003  // IO Id 3
#define IOID_4                  0x00000004  // IO Id 4
#define IOID_5                  0x00000005  // IO Id 5
#define IOID_6                  0x00000006  // IO Id 6
#define IOID_7                  0x00000007  // IO Id 7
#define IOID_8                  0x00000008  // IO Id 8
#define IOID_9                  0x00000009  // IO Id 9
#define IOID_10                 0x0000000A  // IO Id 10
#define IOID_11                 0x0000000B  // IO Id 11
#define IOID_12                 0x0000000C  // IO Id 12
#define IOID_13                 0x0000000D  // IO Id 13
#define IOID_14                 0x0000000E  // IO Id 14
#define IOID_15                 0x0000000F  // IO Id 15
#define IOID_16                 0x00000010  // IO Id 16
#define IOID_17                 0x00000011  // IO Id 17
#define IOID_18                 0x00000012  // IO Id 18
#define IOID_19                 0x00000013  // IO Id 19
#define IOID_20                 0x00000014  // IO Id 20
#define IOID_21                 0x00000015  // IO Id 21
#define IOID_22                 0x00000016  // IO Id 22
#define IOID_23                 0x00000017  // IO Id 23
#define IOID_24                 0x00000018  // IO Id 24
#define IOID_25                 0x00000019  // IO Id 25
#define IOID_26                 0x0000001A  // IO Id 26
#define IOID_27                 0x0000001B  // IO Id 27
#define IOID_28                 0x0000001C  // IO Id 28
#define IOID_29                 0x0000001D  // IO Id 29
#define IOID_30                 0x0000001E  // IO Id 30
#define IOID_31                 0x0000001F  // IO Id 31
#define IOID_UNUSED             0xFFFFFFFF  // Unused IO Id

#define IOC_IOID_MASK           0x000000FF  // IOC IO Id bit mask

//*****************************************************************************
//
// Number of IO ports
//
//*****************************************************************************
#define NUM_IO_PORTS 56

//*****************************************************************************
//
// IOC Peripheral Port Mapping
//
//*****************************************************************************
#define IOC_PORT_GPIO             0x00000000  // Default general purpose IO usage
#define IOC_PORT_AON_CLK32K       0x00000007  // AON External 32kHz clock
#define IOC_PORT_AUX_IO           0x00000008  // AUX IO Pin
#define IOC_PORT_MCU_SSI0_RX      0x00000009  // MCU SSI0 Receive Pin
#define IOC_PORT_MCU_SSI0_TX      0x0000000A  // MCU SSI0 Transmit Pin
#define IOC_PORT_MCU_SSI0_FSS     0x0000000B  // MCU SSI0 FSS Pin
#define IOC_PORT_MCU_SSI0_CLK     0x0000000C  // MCU SSI0 Clock Pin
#define IOC_PORT_MCU_I2C_MSSDA    0x0000000D  // MCU I2C Data Pin
#define IOC_PORT_MCU_I2C_MSSCL    0x0000000E  // MCU I2C Clock Pin
#define IOC_PORT_MCU_UART0_RX     0x0000000F  // MCU UART0 Receive Pin
#define IOC_PORT_MCU_UART0_TX     0x00000010  // MCU UART0 Transmit Pin
#define IOC_PORT_MCU_UART0_CTS    0x00000011  // MCU UART0 Clear To Send Pin
#define IOC_PORT_MCU_UART0_RTS    0x00000012  // MCU UART0 Request To Send Pin
#define IOC_PORT_MCU_UART1_RX     0x00000013  // MCU UART1 Receive Pin
#define IOC_PORT_MCU_UART1_TX     0x00000014  // MCU UART1 Transmit Pin
#define IOC_PORT_MCU_UART1_CTS    0x00000015  // MCU UART1 Clear To Send Pin
#define IOC_PORT_MCU_UART1_RTS    0x00000016  // MCU UART1 Request To Send Pin
#define IOC_PORT_MCU_PORT_EVENT0  0x00000017  // MCU PORT EVENT 0
#define IOC_PORT_MCU_PORT_EVENT1  0x00000018  // MCU PORT EVENT 1
#define IOC_PORT_MCU_PORT_EVENT2  0x00000019  // MCU PORT EVENT 2
#define IOC_PORT_MCU_PORT_EVENT3  0x0000001A  // MCU PORT EVENT 3
#define IOC_PORT_MCU_PORT_EVENT4  0x0000001B  // MCU PORT EVENT 4
#define IOC_PORT_MCU_PORT_EVENT5  0x0000001C  // MCU PORT EVENT 5
#define IOC_PORT_MCU_PORT_EVENT6  0x0000001D  // MCU PORT EVENT 6
#define IOC_PORT_MCU_PORT_EVENT7  0x0000001E  // MCU PORT EVENT 7
#define IOC_PORT_MCU_SWV          0x00000020  // Serial Wire Viewer
#define IOC_PORT_MCU_SSI1_RX      0x00000021  // MCU SSI1 Receive Pin
#define IOC_PORT_MCU_SSI1_TX      0x00000022  // MCU SSI1 Transmit Pin
#define IOC_PORT_MCU_SSI1_FSS     0x00000023  // MCU SSI1 FSS Pin
#define IOC_PORT_MCU_SSI1_CLK     0x00000024  // MCU SSI1 Clock Pin
#define IOC_PORT_MCU_I2S_AD0      0x00000025  // MCU I2S Data Pin 0
#define IOC_PORT_MCU_I2S_AD1      0x00000026  // MCU I2S Data Pin 1
#define IOC_PORT_MCU_I2S_WCLK     0x00000027  // MCU I2S Frame/Word Clock
#define IOC_PORT_MCU_I2S_BCLK     0x00000028  // MCU I2S Bit Clock
#define IOC_PORT_MCU_I2S_MCLK     0x00000029  // MCU I2S Master clock 2
#define IOC_PORT_RFC_TRC          0x0000002E  // RF Core Tracer
#define IOC_PORT_RFC_GPO0         0x0000002F  // RC Core Data Out Pin 0
#define IOC_PORT_RFC_GPO1         0x00000030  // RC Core Data Out Pin 1
#define IOC_PORT_RFC_GPO2         0x00000031  // RC Core Data Out Pin 2
#define IOC_PORT_RFC_GPO3         0x00000032  // RC Core Data Out Pin 3
#define IOC_PORT_RFC_GPI0         0x00000033  // RC Core Data In Pin 0
#define IOC_PORT_RFC_GPI1         0x00000034  // RC Core Data In Pin 1
#define IOC_PORT_RFC_SMI_DL_OUT   0x00000035  // RF Core SMI Data Link Out
#define IOC_PORT_RFC_SMI_DL_IN    0x00000036  // RF Core SMI Data Link in
#define IOC_PORT_RFC_SMI_CL_OUT   0x00000037  // RF Core SMI Command Link Out
#define IOC_PORT_RFC_SMI_CL_IN    0x00000038  // RF Core SMI Command Link In

//*****************************************************************************
//
// Defines for enabling/disabling an IO
//
//*****************************************************************************
#define IOC_SLEW_ENABLE         0x00001000
#define IOC_SLEW_DISABLE        0x00000000
#define IOC_INPUT_ENABLE        0x20000000
#define IOC_INPUT_DISABLE       0x00000000
#define IOC_HYST_ENABLE         0x40000000
#define IOC_HYST_DISABLE        0x00000000

//*****************************************************************************
//
// Defines that can be used to set the shutdown mode of an IO
//
//*****************************************************************************
#define IOC_NO_WAKE_UP          0x00000000
#define IOC_WAKE_ON_LOW         0x10000000
#define IOC_WAKE_ON_HIGH        0x18000000

//*****************************************************************************
//
// Defines that can be used to set the IO Mode of an IO
//
//*****************************************************************************
#define IOC_IOMODE_NORMAL       0x00000000  // Normal Input/Output
#define IOC_IOMODE_INV          0x01000000  // Inverted Input/Output
#define IOC_IOMODE_OPEN_DRAIN_NORMAL \
                                0x04000000  // Open Drain, Normal Input/Output
#define IOC_IOMODE_OPEN_DRAIN_INV \
                                0x05000000  // Open Drain, Inverted
                                            // Input/Output
#define IOC_IOMODE_OPEN_SRC_NORMAL \
                                0x06000000  // Open Source, Normal Input/Output
#define IOC_IOMODE_OPEN_SRC_INV \
                                0x07000000  // Open Source, Inverted
                                            // Input/Output

//*****************************************************************************
//
// Defines that can be used to set the edge detection on an IO
//
//*****************************************************************************
#define IOC_NO_EDGE             0x00000000  // No edge detection
#define IOC_FALLING_EDGE        0x00010000  // Edge detection on falling edge
#define IOC_RISING_EDGE         0x00020000  // Edge detection on rising edge
#define IOC_BOTH_EDGES          0x00030000  // Edge detection on both edges
#define IOC_INT_ENABLE          0x00040000  // Enable interrupt on edge detect
#define IOC_INT_DISABLE         0x00000000  // Disable interrupt on edge detect
#define IOC_INT_M               0x00070000  // Int config mask

//*****************************************************************************
//
// Defines that be used to set pull on an IO
//
//*****************************************************************************
#define IOC_NO_IOPULL           0x00006000  // No IO pull
#define IOC_IOPULL_UP           0x00004000  // Pull up
#define IOC_IOPULL_DOWN         0x00002000  // Pull down
#define IOC_IOPULL_M            0x00006000  // Pull config mask
#define IOC_IOPULL_M            0x00006000

//*****************************************************************************
//
// Defines that can be used to select the drive strength of an IO
//
//*****************************************************************************
#define IOC_CURRENT_2MA         0x00000000  // 2mA drive strength
#define IOC_CURRENT_4MA         0x00000400  // 4mA drive strength
#define IOC_CURRENT_8MA         0x00000800  // 4 or 8mA drive strength

#define IOC_STRENGTH_AUTO       0x00000000  // Automatic Drive Strength
                                            // (2/4/8 mA @ VVDS)
#define IOC_STRENGTH_MAX        0x00000300  // Maximum Drive Strength
                                            // (2/4/8 mA @ 1.8V)
#define IOC_STRENGTH_MED        0x00000200  // Medium Drive Strength
                                            // (2/4/8 mA @ 2.5V)
#define IOC_STRENGTH_MIN        0x00000100  // Minimum Drive Strength
                                            // (2/4/8 mA @ 3.3V)

//*****************************************************************************
//
// Defines that can be used to enable event generation on edge detect
//
//*****************************************************************************
#define IOC_EVT_AON_PROG2_DISABLE      0x00000000
#define IOC_EVT_AON_PROG2_ENABLE       0x00800000
#define IOC_EVT_AON_PROG1_DISABLE      0x00000000
#define IOC_EVT_AON_PROG1_ENABLE       0x00400000
#define IOC_EVT_AON_PROG0_DISABLE      0x00000000
#define IOC_EVT_AON_PROG0_ENABLE       0x00200000
#define IOC_EVT_RTC_DISABLE            0x00000000
#define IOC_EVT_RTC_ENABLE             0x00000080
#define IOC_EVT_MCU_WU_DISABLE         0x00000000
#define IOC_EVT_MCU_WU_ENABLE          0x00000040

//*****************************************************************************
//
// Defines for standard IO setup
//
//*****************************************************************************
#define IOC_STD_INPUT           (IOC_CURRENT_2MA | IOC_STRENGTH_AUTO |      \
                                 IOC_NO_IOPULL | IOC_SLEW_DISABLE |         \
                                 IOC_HYST_DISABLE | IOC_NO_EDGE |           \
                                 IOC_INT_DISABLE | IOC_IOMODE_NORMAL |      \
                                 IOC_NO_WAKE_UP | IOC_INPUT_ENABLE )
#define IOC_STD_OUTPUT          (IOC_CURRENT_2MA | IOC_STRENGTH_AUTO |      \
                                 IOC_NO_IOPULL | IOC_SLEW_DISABLE |         \
                                 IOC_HYST_DISABLE | IOC_NO_EDGE |           \
                                 IOC_INT_DISABLE | IOC_IOMODE_NORMAL |      \
                                 IOC_NO_WAKE_UP | IOC_INPUT_DISABLE )


#endif // __IOC_H__

#ifndef __HW_IOC_H__
#define __HW_IOC_H__

//*****************************************************************************
//
// This section defines the register offsets of
// IOC component
//
//*****************************************************************************
// Configuration of DIO0
#define IOC_O_IOCFG0                                                0x00000000

// Configuration of DIO1
#define IOC_O_IOCFG1                                                0x00000004

// Configuration of DIO2
#define IOC_O_IOCFG2                                                0x00000008

// Configuration of DIO3
#define IOC_O_IOCFG3                                                0x0000000C

// Configuration of DIO4
#define IOC_O_IOCFG4                                                0x00000010

// Configuration of DIO5
#define IOC_O_IOCFG5                                                0x00000014

// Configuration of DIO6
#define IOC_O_IOCFG6                                                0x00000018

// Configuration of DIO7
#define IOC_O_IOCFG7                                                0x0000001C

// Configuration of DIO8
#define IOC_O_IOCFG8                                                0x00000020

// Configuration of DIO9
#define IOC_O_IOCFG9                                                0x00000024

// Configuration of DIO10
#define IOC_O_IOCFG10                                               0x00000028

// Configuration of DIO11
#define IOC_O_IOCFG11                                               0x0000002C

// Configuration of DIO12
#define IOC_O_IOCFG12                                               0x00000030

// Configuration of DIO13
#define IOC_O_IOCFG13                                               0x00000034

// Configuration of DIO14
#define IOC_O_IOCFG14                                               0x00000038

// Configuration of DIO15
#define IOC_O_IOCFG15                                               0x0000003C

// Configuration of DIO16
#define IOC_O_IOCFG16                                               0x00000040

// Configuration of DIO17
#define IOC_O_IOCFG17                                               0x00000044

// Configuration of DIO18
#define IOC_O_IOCFG18                                               0x00000048

// Configuration of DIO19
#define IOC_O_IOCFG19                                               0x0000004C

// Configuration of DIO20
#define IOC_O_IOCFG20                                               0x00000050

// Configuration of DIO21
#define IOC_O_IOCFG21                                               0x00000054

// Configuration of DIO22
#define IOC_O_IOCFG22                                               0x00000058

// Configuration of DIO23
#define IOC_O_IOCFG23                                               0x0000005C

// Configuration of DIO24
#define IOC_O_IOCFG24                                               0x00000060

// Configuration of DIO25
#define IOC_O_IOCFG25                                               0x00000064

// Configuration of DIO26
#define IOC_O_IOCFG26                                               0x00000068

// Configuration of DIO27
#define IOC_O_IOCFG27                                               0x0000006C

// Configuration of DIO28
#define IOC_O_IOCFG28                                               0x00000070

// Configuration of DIO29
#define IOC_O_IOCFG29                                               0x00000074

// Configuration of DIO30
#define IOC_O_IOCFG30                                               0x00000078

// Configuration of DIO31
#define IOC_O_IOCFG31                                               0x0000007C

//*****************************************************************************
//
// Register: IOC_O_IOCFG0
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG0_HYST_EN                                          0x40000000
#define IOC_IOCFG0_HYST_EN_BITN                                             30
#define IOC_IOCFG0_HYST_EN_M                                        0x40000000
#define IOC_IOCFG0_HYST_EN_S                                                30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG0_IE                                               0x20000000
#define IOC_IOCFG0_IE_BITN                                                  29
#define IOC_IOCFG0_IE_M                                             0x20000000
#define IOC_IOCFG0_IE_S                                                     29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG0_WU_CFG_W                                                  2
#define IOC_IOCFG0_WU_CFG_M                                         0x18000000
#define IOC_IOCFG0_WU_CFG_S                                                 27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input/output
// OPENSRC                  Open Source
//                          Normal input / outut
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG0_IOMODE_W                                                  3
#define IOC_IOCFG0_IOMODE_M                                         0x07000000
#define IOC_IOCFG0_IOMODE_S                                                 24
#define IOC_IOCFG0_IOMODE_OPENSRC_INV                               0x07000000
#define IOC_IOCFG0_IOMODE_OPENSRC                                   0x06000000
#define IOC_IOCFG0_IOMODE_OPENDR_INV                                0x05000000
#define IOC_IOCFG0_IOMODE_OPENDR                                    0x04000000
#define IOC_IOCFG0_IOMODE_INV                                       0x01000000
#define IOC_IOCFG0_IOMODE_NORMAL                                    0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG0_IOEV_AON_PROG2_EN                                0x00800000
#define IOC_IOCFG0_IOEV_AON_PROG2_EN_BITN                                   23
#define IOC_IOCFG0_IOEV_AON_PROG2_EN_M                              0x00800000
#define IOC_IOCFG0_IOEV_AON_PROG2_EN_S                                      23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG0_IOEV_AON_PROG1_EN                                0x00400000
#define IOC_IOCFG0_IOEV_AON_PROG1_EN_BITN                                   22
#define IOC_IOCFG0_IOEV_AON_PROG1_EN_M                              0x00400000
#define IOC_IOCFG0_IOEV_AON_PROG1_EN_S                                      22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG0_IOEV_AON_PROG0_EN                                0x00200000
#define IOC_IOCFG0_IOEV_AON_PROG0_EN_BITN                                   21
#define IOC_IOCFG0_IOEV_AON_PROG0_EN_M                              0x00200000
#define IOC_IOCFG0_IOEV_AON_PROG0_EN_S                                      21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG0_EDGE_IRQ_EN                                      0x00040000
#define IOC_IOCFG0_EDGE_IRQ_EN_BITN                                         18
#define IOC_IOCFG0_EDGE_IRQ_EN_M                                    0x00040000
#define IOC_IOCFG0_EDGE_IRQ_EN_S                                            18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG0_EDGE_DET_W                                                2
#define IOC_IOCFG0_EDGE_DET_M                                       0x00030000
#define IOC_IOCFG0_EDGE_DET_S                                               16
#define IOC_IOCFG0_EDGE_DET_BOTH                                    0x00030000
#define IOC_IOCFG0_EDGE_DET_POS                                     0x00020000
#define IOC_IOCFG0_EDGE_DET_NEG                                     0x00010000
#define IOC_IOCFG0_EDGE_DET_NONE                                    0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG0_PULL_CTL_W                                                2
#define IOC_IOCFG0_PULL_CTL_M                                       0x00006000
#define IOC_IOCFG0_PULL_CTL_S                                               13
#define IOC_IOCFG0_PULL_CTL_DIS                                     0x00006000
#define IOC_IOCFG0_PULL_CTL_UP                                      0x00004000
#define IOC_IOCFG0_PULL_CTL_DWN                                     0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG0_SLEW_RED                                         0x00001000
#define IOC_IOCFG0_SLEW_RED_BITN                                            12
#define IOC_IOCFG0_SLEW_RED_M                                       0x00001000
#define IOC_IOCFG0_SLEW_RED_S                                               12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG0_IOCURR_W                                                  2
#define IOC_IOCFG0_IOCURR_M                                         0x00000C00
#define IOC_IOCFG0_IOCURR_S                                                 10
#define IOC_IOCFG0_IOCURR_4_8MA                                     0x00000800
#define IOC_IOCFG0_IOCURR_4MA                                       0x00000400
#define IOC_IOCFG0_IOCURR_2MA                                       0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG0_IOSTR_W                                                   2
#define IOC_IOCFG0_IOSTR_M                                          0x00000300
#define IOC_IOCFG0_IOSTR_S                                                   8
#define IOC_IOCFG0_IOSTR_MAX                                        0x00000300
#define IOC_IOCFG0_IOSTR_MED                                        0x00000200
#define IOC_IOCFG0_IOSTR_MIN                                        0x00000100
#define IOC_IOCFG0_IOSTR_AUTO                                       0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG0_IOEV_RTC_EN                                      0x00000080
#define IOC_IOCFG0_IOEV_RTC_EN_BITN                                          7
#define IOC_IOCFG0_IOEV_RTC_EN_M                                    0x00000080
#define IOC_IOCFG0_IOEV_RTC_EN_S                                             7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG0_IOEV_MCU_WU_EN                                   0x00000040
#define IOC_IOCFG0_IOEV_MCU_WU_EN_BITN                                       6
#define IOC_IOCFG0_IOEV_MCU_WU_EN_M                                 0x00000040
#define IOC_IOCFG0_IOEV_MCU_WU_EN_S                                          6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO0
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG0_PORT_ID_W                                                 6
#define IOC_IOCFG0_PORT_ID_M                                        0x0000003F
#define IOC_IOCFG0_PORT_ID_S                                                 0
#define IOC_IOCFG0_PORT_ID_RFC_SMI_CL_IN                            0x00000038
#define IOC_IOCFG0_PORT_ID_RFC_SMI_CL_OUT                           0x00000037
#define IOC_IOCFG0_PORT_ID_RFC_SMI_DL_IN                            0x00000036
#define IOC_IOCFG0_PORT_ID_RFC_SMI_DL_OUT                           0x00000035
#define IOC_IOCFG0_PORT_ID_RFC_GPI1                                 0x00000034
#define IOC_IOCFG0_PORT_ID_RFC_GPI0                                 0x00000033
#define IOC_IOCFG0_PORT_ID_RFC_GPO3                                 0x00000032
#define IOC_IOCFG0_PORT_ID_RFC_GPO2                                 0x00000031
#define IOC_IOCFG0_PORT_ID_RFC_GPO1                                 0x00000030
#define IOC_IOCFG0_PORT_ID_RFC_GPO0                                 0x0000002F
#define IOC_IOCFG0_PORT_ID_RFC_TRC                                  0x0000002E
#define IOC_IOCFG0_PORT_ID_I2S_MCLK                                 0x00000029
#define IOC_IOCFG0_PORT_ID_I2S_BCLK                                 0x00000028
#define IOC_IOCFG0_PORT_ID_I2S_WCLK                                 0x00000027
#define IOC_IOCFG0_PORT_ID_I2S_AD1                                  0x00000026
#define IOC_IOCFG0_PORT_ID_I2S_AD0                                  0x00000025
#define IOC_IOCFG0_PORT_ID_SSI1_CLK                                 0x00000024
#define IOC_IOCFG0_PORT_ID_SSI1_FSS                                 0x00000023
#define IOC_IOCFG0_PORT_ID_SSI1_TX                                  0x00000022
#define IOC_IOCFG0_PORT_ID_SSI1_RX                                  0x00000021
#define IOC_IOCFG0_PORT_ID_CPU_SWV                                  0x00000020
#define IOC_IOCFG0_PORT_ID_PORT_EVENT7                              0x0000001E
#define IOC_IOCFG0_PORT_ID_PORT_EVENT6                              0x0000001D
#define IOC_IOCFG0_PORT_ID_PORT_EVENT5                              0x0000001C
#define IOC_IOCFG0_PORT_ID_PORT_EVENT4                              0x0000001B
#define IOC_IOCFG0_PORT_ID_PORT_EVENT3                              0x0000001A
#define IOC_IOCFG0_PORT_ID_PORT_EVENT2                              0x00000019
#define IOC_IOCFG0_PORT_ID_PORT_EVENT1                              0x00000018
#define IOC_IOCFG0_PORT_ID_PORT_EVENT0                              0x00000017
#define IOC_IOCFG0_PORT_ID_UART1_RTS                                0x00000016
#define IOC_IOCFG0_PORT_ID_UART1_CTS                                0x00000015
#define IOC_IOCFG0_PORT_ID_UART1_TX                                 0x00000014
#define IOC_IOCFG0_PORT_ID_UART1_RX                                 0x00000013
#define IOC_IOCFG0_PORT_ID_UART0_RTS                                0x00000012
#define IOC_IOCFG0_PORT_ID_UART0_CTS                                0x00000011
#define IOC_IOCFG0_PORT_ID_UART0_TX                                 0x00000010
#define IOC_IOCFG0_PORT_ID_UART0_RX                                 0x0000000F
#define IOC_IOCFG0_PORT_ID_I2C_MSSCL                                0x0000000E
#define IOC_IOCFG0_PORT_ID_I2C_MSSDA                                0x0000000D
#define IOC_IOCFG0_PORT_ID_SSI0_CLK                                 0x0000000C
#define IOC_IOCFG0_PORT_ID_SSI0_FSS                                 0x0000000B
#define IOC_IOCFG0_PORT_ID_SSI0_TX                                  0x0000000A
#define IOC_IOCFG0_PORT_ID_SSI0_RX                                  0x00000009
#define IOC_IOCFG0_PORT_ID_AUX_IO                                   0x00000008
#define IOC_IOCFG0_PORT_ID_AON_CLK32K                               0x00000007
#define IOC_IOCFG0_PORT_ID_GPIO                                     0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG1
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG1_HYST_EN                                          0x40000000
#define IOC_IOCFG1_HYST_EN_BITN                                             30
#define IOC_IOCFG1_HYST_EN_M                                        0x40000000
#define IOC_IOCFG1_HYST_EN_S                                                30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG1_IE                                               0x20000000
#define IOC_IOCFG1_IE_BITN                                                  29
#define IOC_IOCFG1_IE_M                                             0x20000000
#define IOC_IOCFG1_IE_S                                                     29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG1_WU_CFG_W                                                  2
#define IOC_IOCFG1_WU_CFG_M                                         0x18000000
#define IOC_IOCFG1_WU_CFG_S                                                 27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG1_IOMODE_W                                                  3
#define IOC_IOCFG1_IOMODE_M                                         0x07000000
#define IOC_IOCFG1_IOMODE_S                                                 24
#define IOC_IOCFG1_IOMODE_OPENSRC_INV                               0x07000000
#define IOC_IOCFG1_IOMODE_OPENSRC                                   0x06000000
#define IOC_IOCFG1_IOMODE_OPENDR_INV                                0x05000000
#define IOC_IOCFG1_IOMODE_OPENDR                                    0x04000000
#define IOC_IOCFG1_IOMODE_INV                                       0x01000000
#define IOC_IOCFG1_IOMODE_NORMAL                                    0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG1_IOEV_AON_PROG2_EN                                0x00800000
#define IOC_IOCFG1_IOEV_AON_PROG2_EN_BITN                                   23
#define IOC_IOCFG1_IOEV_AON_PROG2_EN_M                              0x00800000
#define IOC_IOCFG1_IOEV_AON_PROG2_EN_S                                      23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG1_IOEV_AON_PROG1_EN                                0x00400000
#define IOC_IOCFG1_IOEV_AON_PROG1_EN_BITN                                   22
#define IOC_IOCFG1_IOEV_AON_PROG1_EN_M                              0x00400000
#define IOC_IOCFG1_IOEV_AON_PROG1_EN_S                                      22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG1_IOEV_AON_PROG0_EN                                0x00200000
#define IOC_IOCFG1_IOEV_AON_PROG0_EN_BITN                                   21
#define IOC_IOCFG1_IOEV_AON_PROG0_EN_M                              0x00200000
#define IOC_IOCFG1_IOEV_AON_PROG0_EN_S                                      21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG1_EDGE_IRQ_EN                                      0x00040000
#define IOC_IOCFG1_EDGE_IRQ_EN_BITN                                         18
#define IOC_IOCFG1_EDGE_IRQ_EN_M                                    0x00040000
#define IOC_IOCFG1_EDGE_IRQ_EN_S                                            18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG1_EDGE_DET_W                                                2
#define IOC_IOCFG1_EDGE_DET_M                                       0x00030000
#define IOC_IOCFG1_EDGE_DET_S                                               16
#define IOC_IOCFG1_EDGE_DET_BOTH                                    0x00030000
#define IOC_IOCFG1_EDGE_DET_POS                                     0x00020000
#define IOC_IOCFG1_EDGE_DET_NEG                                     0x00010000
#define IOC_IOCFG1_EDGE_DET_NONE                                    0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG1_PULL_CTL_W                                                2
#define IOC_IOCFG1_PULL_CTL_M                                       0x00006000
#define IOC_IOCFG1_PULL_CTL_S                                               13
#define IOC_IOCFG1_PULL_CTL_DIS                                     0x00006000
#define IOC_IOCFG1_PULL_CTL_UP                                      0x00004000
#define IOC_IOCFG1_PULL_CTL_DWN                                     0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG1_SLEW_RED                                         0x00001000
#define IOC_IOCFG1_SLEW_RED_BITN                                            12
#define IOC_IOCFG1_SLEW_RED_M                                       0x00001000
#define IOC_IOCFG1_SLEW_RED_S                                               12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG1_IOCURR_W                                                  2
#define IOC_IOCFG1_IOCURR_M                                         0x00000C00
#define IOC_IOCFG1_IOCURR_S                                                 10
#define IOC_IOCFG1_IOCURR_4_8MA                                     0x00000800
#define IOC_IOCFG1_IOCURR_4MA                                       0x00000400
#define IOC_IOCFG1_IOCURR_2MA                                       0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG1_IOSTR_W                                                   2
#define IOC_IOCFG1_IOSTR_M                                          0x00000300
#define IOC_IOCFG1_IOSTR_S                                                   8
#define IOC_IOCFG1_IOSTR_MAX                                        0x00000300
#define IOC_IOCFG1_IOSTR_MED                                        0x00000200
#define IOC_IOCFG1_IOSTR_MIN                                        0x00000100
#define IOC_IOCFG1_IOSTR_AUTO                                       0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG1_IOEV_RTC_EN                                      0x00000080
#define IOC_IOCFG1_IOEV_RTC_EN_BITN                                          7
#define IOC_IOCFG1_IOEV_RTC_EN_M                                    0x00000080
#define IOC_IOCFG1_IOEV_RTC_EN_S                                             7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG1_IOEV_MCU_WU_EN                                   0x00000040
#define IOC_IOCFG1_IOEV_MCU_WU_EN_BITN                                       6
#define IOC_IOCFG1_IOEV_MCU_WU_EN_M                                 0x00000040
#define IOC_IOCFG1_IOEV_MCU_WU_EN_S                                          6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO1
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG1_PORT_ID_W                                                 6
#define IOC_IOCFG1_PORT_ID_M                                        0x0000003F
#define IOC_IOCFG1_PORT_ID_S                                                 0
#define IOC_IOCFG1_PORT_ID_RFC_SMI_CL_IN                            0x00000038
#define IOC_IOCFG1_PORT_ID_RFC_SMI_CL_OUT                           0x00000037
#define IOC_IOCFG1_PORT_ID_RFC_SMI_DL_IN                            0x00000036
#define IOC_IOCFG1_PORT_ID_RFC_SMI_DL_OUT                           0x00000035
#define IOC_IOCFG1_PORT_ID_RFC_GPI1                                 0x00000034
#define IOC_IOCFG1_PORT_ID_RFC_GPI0                                 0x00000033
#define IOC_IOCFG1_PORT_ID_RFC_GPO3                                 0x00000032
#define IOC_IOCFG1_PORT_ID_RFC_GPO2                                 0x00000031
#define IOC_IOCFG1_PORT_ID_RFC_GPO1                                 0x00000030
#define IOC_IOCFG1_PORT_ID_RFC_GPO0                                 0x0000002F
#define IOC_IOCFG1_PORT_ID_RFC_TRC                                  0x0000002E
#define IOC_IOCFG1_PORT_ID_I2S_MCLK                                 0x00000029
#define IOC_IOCFG1_PORT_ID_I2S_BCLK                                 0x00000028
#define IOC_IOCFG1_PORT_ID_I2S_WCLK                                 0x00000027
#define IOC_IOCFG1_PORT_ID_I2S_AD1                                  0x00000026
#define IOC_IOCFG1_PORT_ID_I2S_AD0                                  0x00000025
#define IOC_IOCFG1_PORT_ID_SSI1_CLK                                 0x00000024
#define IOC_IOCFG1_PORT_ID_SSI1_FSS                                 0x00000023
#define IOC_IOCFG1_PORT_ID_SSI1_TX                                  0x00000022
#define IOC_IOCFG1_PORT_ID_SSI1_RX                                  0x00000021
#define IOC_IOCFG1_PORT_ID_CPU_SWV                                  0x00000020
#define IOC_IOCFG1_PORT_ID_PORT_EVENT7                              0x0000001E
#define IOC_IOCFG1_PORT_ID_PORT_EVENT6                              0x0000001D
#define IOC_IOCFG1_PORT_ID_PORT_EVENT5                              0x0000001C
#define IOC_IOCFG1_PORT_ID_PORT_EVENT4                              0x0000001B
#define IOC_IOCFG1_PORT_ID_PORT_EVENT3                              0x0000001A
#define IOC_IOCFG1_PORT_ID_PORT_EVENT2                              0x00000019
#define IOC_IOCFG1_PORT_ID_PORT_EVENT1                              0x00000018
#define IOC_IOCFG1_PORT_ID_PORT_EVENT0                              0x00000017
#define IOC_IOCFG1_PORT_ID_UART1_RTS                                0x00000016
#define IOC_IOCFG1_PORT_ID_UART1_CTS                                0x00000015
#define IOC_IOCFG1_PORT_ID_UART1_TX                                 0x00000014
#define IOC_IOCFG1_PORT_ID_UART1_RX                                 0x00000013
#define IOC_IOCFG1_PORT_ID_UART0_RTS                                0x00000012
#define IOC_IOCFG1_PORT_ID_UART0_CTS                                0x00000011
#define IOC_IOCFG1_PORT_ID_UART0_TX                                 0x00000010
#define IOC_IOCFG1_PORT_ID_UART0_RX                                 0x0000000F
#define IOC_IOCFG1_PORT_ID_I2C_MSSCL                                0x0000000E
#define IOC_IOCFG1_PORT_ID_I2C_MSSDA                                0x0000000D
#define IOC_IOCFG1_PORT_ID_SSI0_CLK                                 0x0000000C
#define IOC_IOCFG1_PORT_ID_SSI0_FSS                                 0x0000000B
#define IOC_IOCFG1_PORT_ID_SSI0_TX                                  0x0000000A
#define IOC_IOCFG1_PORT_ID_SSI0_RX                                  0x00000009
#define IOC_IOCFG1_PORT_ID_AUX_IO                                   0x00000008
#define IOC_IOCFG1_PORT_ID_AON_CLK32K                               0x00000007
#define IOC_IOCFG1_PORT_ID_GPIO                                     0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG2
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG2_HYST_EN                                          0x40000000
#define IOC_IOCFG2_HYST_EN_BITN                                             30
#define IOC_IOCFG2_HYST_EN_M                                        0x40000000
#define IOC_IOCFG2_HYST_EN_S                                                30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG2_IE                                               0x20000000
#define IOC_IOCFG2_IE_BITN                                                  29
#define IOC_IOCFG2_IE_M                                             0x20000000
#define IOC_IOCFG2_IE_S                                                     29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG2_WU_CFG_W                                                  2
#define IOC_IOCFG2_WU_CFG_M                                         0x18000000
#define IOC_IOCFG2_WU_CFG_S                                                 27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG2_IOMODE_W                                                  3
#define IOC_IOCFG2_IOMODE_M                                         0x07000000
#define IOC_IOCFG2_IOMODE_S                                                 24
#define IOC_IOCFG2_IOMODE_OPENSRC_INV                               0x07000000
#define IOC_IOCFG2_IOMODE_OPENSRC                                   0x06000000
#define IOC_IOCFG2_IOMODE_OPENDR_INV                                0x05000000
#define IOC_IOCFG2_IOMODE_OPENDR                                    0x04000000
#define IOC_IOCFG2_IOMODE_INV                                       0x01000000
#define IOC_IOCFG2_IOMODE_NORMAL                                    0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG2_IOEV_AON_PROG2_EN                                0x00800000
#define IOC_IOCFG2_IOEV_AON_PROG2_EN_BITN                                   23
#define IOC_IOCFG2_IOEV_AON_PROG2_EN_M                              0x00800000
#define IOC_IOCFG2_IOEV_AON_PROG2_EN_S                                      23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG2_IOEV_AON_PROG1_EN                                0x00400000
#define IOC_IOCFG2_IOEV_AON_PROG1_EN_BITN                                   22
#define IOC_IOCFG2_IOEV_AON_PROG1_EN_M                              0x00400000
#define IOC_IOCFG2_IOEV_AON_PROG1_EN_S                                      22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG2_IOEV_AON_PROG0_EN                                0x00200000
#define IOC_IOCFG2_IOEV_AON_PROG0_EN_BITN                                   21
#define IOC_IOCFG2_IOEV_AON_PROG0_EN_M                              0x00200000
#define IOC_IOCFG2_IOEV_AON_PROG0_EN_S                                      21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG2_EDGE_IRQ_EN                                      0x00040000
#define IOC_IOCFG2_EDGE_IRQ_EN_BITN                                         18
#define IOC_IOCFG2_EDGE_IRQ_EN_M                                    0x00040000
#define IOC_IOCFG2_EDGE_IRQ_EN_S                                            18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG2_EDGE_DET_W                                                2
#define IOC_IOCFG2_EDGE_DET_M                                       0x00030000
#define IOC_IOCFG2_EDGE_DET_S                                               16
#define IOC_IOCFG2_EDGE_DET_BOTH                                    0x00030000
#define IOC_IOCFG2_EDGE_DET_POS                                     0x00020000
#define IOC_IOCFG2_EDGE_DET_NEG                                     0x00010000
#define IOC_IOCFG2_EDGE_DET_NONE                                    0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG2_PULL_CTL_W                                                2
#define IOC_IOCFG2_PULL_CTL_M                                       0x00006000
#define IOC_IOCFG2_PULL_CTL_S                                               13
#define IOC_IOCFG2_PULL_CTL_DIS                                     0x00006000
#define IOC_IOCFG2_PULL_CTL_UP                                      0x00004000
#define IOC_IOCFG2_PULL_CTL_DWN                                     0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG2_SLEW_RED                                         0x00001000
#define IOC_IOCFG2_SLEW_RED_BITN                                            12
#define IOC_IOCFG2_SLEW_RED_M                                       0x00001000
#define IOC_IOCFG2_SLEW_RED_S                                               12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG2_IOCURR_W                                                  2
#define IOC_IOCFG2_IOCURR_M                                         0x00000C00
#define IOC_IOCFG2_IOCURR_S                                                 10
#define IOC_IOCFG2_IOCURR_4_8MA                                     0x00000800
#define IOC_IOCFG2_IOCURR_4MA                                       0x00000400
#define IOC_IOCFG2_IOCURR_2MA                                       0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG2_IOSTR_W                                                   2
#define IOC_IOCFG2_IOSTR_M                                          0x00000300
#define IOC_IOCFG2_IOSTR_S                                                   8
#define IOC_IOCFG2_IOSTR_MAX                                        0x00000300
#define IOC_IOCFG2_IOSTR_MED                                        0x00000200
#define IOC_IOCFG2_IOSTR_MIN                                        0x00000100
#define IOC_IOCFG2_IOSTR_AUTO                                       0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG2_IOEV_RTC_EN                                      0x00000080
#define IOC_IOCFG2_IOEV_RTC_EN_BITN                                          7
#define IOC_IOCFG2_IOEV_RTC_EN_M                                    0x00000080
#define IOC_IOCFG2_IOEV_RTC_EN_S                                             7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG2_IOEV_MCU_WU_EN                                   0x00000040
#define IOC_IOCFG2_IOEV_MCU_WU_EN_BITN                                       6
#define IOC_IOCFG2_IOEV_MCU_WU_EN_M                                 0x00000040
#define IOC_IOCFG2_IOEV_MCU_WU_EN_S                                          6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO2
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG2_PORT_ID_W                                                 6
#define IOC_IOCFG2_PORT_ID_M                                        0x0000003F
#define IOC_IOCFG2_PORT_ID_S                                                 0
#define IOC_IOCFG2_PORT_ID_RFC_SMI_CL_IN                            0x00000038
#define IOC_IOCFG2_PORT_ID_RFC_SMI_CL_OUT                           0x00000037
#define IOC_IOCFG2_PORT_ID_RFC_SMI_DL_IN                            0x00000036
#define IOC_IOCFG2_PORT_ID_RFC_SMI_DL_OUT                           0x00000035
#define IOC_IOCFG2_PORT_ID_RFC_GPI1                                 0x00000034
#define IOC_IOCFG2_PORT_ID_RFC_GPI0                                 0x00000033
#define IOC_IOCFG2_PORT_ID_RFC_GPO3                                 0x00000032
#define IOC_IOCFG2_PORT_ID_RFC_GPO2                                 0x00000031
#define IOC_IOCFG2_PORT_ID_RFC_GPO1                                 0x00000030
#define IOC_IOCFG2_PORT_ID_RFC_GPO0                                 0x0000002F
#define IOC_IOCFG2_PORT_ID_RFC_TRC                                  0x0000002E
#define IOC_IOCFG2_PORT_ID_I2S_MCLK                                 0x00000029
#define IOC_IOCFG2_PORT_ID_I2S_BCLK                                 0x00000028
#define IOC_IOCFG2_PORT_ID_I2S_WCLK                                 0x00000027
#define IOC_IOCFG2_PORT_ID_I2S_AD1                                  0x00000026
#define IOC_IOCFG2_PORT_ID_I2S_AD0                                  0x00000025
#define IOC_IOCFG2_PORT_ID_SSI1_CLK                                 0x00000024
#define IOC_IOCFG2_PORT_ID_SSI1_FSS                                 0x00000023
#define IOC_IOCFG2_PORT_ID_SSI1_TX                                  0x00000022
#define IOC_IOCFG2_PORT_ID_SSI1_RX                                  0x00000021
#define IOC_IOCFG2_PORT_ID_CPU_SWV                                  0x00000020
#define IOC_IOCFG2_PORT_ID_PORT_EVENT7                              0x0000001E
#define IOC_IOCFG2_PORT_ID_PORT_EVENT6                              0x0000001D
#define IOC_IOCFG2_PORT_ID_PORT_EVENT5                              0x0000001C
#define IOC_IOCFG2_PORT_ID_PORT_EVENT4                              0x0000001B
#define IOC_IOCFG2_PORT_ID_PORT_EVENT3                              0x0000001A
#define IOC_IOCFG2_PORT_ID_PORT_EVENT2                              0x00000019
#define IOC_IOCFG2_PORT_ID_PORT_EVENT1                              0x00000018
#define IOC_IOCFG2_PORT_ID_PORT_EVENT0                              0x00000017
#define IOC_IOCFG2_PORT_ID_UART1_RTS                                0x00000016
#define IOC_IOCFG2_PORT_ID_UART1_CTS                                0x00000015
#define IOC_IOCFG2_PORT_ID_UART1_TX                                 0x00000014
#define IOC_IOCFG2_PORT_ID_UART1_RX                                 0x00000013
#define IOC_IOCFG2_PORT_ID_UART0_RTS                                0x00000012
#define IOC_IOCFG2_PORT_ID_UART0_CTS                                0x00000011
#define IOC_IOCFG2_PORT_ID_UART0_TX                                 0x00000010
#define IOC_IOCFG2_PORT_ID_UART0_RX                                 0x0000000F
#define IOC_IOCFG2_PORT_ID_I2C_MSSCL                                0x0000000E
#define IOC_IOCFG2_PORT_ID_I2C_MSSDA                                0x0000000D
#define IOC_IOCFG2_PORT_ID_SSI0_CLK                                 0x0000000C
#define IOC_IOCFG2_PORT_ID_SSI0_FSS                                 0x0000000B
#define IOC_IOCFG2_PORT_ID_SSI0_TX                                  0x0000000A
#define IOC_IOCFG2_PORT_ID_SSI0_RX                                  0x00000009
#define IOC_IOCFG2_PORT_ID_AUX_IO                                   0x00000008
#define IOC_IOCFG2_PORT_ID_AON_CLK32K                               0x00000007
#define IOC_IOCFG2_PORT_ID_GPIO                                     0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG3
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG3_HYST_EN                                          0x40000000
#define IOC_IOCFG3_HYST_EN_BITN                                             30
#define IOC_IOCFG3_HYST_EN_M                                        0x40000000
#define IOC_IOCFG3_HYST_EN_S                                                30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG3_IE                                               0x20000000
#define IOC_IOCFG3_IE_BITN                                                  29
#define IOC_IOCFG3_IE_M                                             0x20000000
#define IOC_IOCFG3_IE_S                                                     29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG3_WU_CFG_W                                                  2
#define IOC_IOCFG3_WU_CFG_M                                         0x18000000
#define IOC_IOCFG3_WU_CFG_S                                                 27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG3_IOMODE_W                                                  3
#define IOC_IOCFG3_IOMODE_M                                         0x07000000
#define IOC_IOCFG3_IOMODE_S                                                 24
#define IOC_IOCFG3_IOMODE_OPENSRC_INV                               0x07000000
#define IOC_IOCFG3_IOMODE_OPENSRC                                   0x06000000
#define IOC_IOCFG3_IOMODE_OPENDR_INV                                0x05000000
#define IOC_IOCFG3_IOMODE_OPENDR                                    0x04000000
#define IOC_IOCFG3_IOMODE_INV                                       0x01000000
#define IOC_IOCFG3_IOMODE_NORMAL                                    0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG3_IOEV_AON_PROG2_EN                                0x00800000
#define IOC_IOCFG3_IOEV_AON_PROG2_EN_BITN                                   23
#define IOC_IOCFG3_IOEV_AON_PROG2_EN_M                              0x00800000
#define IOC_IOCFG3_IOEV_AON_PROG2_EN_S                                      23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG3_IOEV_AON_PROG1_EN                                0x00400000
#define IOC_IOCFG3_IOEV_AON_PROG1_EN_BITN                                   22
#define IOC_IOCFG3_IOEV_AON_PROG1_EN_M                              0x00400000
#define IOC_IOCFG3_IOEV_AON_PROG1_EN_S                                      22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG3_IOEV_AON_PROG0_EN                                0x00200000
#define IOC_IOCFG3_IOEV_AON_PROG0_EN_BITN                                   21
#define IOC_IOCFG3_IOEV_AON_PROG0_EN_M                              0x00200000
#define IOC_IOCFG3_IOEV_AON_PROG0_EN_S                                      21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG3_EDGE_IRQ_EN                                      0x00040000
#define IOC_IOCFG3_EDGE_IRQ_EN_BITN                                         18
#define IOC_IOCFG3_EDGE_IRQ_EN_M                                    0x00040000
#define IOC_IOCFG3_EDGE_IRQ_EN_S                                            18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG3_EDGE_DET_W                                                2
#define IOC_IOCFG3_EDGE_DET_M                                       0x00030000
#define IOC_IOCFG3_EDGE_DET_S                                               16
#define IOC_IOCFG3_EDGE_DET_BOTH                                    0x00030000
#define IOC_IOCFG3_EDGE_DET_POS                                     0x00020000
#define IOC_IOCFG3_EDGE_DET_NEG                                     0x00010000
#define IOC_IOCFG3_EDGE_DET_NONE                                    0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG3_PULL_CTL_W                                                2
#define IOC_IOCFG3_PULL_CTL_M                                       0x00006000
#define IOC_IOCFG3_PULL_CTL_S                                               13
#define IOC_IOCFG3_PULL_CTL_DIS                                     0x00006000
#define IOC_IOCFG3_PULL_CTL_UP                                      0x00004000
#define IOC_IOCFG3_PULL_CTL_DWN                                     0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG3_SLEW_RED                                         0x00001000
#define IOC_IOCFG3_SLEW_RED_BITN                                            12
#define IOC_IOCFG3_SLEW_RED_M                                       0x00001000
#define IOC_IOCFG3_SLEW_RED_S                                               12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG3_IOCURR_W                                                  2
#define IOC_IOCFG3_IOCURR_M                                         0x00000C00
#define IOC_IOCFG3_IOCURR_S                                                 10
#define IOC_IOCFG3_IOCURR_4_8MA                                     0x00000800
#define IOC_IOCFG3_IOCURR_4MA                                       0x00000400
#define IOC_IOCFG3_IOCURR_2MA                                       0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG3_IOSTR_W                                                   2
#define IOC_IOCFG3_IOSTR_M                                          0x00000300
#define IOC_IOCFG3_IOSTR_S                                                   8
#define IOC_IOCFG3_IOSTR_MAX                                        0x00000300
#define IOC_IOCFG3_IOSTR_MED                                        0x00000200
#define IOC_IOCFG3_IOSTR_MIN                                        0x00000100
#define IOC_IOCFG3_IOSTR_AUTO                                       0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG3_IOEV_RTC_EN                                      0x00000080
#define IOC_IOCFG3_IOEV_RTC_EN_BITN                                          7
#define IOC_IOCFG3_IOEV_RTC_EN_M                                    0x00000080
#define IOC_IOCFG3_IOEV_RTC_EN_S                                             7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG3_IOEV_MCU_WU_EN                                   0x00000040
#define IOC_IOCFG3_IOEV_MCU_WU_EN_BITN                                       6
#define IOC_IOCFG3_IOEV_MCU_WU_EN_M                                 0x00000040
#define IOC_IOCFG3_IOEV_MCU_WU_EN_S                                          6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO3
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG3_PORT_ID_W                                                 6
#define IOC_IOCFG3_PORT_ID_M                                        0x0000003F
#define IOC_IOCFG3_PORT_ID_S                                                 0
#define IOC_IOCFG3_PORT_ID_RFC_SMI_CL_IN                            0x00000038
#define IOC_IOCFG3_PORT_ID_RFC_SMI_CL_OUT                           0x00000037
#define IOC_IOCFG3_PORT_ID_RFC_SMI_DL_IN                            0x00000036
#define IOC_IOCFG3_PORT_ID_RFC_SMI_DL_OUT                           0x00000035
#define IOC_IOCFG3_PORT_ID_RFC_GPI1                                 0x00000034
#define IOC_IOCFG3_PORT_ID_RFC_GPI0                                 0x00000033
#define IOC_IOCFG3_PORT_ID_RFC_GPO3                                 0x00000032
#define IOC_IOCFG3_PORT_ID_RFC_GPO2                                 0x00000031
#define IOC_IOCFG3_PORT_ID_RFC_GPO1                                 0x00000030
#define IOC_IOCFG3_PORT_ID_RFC_GPO0                                 0x0000002F
#define IOC_IOCFG3_PORT_ID_RFC_TRC                                  0x0000002E
#define IOC_IOCFG3_PORT_ID_I2S_MCLK                                 0x00000029
#define IOC_IOCFG3_PORT_ID_I2S_BCLK                                 0x00000028
#define IOC_IOCFG3_PORT_ID_I2S_WCLK                                 0x00000027
#define IOC_IOCFG3_PORT_ID_I2S_AD1                                  0x00000026
#define IOC_IOCFG3_PORT_ID_I2S_AD0                                  0x00000025
#define IOC_IOCFG3_PORT_ID_SSI1_CLK                                 0x00000024
#define IOC_IOCFG3_PORT_ID_SSI1_FSS                                 0x00000023
#define IOC_IOCFG3_PORT_ID_SSI1_TX                                  0x00000022
#define IOC_IOCFG3_PORT_ID_SSI1_RX                                  0x00000021
#define IOC_IOCFG3_PORT_ID_CPU_SWV                                  0x00000020
#define IOC_IOCFG3_PORT_ID_PORT_EVENT7                              0x0000001E
#define IOC_IOCFG3_PORT_ID_PORT_EVENT6                              0x0000001D
#define IOC_IOCFG3_PORT_ID_PORT_EVENT5                              0x0000001C
#define IOC_IOCFG3_PORT_ID_PORT_EVENT4                              0x0000001B
#define IOC_IOCFG3_PORT_ID_PORT_EVENT3                              0x0000001A
#define IOC_IOCFG3_PORT_ID_PORT_EVENT2                              0x00000019
#define IOC_IOCFG3_PORT_ID_PORT_EVENT1                              0x00000018
#define IOC_IOCFG3_PORT_ID_PORT_EVENT0                              0x00000017
#define IOC_IOCFG3_PORT_ID_UART1_RTS                                0x00000016
#define IOC_IOCFG3_PORT_ID_UART1_CTS                                0x00000015
#define IOC_IOCFG3_PORT_ID_UART1_TX                                 0x00000014
#define IOC_IOCFG3_PORT_ID_UART1_RX                                 0x00000013
#define IOC_IOCFG3_PORT_ID_UART0_RTS                                0x00000012
#define IOC_IOCFG3_PORT_ID_UART0_CTS                                0x00000011
#define IOC_IOCFG3_PORT_ID_UART0_TX                                 0x00000010
#define IOC_IOCFG3_PORT_ID_UART0_RX                                 0x0000000F
#define IOC_IOCFG3_PORT_ID_I2C_MSSCL                                0x0000000E
#define IOC_IOCFG3_PORT_ID_I2C_MSSDA                                0x0000000D
#define IOC_IOCFG3_PORT_ID_SSI0_CLK                                 0x0000000C
#define IOC_IOCFG3_PORT_ID_SSI0_FSS                                 0x0000000B
#define IOC_IOCFG3_PORT_ID_SSI0_TX                                  0x0000000A
#define IOC_IOCFG3_PORT_ID_SSI0_RX                                  0x00000009
#define IOC_IOCFG3_PORT_ID_AUX_IO                                   0x00000008
#define IOC_IOCFG3_PORT_ID_AON_CLK32K                               0x00000007
#define IOC_IOCFG3_PORT_ID_GPIO                                     0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG4
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG4_HYST_EN                                          0x40000000
#define IOC_IOCFG4_HYST_EN_BITN                                             30
#define IOC_IOCFG4_HYST_EN_M                                        0x40000000
#define IOC_IOCFG4_HYST_EN_S                                                30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG4_IE                                               0x20000000
#define IOC_IOCFG4_IE_BITN                                                  29
#define IOC_IOCFG4_IE_M                                             0x20000000
#define IOC_IOCFG4_IE_S                                                     29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG4_WU_CFG_W                                                  2
#define IOC_IOCFG4_WU_CFG_M                                         0x18000000
#define IOC_IOCFG4_WU_CFG_S                                                 27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG4_IOMODE_W                                                  3
#define IOC_IOCFG4_IOMODE_M                                         0x07000000
#define IOC_IOCFG4_IOMODE_S                                                 24
#define IOC_IOCFG4_IOMODE_OPENSRC_INV                               0x07000000
#define IOC_IOCFG4_IOMODE_OPENSRC                                   0x06000000
#define IOC_IOCFG4_IOMODE_OPENDR_INV                                0x05000000
#define IOC_IOCFG4_IOMODE_OPENDR                                    0x04000000
#define IOC_IOCFG4_IOMODE_INV                                       0x01000000
#define IOC_IOCFG4_IOMODE_NORMAL                                    0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG4_IOEV_AON_PROG2_EN                                0x00800000
#define IOC_IOCFG4_IOEV_AON_PROG2_EN_BITN                                   23
#define IOC_IOCFG4_IOEV_AON_PROG2_EN_M                              0x00800000
#define IOC_IOCFG4_IOEV_AON_PROG2_EN_S                                      23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG4_IOEV_AON_PROG1_EN                                0x00400000
#define IOC_IOCFG4_IOEV_AON_PROG1_EN_BITN                                   22
#define IOC_IOCFG4_IOEV_AON_PROG1_EN_M                              0x00400000
#define IOC_IOCFG4_IOEV_AON_PROG1_EN_S                                      22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG4_IOEV_AON_PROG0_EN                                0x00200000
#define IOC_IOCFG4_IOEV_AON_PROG0_EN_BITN                                   21
#define IOC_IOCFG4_IOEV_AON_PROG0_EN_M                              0x00200000
#define IOC_IOCFG4_IOEV_AON_PROG0_EN_S                                      21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG4_EDGE_IRQ_EN                                      0x00040000
#define IOC_IOCFG4_EDGE_IRQ_EN_BITN                                         18
#define IOC_IOCFG4_EDGE_IRQ_EN_M                                    0x00040000
#define IOC_IOCFG4_EDGE_IRQ_EN_S                                            18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG4_EDGE_DET_W                                                2
#define IOC_IOCFG4_EDGE_DET_M                                       0x00030000
#define IOC_IOCFG4_EDGE_DET_S                                               16
#define IOC_IOCFG4_EDGE_DET_BOTH                                    0x00030000
#define IOC_IOCFG4_EDGE_DET_POS                                     0x00020000
#define IOC_IOCFG4_EDGE_DET_NEG                                     0x00010000
#define IOC_IOCFG4_EDGE_DET_NONE                                    0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG4_PULL_CTL_W                                                2
#define IOC_IOCFG4_PULL_CTL_M                                       0x00006000
#define IOC_IOCFG4_PULL_CTL_S                                               13
#define IOC_IOCFG4_PULL_CTL_DIS                                     0x00006000
#define IOC_IOCFG4_PULL_CTL_UP                                      0x00004000
#define IOC_IOCFG4_PULL_CTL_DWN                                     0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG4_SLEW_RED                                         0x00001000
#define IOC_IOCFG4_SLEW_RED_BITN                                            12
#define IOC_IOCFG4_SLEW_RED_M                                       0x00001000
#define IOC_IOCFG4_SLEW_RED_S                                               12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG4_IOCURR_W                                                  2
#define IOC_IOCFG4_IOCURR_M                                         0x00000C00
#define IOC_IOCFG4_IOCURR_S                                                 10
#define IOC_IOCFG4_IOCURR_4_8MA                                     0x00000800
#define IOC_IOCFG4_IOCURR_4MA                                       0x00000400
#define IOC_IOCFG4_IOCURR_2MA                                       0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG4_IOSTR_W                                                   2
#define IOC_IOCFG4_IOSTR_M                                          0x00000300
#define IOC_IOCFG4_IOSTR_S                                                   8
#define IOC_IOCFG4_IOSTR_MAX                                        0x00000300
#define IOC_IOCFG4_IOSTR_MED                                        0x00000200
#define IOC_IOCFG4_IOSTR_MIN                                        0x00000100
#define IOC_IOCFG4_IOSTR_AUTO                                       0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG4_IOEV_RTC_EN                                      0x00000080
#define IOC_IOCFG4_IOEV_RTC_EN_BITN                                          7
#define IOC_IOCFG4_IOEV_RTC_EN_M                                    0x00000080
#define IOC_IOCFG4_IOEV_RTC_EN_S                                             7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG4_IOEV_MCU_WU_EN                                   0x00000040
#define IOC_IOCFG4_IOEV_MCU_WU_EN_BITN                                       6
#define IOC_IOCFG4_IOEV_MCU_WU_EN_M                                 0x00000040
#define IOC_IOCFG4_IOEV_MCU_WU_EN_S                                          6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO4
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG4_PORT_ID_W                                                 6
#define IOC_IOCFG4_PORT_ID_M                                        0x0000003F
#define IOC_IOCFG4_PORT_ID_S                                                 0
#define IOC_IOCFG4_PORT_ID_RFC_SMI_CL_IN                            0x00000038
#define IOC_IOCFG4_PORT_ID_RFC_SMI_CL_OUT                           0x00000037
#define IOC_IOCFG4_PORT_ID_RFC_SMI_DL_IN                            0x00000036
#define IOC_IOCFG4_PORT_ID_RFC_SMI_DL_OUT                           0x00000035
#define IOC_IOCFG4_PORT_ID_RFC_GPI1                                 0x00000034
#define IOC_IOCFG4_PORT_ID_RFC_GPI0                                 0x00000033
#define IOC_IOCFG4_PORT_ID_RFC_GPO3                                 0x00000032
#define IOC_IOCFG4_PORT_ID_RFC_GPO2                                 0x00000031
#define IOC_IOCFG4_PORT_ID_RFC_GPO1                                 0x00000030
#define IOC_IOCFG4_PORT_ID_RFC_GPO0                                 0x0000002F
#define IOC_IOCFG4_PORT_ID_RFC_TRC                                  0x0000002E
#define IOC_IOCFG4_PORT_ID_I2S_MCLK                                 0x00000029
#define IOC_IOCFG4_PORT_ID_I2S_BCLK                                 0x00000028
#define IOC_IOCFG4_PORT_ID_I2S_WCLK                                 0x00000027
#define IOC_IOCFG4_PORT_ID_I2S_AD1                                  0x00000026
#define IOC_IOCFG4_PORT_ID_I2S_AD0                                  0x00000025
#define IOC_IOCFG4_PORT_ID_SSI1_CLK                                 0x00000024
#define IOC_IOCFG4_PORT_ID_SSI1_FSS                                 0x00000023
#define IOC_IOCFG4_PORT_ID_SSI1_TX                                  0x00000022
#define IOC_IOCFG4_PORT_ID_SSI1_RX                                  0x00000021
#define IOC_IOCFG4_PORT_ID_CPU_SWV                                  0x00000020
#define IOC_IOCFG4_PORT_ID_PORT_EVENT7                              0x0000001E
#define IOC_IOCFG4_PORT_ID_PORT_EVENT6                              0x0000001D
#define IOC_IOCFG4_PORT_ID_PORT_EVENT5                              0x0000001C
#define IOC_IOCFG4_PORT_ID_PORT_EVENT4                              0x0000001B
#define IOC_IOCFG4_PORT_ID_PORT_EVENT3                              0x0000001A
#define IOC_IOCFG4_PORT_ID_PORT_EVENT2                              0x00000019
#define IOC_IOCFG4_PORT_ID_PORT_EVENT1                              0x00000018
#define IOC_IOCFG4_PORT_ID_PORT_EVENT0                              0x00000017
#define IOC_IOCFG4_PORT_ID_UART1_RTS                                0x00000016
#define IOC_IOCFG4_PORT_ID_UART1_CTS                                0x00000015
#define IOC_IOCFG4_PORT_ID_UART1_TX                                 0x00000014
#define IOC_IOCFG4_PORT_ID_UART1_RX                                 0x00000013
#define IOC_IOCFG4_PORT_ID_UART0_RTS                                0x00000012
#define IOC_IOCFG4_PORT_ID_UART0_CTS                                0x00000011
#define IOC_IOCFG4_PORT_ID_UART0_TX                                 0x00000010
#define IOC_IOCFG4_PORT_ID_UART0_RX                                 0x0000000F
#define IOC_IOCFG4_PORT_ID_I2C_MSSCL                                0x0000000E
#define IOC_IOCFG4_PORT_ID_I2C_MSSDA                                0x0000000D
#define IOC_IOCFG4_PORT_ID_SSI0_CLK                                 0x0000000C
#define IOC_IOCFG4_PORT_ID_SSI0_FSS                                 0x0000000B
#define IOC_IOCFG4_PORT_ID_SSI0_TX                                  0x0000000A
#define IOC_IOCFG4_PORT_ID_SSI0_RX                                  0x00000009
#define IOC_IOCFG4_PORT_ID_AUX_IO                                   0x00000008
#define IOC_IOCFG4_PORT_ID_AON_CLK32K                               0x00000007
#define IOC_IOCFG4_PORT_ID_GPIO                                     0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG5
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG5_HYST_EN                                          0x40000000
#define IOC_IOCFG5_HYST_EN_BITN                                             30
#define IOC_IOCFG5_HYST_EN_M                                        0x40000000
#define IOC_IOCFG5_HYST_EN_S                                                30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG5_IE                                               0x20000000
#define IOC_IOCFG5_IE_BITN                                                  29
#define IOC_IOCFG5_IE_M                                             0x20000000
#define IOC_IOCFG5_IE_S                                                     29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG5_WU_CFG_W                                                  2
#define IOC_IOCFG5_WU_CFG_M                                         0x18000000
#define IOC_IOCFG5_WU_CFG_S                                                 27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG5_IOMODE_W                                                  3
#define IOC_IOCFG5_IOMODE_M                                         0x07000000
#define IOC_IOCFG5_IOMODE_S                                                 24
#define IOC_IOCFG5_IOMODE_OPENSRC_INV                               0x07000000
#define IOC_IOCFG5_IOMODE_OPENSRC                                   0x06000000
#define IOC_IOCFG5_IOMODE_OPENDR_INV                                0x05000000
#define IOC_IOCFG5_IOMODE_OPENDR                                    0x04000000
#define IOC_IOCFG5_IOMODE_INV                                       0x01000000
#define IOC_IOCFG5_IOMODE_NORMAL                                    0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG5_IOEV_AON_PROG2_EN                                0x00800000
#define IOC_IOCFG5_IOEV_AON_PROG2_EN_BITN                                   23
#define IOC_IOCFG5_IOEV_AON_PROG2_EN_M                              0x00800000
#define IOC_IOCFG5_IOEV_AON_PROG2_EN_S                                      23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG5_IOEV_AON_PROG1_EN                                0x00400000
#define IOC_IOCFG5_IOEV_AON_PROG1_EN_BITN                                   22
#define IOC_IOCFG5_IOEV_AON_PROG1_EN_M                              0x00400000
#define IOC_IOCFG5_IOEV_AON_PROG1_EN_S                                      22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG5_IOEV_AON_PROG0_EN                                0x00200000
#define IOC_IOCFG5_IOEV_AON_PROG0_EN_BITN                                   21
#define IOC_IOCFG5_IOEV_AON_PROG0_EN_M                              0x00200000
#define IOC_IOCFG5_IOEV_AON_PROG0_EN_S                                      21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG5_EDGE_IRQ_EN                                      0x00040000
#define IOC_IOCFG5_EDGE_IRQ_EN_BITN                                         18
#define IOC_IOCFG5_EDGE_IRQ_EN_M                                    0x00040000
#define IOC_IOCFG5_EDGE_IRQ_EN_S                                            18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG5_EDGE_DET_W                                                2
#define IOC_IOCFG5_EDGE_DET_M                                       0x00030000
#define IOC_IOCFG5_EDGE_DET_S                                               16
#define IOC_IOCFG5_EDGE_DET_BOTH                                    0x00030000
#define IOC_IOCFG5_EDGE_DET_POS                                     0x00020000
#define IOC_IOCFG5_EDGE_DET_NEG                                     0x00010000
#define IOC_IOCFG5_EDGE_DET_NONE                                    0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG5_PULL_CTL_W                                                2
#define IOC_IOCFG5_PULL_CTL_M                                       0x00006000
#define IOC_IOCFG5_PULL_CTL_S                                               13
#define IOC_IOCFG5_PULL_CTL_DIS                                     0x00006000
#define IOC_IOCFG5_PULL_CTL_UP                                      0x00004000
#define IOC_IOCFG5_PULL_CTL_DWN                                     0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG5_SLEW_RED                                         0x00001000
#define IOC_IOCFG5_SLEW_RED_BITN                                            12
#define IOC_IOCFG5_SLEW_RED_M                                       0x00001000
#define IOC_IOCFG5_SLEW_RED_S                                               12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG5_IOCURR_W                                                  2
#define IOC_IOCFG5_IOCURR_M                                         0x00000C00
#define IOC_IOCFG5_IOCURR_S                                                 10
#define IOC_IOCFG5_IOCURR_4_8MA                                     0x00000800
#define IOC_IOCFG5_IOCURR_4MA                                       0x00000400
#define IOC_IOCFG5_IOCURR_2MA                                       0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG5_IOSTR_W                                                   2
#define IOC_IOCFG5_IOSTR_M                                          0x00000300
#define IOC_IOCFG5_IOSTR_S                                                   8
#define IOC_IOCFG5_IOSTR_MAX                                        0x00000300
#define IOC_IOCFG5_IOSTR_MED                                        0x00000200
#define IOC_IOCFG5_IOSTR_MIN                                        0x00000100
#define IOC_IOCFG5_IOSTR_AUTO                                       0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG5_IOEV_RTC_EN                                      0x00000080
#define IOC_IOCFG5_IOEV_RTC_EN_BITN                                          7
#define IOC_IOCFG5_IOEV_RTC_EN_M                                    0x00000080
#define IOC_IOCFG5_IOEV_RTC_EN_S                                             7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG5_IOEV_MCU_WU_EN                                   0x00000040
#define IOC_IOCFG5_IOEV_MCU_WU_EN_BITN                                       6
#define IOC_IOCFG5_IOEV_MCU_WU_EN_M                                 0x00000040
#define IOC_IOCFG5_IOEV_MCU_WU_EN_S                                          6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO5
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG5_PORT_ID_W                                                 6
#define IOC_IOCFG5_PORT_ID_M                                        0x0000003F
#define IOC_IOCFG5_PORT_ID_S                                                 0
#define IOC_IOCFG5_PORT_ID_RFC_SMI_CL_IN                            0x00000038
#define IOC_IOCFG5_PORT_ID_RFC_SMI_CL_OUT                           0x00000037
#define IOC_IOCFG5_PORT_ID_RFC_SMI_DL_IN                            0x00000036
#define IOC_IOCFG5_PORT_ID_RFC_SMI_DL_OUT                           0x00000035
#define IOC_IOCFG5_PORT_ID_RFC_GPI1                                 0x00000034
#define IOC_IOCFG5_PORT_ID_RFC_GPI0                                 0x00000033
#define IOC_IOCFG5_PORT_ID_RFC_GPO3                                 0x00000032
#define IOC_IOCFG5_PORT_ID_RFC_GPO2                                 0x00000031
#define IOC_IOCFG5_PORT_ID_RFC_GPO1                                 0x00000030
#define IOC_IOCFG5_PORT_ID_RFC_GPO0                                 0x0000002F
#define IOC_IOCFG5_PORT_ID_RFC_TRC                                  0x0000002E
#define IOC_IOCFG5_PORT_ID_I2S_MCLK                                 0x00000029
#define IOC_IOCFG5_PORT_ID_I2S_BCLK                                 0x00000028
#define IOC_IOCFG5_PORT_ID_I2S_WCLK                                 0x00000027
#define IOC_IOCFG5_PORT_ID_I2S_AD1                                  0x00000026
#define IOC_IOCFG5_PORT_ID_I2S_AD0                                  0x00000025
#define IOC_IOCFG5_PORT_ID_SSI1_CLK                                 0x00000024
#define IOC_IOCFG5_PORT_ID_SSI1_FSS                                 0x00000023
#define IOC_IOCFG5_PORT_ID_SSI1_TX                                  0x00000022
#define IOC_IOCFG5_PORT_ID_SSI1_RX                                  0x00000021
#define IOC_IOCFG5_PORT_ID_CPU_SWV                                  0x00000020
#define IOC_IOCFG5_PORT_ID_PORT_EVENT7                              0x0000001E
#define IOC_IOCFG5_PORT_ID_PORT_EVENT6                              0x0000001D
#define IOC_IOCFG5_PORT_ID_PORT_EVENT5                              0x0000001C
#define IOC_IOCFG5_PORT_ID_PORT_EVENT4                              0x0000001B
#define IOC_IOCFG5_PORT_ID_PORT_EVENT3                              0x0000001A
#define IOC_IOCFG5_PORT_ID_PORT_EVENT2                              0x00000019
#define IOC_IOCFG5_PORT_ID_PORT_EVENT1                              0x00000018
#define IOC_IOCFG5_PORT_ID_PORT_EVENT0                              0x00000017
#define IOC_IOCFG5_PORT_ID_UART1_RTS                                0x00000016
#define IOC_IOCFG5_PORT_ID_UART1_CTS                                0x00000015
#define IOC_IOCFG5_PORT_ID_UART1_TX                                 0x00000014
#define IOC_IOCFG5_PORT_ID_UART1_RX                                 0x00000013
#define IOC_IOCFG5_PORT_ID_UART0_RTS                                0x00000012
#define IOC_IOCFG5_PORT_ID_UART0_CTS                                0x00000011
#define IOC_IOCFG5_PORT_ID_UART0_TX                                 0x00000010
#define IOC_IOCFG5_PORT_ID_UART0_RX                                 0x0000000F
#define IOC_IOCFG5_PORT_ID_I2C_MSSCL                                0x0000000E
#define IOC_IOCFG5_PORT_ID_I2C_MSSDA                                0x0000000D
#define IOC_IOCFG5_PORT_ID_SSI0_CLK                                 0x0000000C
#define IOC_IOCFG5_PORT_ID_SSI0_FSS                                 0x0000000B
#define IOC_IOCFG5_PORT_ID_SSI0_TX                                  0x0000000A
#define IOC_IOCFG5_PORT_ID_SSI0_RX                                  0x00000009
#define IOC_IOCFG5_PORT_ID_AUX_IO                                   0x00000008
#define IOC_IOCFG5_PORT_ID_AON_CLK32K                               0x00000007
#define IOC_IOCFG5_PORT_ID_GPIO                                     0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG6
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG6_HYST_EN                                          0x40000000
#define IOC_IOCFG6_HYST_EN_BITN                                             30
#define IOC_IOCFG6_HYST_EN_M                                        0x40000000
#define IOC_IOCFG6_HYST_EN_S                                                30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG6_IE                                               0x20000000
#define IOC_IOCFG6_IE_BITN                                                  29
#define IOC_IOCFG6_IE_M                                             0x20000000
#define IOC_IOCFG6_IE_S                                                     29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG6_WU_CFG_W                                                  2
#define IOC_IOCFG6_WU_CFG_M                                         0x18000000
#define IOC_IOCFG6_WU_CFG_S                                                 27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG6_IOMODE_W                                                  3
#define IOC_IOCFG6_IOMODE_M                                         0x07000000
#define IOC_IOCFG6_IOMODE_S                                                 24
#define IOC_IOCFG6_IOMODE_OPENSRC_INV                               0x07000000
#define IOC_IOCFG6_IOMODE_OPENSRC                                   0x06000000
#define IOC_IOCFG6_IOMODE_OPENDR_INV                                0x05000000
#define IOC_IOCFG6_IOMODE_OPENDR                                    0x04000000
#define IOC_IOCFG6_IOMODE_INV                                       0x01000000
#define IOC_IOCFG6_IOMODE_NORMAL                                    0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG6_IOEV_AON_PROG2_EN                                0x00800000
#define IOC_IOCFG6_IOEV_AON_PROG2_EN_BITN                                   23
#define IOC_IOCFG6_IOEV_AON_PROG2_EN_M                              0x00800000
#define IOC_IOCFG6_IOEV_AON_PROG2_EN_S                                      23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG6_IOEV_AON_PROG1_EN                                0x00400000
#define IOC_IOCFG6_IOEV_AON_PROG1_EN_BITN                                   22
#define IOC_IOCFG6_IOEV_AON_PROG1_EN_M                              0x00400000
#define IOC_IOCFG6_IOEV_AON_PROG1_EN_S                                      22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG6_IOEV_AON_PROG0_EN                                0x00200000
#define IOC_IOCFG6_IOEV_AON_PROG0_EN_BITN                                   21
#define IOC_IOCFG6_IOEV_AON_PROG0_EN_M                              0x00200000
#define IOC_IOCFG6_IOEV_AON_PROG0_EN_S                                      21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG6_EDGE_IRQ_EN                                      0x00040000
#define IOC_IOCFG6_EDGE_IRQ_EN_BITN                                         18
#define IOC_IOCFG6_EDGE_IRQ_EN_M                                    0x00040000
#define IOC_IOCFG6_EDGE_IRQ_EN_S                                            18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG6_EDGE_DET_W                                                2
#define IOC_IOCFG6_EDGE_DET_M                                       0x00030000
#define IOC_IOCFG6_EDGE_DET_S                                               16
#define IOC_IOCFG6_EDGE_DET_BOTH                                    0x00030000
#define IOC_IOCFG6_EDGE_DET_POS                                     0x00020000
#define IOC_IOCFG6_EDGE_DET_NEG                                     0x00010000
#define IOC_IOCFG6_EDGE_DET_NONE                                    0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG6_PULL_CTL_W                                                2
#define IOC_IOCFG6_PULL_CTL_M                                       0x00006000
#define IOC_IOCFG6_PULL_CTL_S                                               13
#define IOC_IOCFG6_PULL_CTL_DIS                                     0x00006000
#define IOC_IOCFG6_PULL_CTL_UP                                      0x00004000
#define IOC_IOCFG6_PULL_CTL_DWN                                     0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG6_SLEW_RED                                         0x00001000
#define IOC_IOCFG6_SLEW_RED_BITN                                            12
#define IOC_IOCFG6_SLEW_RED_M                                       0x00001000
#define IOC_IOCFG6_SLEW_RED_S                                               12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG6_IOCURR_W                                                  2
#define IOC_IOCFG6_IOCURR_M                                         0x00000C00
#define IOC_IOCFG6_IOCURR_S                                                 10
#define IOC_IOCFG6_IOCURR_4_8MA                                     0x00000800
#define IOC_IOCFG6_IOCURR_4MA                                       0x00000400
#define IOC_IOCFG6_IOCURR_2MA                                       0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG6_IOSTR_W                                                   2
#define IOC_IOCFG6_IOSTR_M                                          0x00000300
#define IOC_IOCFG6_IOSTR_S                                                   8
#define IOC_IOCFG6_IOSTR_MAX                                        0x00000300
#define IOC_IOCFG6_IOSTR_MED                                        0x00000200
#define IOC_IOCFG6_IOSTR_MIN                                        0x00000100
#define IOC_IOCFG6_IOSTR_AUTO                                       0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG6_IOEV_RTC_EN                                      0x00000080
#define IOC_IOCFG6_IOEV_RTC_EN_BITN                                          7
#define IOC_IOCFG6_IOEV_RTC_EN_M                                    0x00000080
#define IOC_IOCFG6_IOEV_RTC_EN_S                                             7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG6_IOEV_MCU_WU_EN                                   0x00000040
#define IOC_IOCFG6_IOEV_MCU_WU_EN_BITN                                       6
#define IOC_IOCFG6_IOEV_MCU_WU_EN_M                                 0x00000040
#define IOC_IOCFG6_IOEV_MCU_WU_EN_S                                          6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO6
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG6_PORT_ID_W                                                 6
#define IOC_IOCFG6_PORT_ID_M                                        0x0000003F
#define IOC_IOCFG6_PORT_ID_S                                                 0
#define IOC_IOCFG6_PORT_ID_RFC_SMI_CL_IN                            0x00000038
#define IOC_IOCFG6_PORT_ID_RFC_SMI_CL_OUT                           0x00000037
#define IOC_IOCFG6_PORT_ID_RFC_SMI_DL_IN                            0x00000036
#define IOC_IOCFG6_PORT_ID_RFC_SMI_DL_OUT                           0x00000035
#define IOC_IOCFG6_PORT_ID_RFC_GPI1                                 0x00000034
#define IOC_IOCFG6_PORT_ID_RFC_GPI0                                 0x00000033
#define IOC_IOCFG6_PORT_ID_RFC_GPO3                                 0x00000032
#define IOC_IOCFG6_PORT_ID_RFC_GPO2                                 0x00000031
#define IOC_IOCFG6_PORT_ID_RFC_GPO1                                 0x00000030
#define IOC_IOCFG6_PORT_ID_RFC_GPO0                                 0x0000002F
#define IOC_IOCFG6_PORT_ID_RFC_TRC                                  0x0000002E
#define IOC_IOCFG6_PORT_ID_I2S_MCLK                                 0x00000029
#define IOC_IOCFG6_PORT_ID_I2S_BCLK                                 0x00000028
#define IOC_IOCFG6_PORT_ID_I2S_WCLK                                 0x00000027
#define IOC_IOCFG6_PORT_ID_I2S_AD1                                  0x00000026
#define IOC_IOCFG6_PORT_ID_I2S_AD0                                  0x00000025
#define IOC_IOCFG6_PORT_ID_SSI1_CLK                                 0x00000024
#define IOC_IOCFG6_PORT_ID_SSI1_FSS                                 0x00000023
#define IOC_IOCFG6_PORT_ID_SSI1_TX                                  0x00000022
#define IOC_IOCFG6_PORT_ID_SSI1_RX                                  0x00000021
#define IOC_IOCFG6_PORT_ID_CPU_SWV                                  0x00000020
#define IOC_IOCFG6_PORT_ID_PORT_EVENT7                              0x0000001E
#define IOC_IOCFG6_PORT_ID_PORT_EVENT6                              0x0000001D
#define IOC_IOCFG6_PORT_ID_PORT_EVENT5                              0x0000001C
#define IOC_IOCFG6_PORT_ID_PORT_EVENT4                              0x0000001B
#define IOC_IOCFG6_PORT_ID_PORT_EVENT3                              0x0000001A
#define IOC_IOCFG6_PORT_ID_PORT_EVENT2                              0x00000019
#define IOC_IOCFG6_PORT_ID_PORT_EVENT1                              0x00000018
#define IOC_IOCFG6_PORT_ID_PORT_EVENT0                              0x00000017
#define IOC_IOCFG6_PORT_ID_UART1_RTS                                0x00000016
#define IOC_IOCFG6_PORT_ID_UART1_CTS                                0x00000015
#define IOC_IOCFG6_PORT_ID_UART1_TX                                 0x00000014
#define IOC_IOCFG6_PORT_ID_UART1_RX                                 0x00000013
#define IOC_IOCFG6_PORT_ID_UART0_RTS                                0x00000012
#define IOC_IOCFG6_PORT_ID_UART0_CTS                                0x00000011
#define IOC_IOCFG6_PORT_ID_UART0_TX                                 0x00000010
#define IOC_IOCFG6_PORT_ID_UART0_RX                                 0x0000000F
#define IOC_IOCFG6_PORT_ID_I2C_MSSCL                                0x0000000E
#define IOC_IOCFG6_PORT_ID_I2C_MSSDA                                0x0000000D
#define IOC_IOCFG6_PORT_ID_SSI0_CLK                                 0x0000000C
#define IOC_IOCFG6_PORT_ID_SSI0_FSS                                 0x0000000B
#define IOC_IOCFG6_PORT_ID_SSI0_TX                                  0x0000000A
#define IOC_IOCFG6_PORT_ID_SSI0_RX                                  0x00000009
#define IOC_IOCFG6_PORT_ID_AUX_IO                                   0x00000008
#define IOC_IOCFG6_PORT_ID_AON_CLK32K                               0x00000007
#define IOC_IOCFG6_PORT_ID_GPIO                                     0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG7
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG7_HYST_EN                                          0x40000000
#define IOC_IOCFG7_HYST_EN_BITN                                             30
#define IOC_IOCFG7_HYST_EN_M                                        0x40000000
#define IOC_IOCFG7_HYST_EN_S                                                30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG7_IE                                               0x20000000
#define IOC_IOCFG7_IE_BITN                                                  29
#define IOC_IOCFG7_IE_M                                             0x20000000
#define IOC_IOCFG7_IE_S                                                     29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG7_WU_CFG_W                                                  2
#define IOC_IOCFG7_WU_CFG_M                                         0x18000000
#define IOC_IOCFG7_WU_CFG_S                                                 27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG7_IOMODE_W                                                  3
#define IOC_IOCFG7_IOMODE_M                                         0x07000000
#define IOC_IOCFG7_IOMODE_S                                                 24
#define IOC_IOCFG7_IOMODE_OPENSRC_INV                               0x07000000
#define IOC_IOCFG7_IOMODE_OPENSRC                                   0x06000000
#define IOC_IOCFG7_IOMODE_OPENDR_INV                                0x05000000
#define IOC_IOCFG7_IOMODE_OPENDR                                    0x04000000
#define IOC_IOCFG7_IOMODE_INV                                       0x01000000
#define IOC_IOCFG7_IOMODE_NORMAL                                    0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG7_IOEV_AON_PROG2_EN                                0x00800000
#define IOC_IOCFG7_IOEV_AON_PROG2_EN_BITN                                   23
#define IOC_IOCFG7_IOEV_AON_PROG2_EN_M                              0x00800000
#define IOC_IOCFG7_IOEV_AON_PROG2_EN_S                                      23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG7_IOEV_AON_PROG1_EN                                0x00400000
#define IOC_IOCFG7_IOEV_AON_PROG1_EN_BITN                                   22
#define IOC_IOCFG7_IOEV_AON_PROG1_EN_M                              0x00400000
#define IOC_IOCFG7_IOEV_AON_PROG1_EN_S                                      22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG7_IOEV_AON_PROG0_EN                                0x00200000
#define IOC_IOCFG7_IOEV_AON_PROG0_EN_BITN                                   21
#define IOC_IOCFG7_IOEV_AON_PROG0_EN_M                              0x00200000
#define IOC_IOCFG7_IOEV_AON_PROG0_EN_S                                      21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG7_EDGE_IRQ_EN                                      0x00040000
#define IOC_IOCFG7_EDGE_IRQ_EN_BITN                                         18
#define IOC_IOCFG7_EDGE_IRQ_EN_M                                    0x00040000
#define IOC_IOCFG7_EDGE_IRQ_EN_S                                            18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG7_EDGE_DET_W                                                2
#define IOC_IOCFG7_EDGE_DET_M                                       0x00030000
#define IOC_IOCFG7_EDGE_DET_S                                               16
#define IOC_IOCFG7_EDGE_DET_BOTH                                    0x00030000
#define IOC_IOCFG7_EDGE_DET_POS                                     0x00020000
#define IOC_IOCFG7_EDGE_DET_NEG                                     0x00010000
#define IOC_IOCFG7_EDGE_DET_NONE                                    0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG7_PULL_CTL_W                                                2
#define IOC_IOCFG7_PULL_CTL_M                                       0x00006000
#define IOC_IOCFG7_PULL_CTL_S                                               13
#define IOC_IOCFG7_PULL_CTL_DIS                                     0x00006000
#define IOC_IOCFG7_PULL_CTL_UP                                      0x00004000
#define IOC_IOCFG7_PULL_CTL_DWN                                     0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG7_SLEW_RED                                         0x00001000
#define IOC_IOCFG7_SLEW_RED_BITN                                            12
#define IOC_IOCFG7_SLEW_RED_M                                       0x00001000
#define IOC_IOCFG7_SLEW_RED_S                                               12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG7_IOCURR_W                                                  2
#define IOC_IOCFG7_IOCURR_M                                         0x00000C00
#define IOC_IOCFG7_IOCURR_S                                                 10
#define IOC_IOCFG7_IOCURR_4_8MA                                     0x00000800
#define IOC_IOCFG7_IOCURR_4MA                                       0x00000400
#define IOC_IOCFG7_IOCURR_2MA                                       0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG7_IOSTR_W                                                   2
#define IOC_IOCFG7_IOSTR_M                                          0x00000300
#define IOC_IOCFG7_IOSTR_S                                                   8
#define IOC_IOCFG7_IOSTR_MAX                                        0x00000300
#define IOC_IOCFG7_IOSTR_MED                                        0x00000200
#define IOC_IOCFG7_IOSTR_MIN                                        0x00000100
#define IOC_IOCFG7_IOSTR_AUTO                                       0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG7_IOEV_RTC_EN                                      0x00000080
#define IOC_IOCFG7_IOEV_RTC_EN_BITN                                          7
#define IOC_IOCFG7_IOEV_RTC_EN_M                                    0x00000080
#define IOC_IOCFG7_IOEV_RTC_EN_S                                             7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG7_IOEV_MCU_WU_EN                                   0x00000040
#define IOC_IOCFG7_IOEV_MCU_WU_EN_BITN                                       6
#define IOC_IOCFG7_IOEV_MCU_WU_EN_M                                 0x00000040
#define IOC_IOCFG7_IOEV_MCU_WU_EN_S                                          6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO7
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG7_PORT_ID_W                                                 6
#define IOC_IOCFG7_PORT_ID_M                                        0x0000003F
#define IOC_IOCFG7_PORT_ID_S                                                 0
#define IOC_IOCFG7_PORT_ID_RFC_SMI_CL_IN                            0x00000038
#define IOC_IOCFG7_PORT_ID_RFC_SMI_CL_OUT                           0x00000037
#define IOC_IOCFG7_PORT_ID_RFC_SMI_DL_IN                            0x00000036
#define IOC_IOCFG7_PORT_ID_RFC_SMI_DL_OUT                           0x00000035
#define IOC_IOCFG7_PORT_ID_RFC_GPI1                                 0x00000034
#define IOC_IOCFG7_PORT_ID_RFC_GPI0                                 0x00000033
#define IOC_IOCFG7_PORT_ID_RFC_GPO3                                 0x00000032
#define IOC_IOCFG7_PORT_ID_RFC_GPO2                                 0x00000031
#define IOC_IOCFG7_PORT_ID_RFC_GPO1                                 0x00000030
#define IOC_IOCFG7_PORT_ID_RFC_GPO0                                 0x0000002F
#define IOC_IOCFG7_PORT_ID_RFC_TRC                                  0x0000002E
#define IOC_IOCFG7_PORT_ID_I2S_MCLK                                 0x00000029
#define IOC_IOCFG7_PORT_ID_I2S_BCLK                                 0x00000028
#define IOC_IOCFG7_PORT_ID_I2S_WCLK                                 0x00000027
#define IOC_IOCFG7_PORT_ID_I2S_AD1                                  0x00000026
#define IOC_IOCFG7_PORT_ID_I2S_AD0                                  0x00000025
#define IOC_IOCFG7_PORT_ID_SSI1_CLK                                 0x00000024
#define IOC_IOCFG7_PORT_ID_SSI1_FSS                                 0x00000023
#define IOC_IOCFG7_PORT_ID_SSI1_TX                                  0x00000022
#define IOC_IOCFG7_PORT_ID_SSI1_RX                                  0x00000021
#define IOC_IOCFG7_PORT_ID_CPU_SWV                                  0x00000020
#define IOC_IOCFG7_PORT_ID_PORT_EVENT7                              0x0000001E
#define IOC_IOCFG7_PORT_ID_PORT_EVENT6                              0x0000001D
#define IOC_IOCFG7_PORT_ID_PORT_EVENT5                              0x0000001C
#define IOC_IOCFG7_PORT_ID_PORT_EVENT4                              0x0000001B
#define IOC_IOCFG7_PORT_ID_PORT_EVENT3                              0x0000001A
#define IOC_IOCFG7_PORT_ID_PORT_EVENT2                              0x00000019
#define IOC_IOCFG7_PORT_ID_PORT_EVENT1                              0x00000018
#define IOC_IOCFG7_PORT_ID_PORT_EVENT0                              0x00000017
#define IOC_IOCFG7_PORT_ID_UART1_RTS                                0x00000016
#define IOC_IOCFG7_PORT_ID_UART1_CTS                                0x00000015
#define IOC_IOCFG7_PORT_ID_UART1_TX                                 0x00000014
#define IOC_IOCFG7_PORT_ID_UART1_RX                                 0x00000013
#define IOC_IOCFG7_PORT_ID_UART0_RTS                                0x00000012
#define IOC_IOCFG7_PORT_ID_UART0_CTS                                0x00000011
#define IOC_IOCFG7_PORT_ID_UART0_TX                                 0x00000010
#define IOC_IOCFG7_PORT_ID_UART0_RX                                 0x0000000F
#define IOC_IOCFG7_PORT_ID_I2C_MSSCL                                0x0000000E
#define IOC_IOCFG7_PORT_ID_I2C_MSSDA                                0x0000000D
#define IOC_IOCFG7_PORT_ID_SSI0_CLK                                 0x0000000C
#define IOC_IOCFG7_PORT_ID_SSI0_FSS                                 0x0000000B
#define IOC_IOCFG7_PORT_ID_SSI0_TX                                  0x0000000A
#define IOC_IOCFG7_PORT_ID_SSI0_RX                                  0x00000009
#define IOC_IOCFG7_PORT_ID_AUX_IO                                   0x00000008
#define IOC_IOCFG7_PORT_ID_AON_CLK32K                               0x00000007
#define IOC_IOCFG7_PORT_ID_GPIO                                     0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG8
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG8_HYST_EN                                          0x40000000
#define IOC_IOCFG8_HYST_EN_BITN                                             30
#define IOC_IOCFG8_HYST_EN_M                                        0x40000000
#define IOC_IOCFG8_HYST_EN_S                                                30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG8_IE                                               0x20000000
#define IOC_IOCFG8_IE_BITN                                                  29
#define IOC_IOCFG8_IE_M                                             0x20000000
#define IOC_IOCFG8_IE_S                                                     29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG8_WU_CFG_W                                                  2
#define IOC_IOCFG8_WU_CFG_M                                         0x18000000
#define IOC_IOCFG8_WU_CFG_S                                                 27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG8_IOMODE_W                                                  3
#define IOC_IOCFG8_IOMODE_M                                         0x07000000
#define IOC_IOCFG8_IOMODE_S                                                 24
#define IOC_IOCFG8_IOMODE_OPENSRC_INV                               0x07000000
#define IOC_IOCFG8_IOMODE_OPENSRC                                   0x06000000
#define IOC_IOCFG8_IOMODE_OPENDR_INV                                0x05000000
#define IOC_IOCFG8_IOMODE_OPENDR                                    0x04000000
#define IOC_IOCFG8_IOMODE_INV                                       0x01000000
#define IOC_IOCFG8_IOMODE_NORMAL                                    0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG8_IOEV_AON_PROG2_EN                                0x00800000
#define IOC_IOCFG8_IOEV_AON_PROG2_EN_BITN                                   23
#define IOC_IOCFG8_IOEV_AON_PROG2_EN_M                              0x00800000
#define IOC_IOCFG8_IOEV_AON_PROG2_EN_S                                      23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG8_IOEV_AON_PROG1_EN                                0x00400000
#define IOC_IOCFG8_IOEV_AON_PROG1_EN_BITN                                   22
#define IOC_IOCFG8_IOEV_AON_PROG1_EN_M                              0x00400000
#define IOC_IOCFG8_IOEV_AON_PROG1_EN_S                                      22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG8_IOEV_AON_PROG0_EN                                0x00200000
#define IOC_IOCFG8_IOEV_AON_PROG0_EN_BITN                                   21
#define IOC_IOCFG8_IOEV_AON_PROG0_EN_M                              0x00200000
#define IOC_IOCFG8_IOEV_AON_PROG0_EN_S                                      21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG8_EDGE_IRQ_EN                                      0x00040000
#define IOC_IOCFG8_EDGE_IRQ_EN_BITN                                         18
#define IOC_IOCFG8_EDGE_IRQ_EN_M                                    0x00040000
#define IOC_IOCFG8_EDGE_IRQ_EN_S                                            18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG8_EDGE_DET_W                                                2
#define IOC_IOCFG8_EDGE_DET_M                                       0x00030000
#define IOC_IOCFG8_EDGE_DET_S                                               16
#define IOC_IOCFG8_EDGE_DET_BOTH                                    0x00030000
#define IOC_IOCFG8_EDGE_DET_POS                                     0x00020000
#define IOC_IOCFG8_EDGE_DET_NEG                                     0x00010000
#define IOC_IOCFG8_EDGE_DET_NONE                                    0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG8_PULL_CTL_W                                                2
#define IOC_IOCFG8_PULL_CTL_M                                       0x00006000
#define IOC_IOCFG8_PULL_CTL_S                                               13
#define IOC_IOCFG8_PULL_CTL_DIS                                     0x00006000
#define IOC_IOCFG8_PULL_CTL_UP                                      0x00004000
#define IOC_IOCFG8_PULL_CTL_DWN                                     0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG8_SLEW_RED                                         0x00001000
#define IOC_IOCFG8_SLEW_RED_BITN                                            12
#define IOC_IOCFG8_SLEW_RED_M                                       0x00001000
#define IOC_IOCFG8_SLEW_RED_S                                               12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG8_IOCURR_W                                                  2
#define IOC_IOCFG8_IOCURR_M                                         0x00000C00
#define IOC_IOCFG8_IOCURR_S                                                 10
#define IOC_IOCFG8_IOCURR_4_8MA                                     0x00000800
#define IOC_IOCFG8_IOCURR_4MA                                       0x00000400
#define IOC_IOCFG8_IOCURR_2MA                                       0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG8_IOSTR_W                                                   2
#define IOC_IOCFG8_IOSTR_M                                          0x00000300
#define IOC_IOCFG8_IOSTR_S                                                   8
#define IOC_IOCFG8_IOSTR_MAX                                        0x00000300
#define IOC_IOCFG8_IOSTR_MED                                        0x00000200
#define IOC_IOCFG8_IOSTR_MIN                                        0x00000100
#define IOC_IOCFG8_IOSTR_AUTO                                       0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG8_IOEV_RTC_EN                                      0x00000080
#define IOC_IOCFG8_IOEV_RTC_EN_BITN                                          7
#define IOC_IOCFG8_IOEV_RTC_EN_M                                    0x00000080
#define IOC_IOCFG8_IOEV_RTC_EN_S                                             7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG8_IOEV_MCU_WU_EN                                   0x00000040
#define IOC_IOCFG8_IOEV_MCU_WU_EN_BITN                                       6
#define IOC_IOCFG8_IOEV_MCU_WU_EN_M                                 0x00000040
#define IOC_IOCFG8_IOEV_MCU_WU_EN_S                                          6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO8
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG8_PORT_ID_W                                                 6
#define IOC_IOCFG8_PORT_ID_M                                        0x0000003F
#define IOC_IOCFG8_PORT_ID_S                                                 0
#define IOC_IOCFG8_PORT_ID_RFC_SMI_CL_IN                            0x00000038
#define IOC_IOCFG8_PORT_ID_RFC_SMI_CL_OUT                           0x00000037
#define IOC_IOCFG8_PORT_ID_RFC_SMI_DL_IN                            0x00000036
#define IOC_IOCFG8_PORT_ID_RFC_SMI_DL_OUT                           0x00000035
#define IOC_IOCFG8_PORT_ID_RFC_GPI1                                 0x00000034
#define IOC_IOCFG8_PORT_ID_RFC_GPI0                                 0x00000033
#define IOC_IOCFG8_PORT_ID_RFC_GPO3                                 0x00000032
#define IOC_IOCFG8_PORT_ID_RFC_GPO2                                 0x00000031
#define IOC_IOCFG8_PORT_ID_RFC_GPO1                                 0x00000030
#define IOC_IOCFG8_PORT_ID_RFC_GPO0                                 0x0000002F
#define IOC_IOCFG8_PORT_ID_RFC_TRC                                  0x0000002E
#define IOC_IOCFG8_PORT_ID_I2S_MCLK                                 0x00000029
#define IOC_IOCFG8_PORT_ID_I2S_BCLK                                 0x00000028
#define IOC_IOCFG8_PORT_ID_I2S_WCLK                                 0x00000027
#define IOC_IOCFG8_PORT_ID_I2S_AD1                                  0x00000026
#define IOC_IOCFG8_PORT_ID_I2S_AD0                                  0x00000025
#define IOC_IOCFG8_PORT_ID_SSI1_CLK                                 0x00000024
#define IOC_IOCFG8_PORT_ID_SSI1_FSS                                 0x00000023
#define IOC_IOCFG8_PORT_ID_SSI1_TX                                  0x00000022
#define IOC_IOCFG8_PORT_ID_SSI1_RX                                  0x00000021
#define IOC_IOCFG8_PORT_ID_CPU_SWV                                  0x00000020
#define IOC_IOCFG8_PORT_ID_PORT_EVENT7                              0x0000001E
#define IOC_IOCFG8_PORT_ID_PORT_EVENT6                              0x0000001D
#define IOC_IOCFG8_PORT_ID_PORT_EVENT5                              0x0000001C
#define IOC_IOCFG8_PORT_ID_PORT_EVENT4                              0x0000001B
#define IOC_IOCFG8_PORT_ID_PORT_EVENT3                              0x0000001A
#define IOC_IOCFG8_PORT_ID_PORT_EVENT2                              0x00000019
#define IOC_IOCFG8_PORT_ID_PORT_EVENT1                              0x00000018
#define IOC_IOCFG8_PORT_ID_PORT_EVENT0                              0x00000017
#define IOC_IOCFG8_PORT_ID_UART1_RTS                                0x00000016
#define IOC_IOCFG8_PORT_ID_UART1_CTS                                0x00000015
#define IOC_IOCFG8_PORT_ID_UART1_TX                                 0x00000014
#define IOC_IOCFG8_PORT_ID_UART1_RX                                 0x00000013
#define IOC_IOCFG8_PORT_ID_UART0_RTS                                0x00000012
#define IOC_IOCFG8_PORT_ID_UART0_CTS                                0x00000011
#define IOC_IOCFG8_PORT_ID_UART0_TX                                 0x00000010
#define IOC_IOCFG8_PORT_ID_UART0_RX                                 0x0000000F
#define IOC_IOCFG8_PORT_ID_I2C_MSSCL                                0x0000000E
#define IOC_IOCFG8_PORT_ID_I2C_MSSDA                                0x0000000D
#define IOC_IOCFG8_PORT_ID_SSI0_CLK                                 0x0000000C
#define IOC_IOCFG8_PORT_ID_SSI0_FSS                                 0x0000000B
#define IOC_IOCFG8_PORT_ID_SSI0_TX                                  0x0000000A
#define IOC_IOCFG8_PORT_ID_SSI0_RX                                  0x00000009
#define IOC_IOCFG8_PORT_ID_AUX_IO                                   0x00000008
#define IOC_IOCFG8_PORT_ID_AON_CLK32K                               0x00000007
#define IOC_IOCFG8_PORT_ID_GPIO                                     0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG9
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG9_HYST_EN                                          0x40000000
#define IOC_IOCFG9_HYST_EN_BITN                                             30
#define IOC_IOCFG9_HYST_EN_M                                        0x40000000
#define IOC_IOCFG9_HYST_EN_S                                                30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG9_IE                                               0x20000000
#define IOC_IOCFG9_IE_BITN                                                  29
#define IOC_IOCFG9_IE_M                                             0x20000000
#define IOC_IOCFG9_IE_S                                                     29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG9_WU_CFG_W                                                  2
#define IOC_IOCFG9_WU_CFG_M                                         0x18000000
#define IOC_IOCFG9_WU_CFG_S                                                 27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG9_IOMODE_W                                                  3
#define IOC_IOCFG9_IOMODE_M                                         0x07000000
#define IOC_IOCFG9_IOMODE_S                                                 24
#define IOC_IOCFG9_IOMODE_OPENSRC_INV                               0x07000000
#define IOC_IOCFG9_IOMODE_OPENSRC                                   0x06000000
#define IOC_IOCFG9_IOMODE_OPENDR_INV                                0x05000000
#define IOC_IOCFG9_IOMODE_OPENDR                                    0x04000000
#define IOC_IOCFG9_IOMODE_INV                                       0x01000000
#define IOC_IOCFG9_IOMODE_NORMAL                                    0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG9_IOEV_AON_PROG2_EN                                0x00800000
#define IOC_IOCFG9_IOEV_AON_PROG2_EN_BITN                                   23
#define IOC_IOCFG9_IOEV_AON_PROG2_EN_M                              0x00800000
#define IOC_IOCFG9_IOEV_AON_PROG2_EN_S                                      23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG9_IOEV_AON_PROG1_EN                                0x00400000
#define IOC_IOCFG9_IOEV_AON_PROG1_EN_BITN                                   22
#define IOC_IOCFG9_IOEV_AON_PROG1_EN_M                              0x00400000
#define IOC_IOCFG9_IOEV_AON_PROG1_EN_S                                      22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG9_IOEV_AON_PROG0_EN                                0x00200000
#define IOC_IOCFG9_IOEV_AON_PROG0_EN_BITN                                   21
#define IOC_IOCFG9_IOEV_AON_PROG0_EN_M                              0x00200000
#define IOC_IOCFG9_IOEV_AON_PROG0_EN_S                                      21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG9_EDGE_IRQ_EN                                      0x00040000
#define IOC_IOCFG9_EDGE_IRQ_EN_BITN                                         18
#define IOC_IOCFG9_EDGE_IRQ_EN_M                                    0x00040000
#define IOC_IOCFG9_EDGE_IRQ_EN_S                                            18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG9_EDGE_DET_W                                                2
#define IOC_IOCFG9_EDGE_DET_M                                       0x00030000
#define IOC_IOCFG9_EDGE_DET_S                                               16
#define IOC_IOCFG9_EDGE_DET_BOTH                                    0x00030000
#define IOC_IOCFG9_EDGE_DET_POS                                     0x00020000
#define IOC_IOCFG9_EDGE_DET_NEG                                     0x00010000
#define IOC_IOCFG9_EDGE_DET_NONE                                    0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG9_PULL_CTL_W                                                2
#define IOC_IOCFG9_PULL_CTL_M                                       0x00006000
#define IOC_IOCFG9_PULL_CTL_S                                               13
#define IOC_IOCFG9_PULL_CTL_DIS                                     0x00006000
#define IOC_IOCFG9_PULL_CTL_UP                                      0x00004000
#define IOC_IOCFG9_PULL_CTL_DWN                                     0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG9_SLEW_RED                                         0x00001000
#define IOC_IOCFG9_SLEW_RED_BITN                                            12
#define IOC_IOCFG9_SLEW_RED_M                                       0x00001000
#define IOC_IOCFG9_SLEW_RED_S                                               12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG9_IOCURR_W                                                  2
#define IOC_IOCFG9_IOCURR_M                                         0x00000C00
#define IOC_IOCFG9_IOCURR_S                                                 10
#define IOC_IOCFG9_IOCURR_4_8MA                                     0x00000800
#define IOC_IOCFG9_IOCURR_4MA                                       0x00000400
#define IOC_IOCFG9_IOCURR_2MA                                       0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG9_IOSTR_W                                                   2
#define IOC_IOCFG9_IOSTR_M                                          0x00000300
#define IOC_IOCFG9_IOSTR_S                                                   8
#define IOC_IOCFG9_IOSTR_MAX                                        0x00000300
#define IOC_IOCFG9_IOSTR_MED                                        0x00000200
#define IOC_IOCFG9_IOSTR_MIN                                        0x00000100
#define IOC_IOCFG9_IOSTR_AUTO                                       0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG9_IOEV_RTC_EN                                      0x00000080
#define IOC_IOCFG9_IOEV_RTC_EN_BITN                                          7
#define IOC_IOCFG9_IOEV_RTC_EN_M                                    0x00000080
#define IOC_IOCFG9_IOEV_RTC_EN_S                                             7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG9_IOEV_MCU_WU_EN                                   0x00000040
#define IOC_IOCFG9_IOEV_MCU_WU_EN_BITN                                       6
#define IOC_IOCFG9_IOEV_MCU_WU_EN_M                                 0x00000040
#define IOC_IOCFG9_IOEV_MCU_WU_EN_S                                          6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO9
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG9_PORT_ID_W                                                 6
#define IOC_IOCFG9_PORT_ID_M                                        0x0000003F
#define IOC_IOCFG9_PORT_ID_S                                                 0
#define IOC_IOCFG9_PORT_ID_RFC_SMI_CL_IN                            0x00000038
#define IOC_IOCFG9_PORT_ID_RFC_SMI_CL_OUT                           0x00000037
#define IOC_IOCFG9_PORT_ID_RFC_SMI_DL_IN                            0x00000036
#define IOC_IOCFG9_PORT_ID_RFC_SMI_DL_OUT                           0x00000035
#define IOC_IOCFG9_PORT_ID_RFC_GPI1                                 0x00000034
#define IOC_IOCFG9_PORT_ID_RFC_GPI0                                 0x00000033
#define IOC_IOCFG9_PORT_ID_RFC_GPO3                                 0x00000032
#define IOC_IOCFG9_PORT_ID_RFC_GPO2                                 0x00000031
#define IOC_IOCFG9_PORT_ID_RFC_GPO1                                 0x00000030
#define IOC_IOCFG9_PORT_ID_RFC_GPO0                                 0x0000002F
#define IOC_IOCFG9_PORT_ID_RFC_TRC                                  0x0000002E
#define IOC_IOCFG9_PORT_ID_I2S_MCLK                                 0x00000029
#define IOC_IOCFG9_PORT_ID_I2S_BCLK                                 0x00000028
#define IOC_IOCFG9_PORT_ID_I2S_WCLK                                 0x00000027
#define IOC_IOCFG9_PORT_ID_I2S_AD1                                  0x00000026
#define IOC_IOCFG9_PORT_ID_I2S_AD0                                  0x00000025
#define IOC_IOCFG9_PORT_ID_SSI1_CLK                                 0x00000024
#define IOC_IOCFG9_PORT_ID_SSI1_FSS                                 0x00000023
#define IOC_IOCFG9_PORT_ID_SSI1_TX                                  0x00000022
#define IOC_IOCFG9_PORT_ID_SSI1_RX                                  0x00000021
#define IOC_IOCFG9_PORT_ID_CPU_SWV                                  0x00000020
#define IOC_IOCFG9_PORT_ID_PORT_EVENT7                              0x0000001E
#define IOC_IOCFG9_PORT_ID_PORT_EVENT6                              0x0000001D
#define IOC_IOCFG9_PORT_ID_PORT_EVENT5                              0x0000001C
#define IOC_IOCFG9_PORT_ID_PORT_EVENT4                              0x0000001B
#define IOC_IOCFG9_PORT_ID_PORT_EVENT3                              0x0000001A
#define IOC_IOCFG9_PORT_ID_PORT_EVENT2                              0x00000019
#define IOC_IOCFG9_PORT_ID_PORT_EVENT1                              0x00000018
#define IOC_IOCFG9_PORT_ID_PORT_EVENT0                              0x00000017
#define IOC_IOCFG9_PORT_ID_UART1_RTS                                0x00000016
#define IOC_IOCFG9_PORT_ID_UART1_CTS                                0x00000015
#define IOC_IOCFG9_PORT_ID_UART1_TX                                 0x00000014
#define IOC_IOCFG9_PORT_ID_UART1_RX                                 0x00000013
#define IOC_IOCFG9_PORT_ID_UART0_RTS                                0x00000012
#define IOC_IOCFG9_PORT_ID_UART0_CTS                                0x00000011
#define IOC_IOCFG9_PORT_ID_UART0_TX                                 0x00000010
#define IOC_IOCFG9_PORT_ID_UART0_RX                                 0x0000000F
#define IOC_IOCFG9_PORT_ID_I2C_MSSCL                                0x0000000E
#define IOC_IOCFG9_PORT_ID_I2C_MSSDA                                0x0000000D
#define IOC_IOCFG9_PORT_ID_SSI0_CLK                                 0x0000000C
#define IOC_IOCFG9_PORT_ID_SSI0_FSS                                 0x0000000B
#define IOC_IOCFG9_PORT_ID_SSI0_TX                                  0x0000000A
#define IOC_IOCFG9_PORT_ID_SSI0_RX                                  0x00000009
#define IOC_IOCFG9_PORT_ID_AUX_IO                                   0x00000008
#define IOC_IOCFG9_PORT_ID_AON_CLK32K                               0x00000007
#define IOC_IOCFG9_PORT_ID_GPIO                                     0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG10
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG10_HYST_EN                                         0x40000000
#define IOC_IOCFG10_HYST_EN_BITN                                            30
#define IOC_IOCFG10_HYST_EN_M                                       0x40000000
#define IOC_IOCFG10_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG10_IE                                              0x20000000
#define IOC_IOCFG10_IE_BITN                                                 29
#define IOC_IOCFG10_IE_M                                            0x20000000
#define IOC_IOCFG10_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG10_WU_CFG_W                                                 2
#define IOC_IOCFG10_WU_CFG_M                                        0x18000000
#define IOC_IOCFG10_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG10_IOMODE_W                                                 3
#define IOC_IOCFG10_IOMODE_M                                        0x07000000
#define IOC_IOCFG10_IOMODE_S                                                24
#define IOC_IOCFG10_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG10_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG10_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG10_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG10_IOMODE_INV                                      0x01000000
#define IOC_IOCFG10_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG10_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG10_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG10_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG10_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG10_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG10_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG10_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG10_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG10_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG10_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG10_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG10_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG10_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG10_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG10_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG10_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG10_EDGE_DET_W                                               2
#define IOC_IOCFG10_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG10_EDGE_DET_S                                              16
#define IOC_IOCFG10_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG10_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG10_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG10_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG10_PULL_CTL_W                                               2
#define IOC_IOCFG10_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG10_PULL_CTL_S                                              13
#define IOC_IOCFG10_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG10_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG10_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG10_SLEW_RED                                        0x00001000
#define IOC_IOCFG10_SLEW_RED_BITN                                           12
#define IOC_IOCFG10_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG10_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG10_IOCURR_W                                                 2
#define IOC_IOCFG10_IOCURR_M                                        0x00000C00
#define IOC_IOCFG10_IOCURR_S                                                10
#define IOC_IOCFG10_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG10_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG10_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG10_IOSTR_W                                                  2
#define IOC_IOCFG10_IOSTR_M                                         0x00000300
#define IOC_IOCFG10_IOSTR_S                                                  8
#define IOC_IOCFG10_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG10_IOSTR_MED                                       0x00000200
#define IOC_IOCFG10_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG10_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG10_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG10_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG10_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG10_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG10_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG10_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG10_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG10_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO10
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG10_PORT_ID_W                                                6
#define IOC_IOCFG10_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG10_PORT_ID_S                                                0
#define IOC_IOCFG10_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG10_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG10_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG10_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG10_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG10_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG10_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG10_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG10_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG10_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG10_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG10_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG10_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG10_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG10_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG10_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG10_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG10_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG10_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG10_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG10_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG10_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG10_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG10_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG10_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG10_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG10_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG10_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG10_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG10_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG10_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG10_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG10_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG10_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG10_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG10_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG10_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG10_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG10_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG10_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG10_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG10_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG10_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG10_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG10_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG10_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG11
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG11_HYST_EN                                         0x40000000
#define IOC_IOCFG11_HYST_EN_BITN                                            30
#define IOC_IOCFG11_HYST_EN_M                                       0x40000000
#define IOC_IOCFG11_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG11_IE                                              0x20000000
#define IOC_IOCFG11_IE_BITN                                                 29
#define IOC_IOCFG11_IE_M                                            0x20000000
#define IOC_IOCFG11_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG11_WU_CFG_W                                                 2
#define IOC_IOCFG11_WU_CFG_M                                        0x18000000
#define IOC_IOCFG11_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG11_IOMODE_W                                                 3
#define IOC_IOCFG11_IOMODE_M                                        0x07000000
#define IOC_IOCFG11_IOMODE_S                                                24
#define IOC_IOCFG11_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG11_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG11_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG11_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG11_IOMODE_INV                                      0x01000000
#define IOC_IOCFG11_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG11_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG11_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG11_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG11_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG11_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG11_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG11_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG11_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG11_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG11_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG11_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG11_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG11_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG11_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG11_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG11_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG11_EDGE_DET_W                                               2
#define IOC_IOCFG11_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG11_EDGE_DET_S                                              16
#define IOC_IOCFG11_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG11_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG11_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG11_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG11_PULL_CTL_W                                               2
#define IOC_IOCFG11_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG11_PULL_CTL_S                                              13
#define IOC_IOCFG11_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG11_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG11_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG11_SLEW_RED                                        0x00001000
#define IOC_IOCFG11_SLEW_RED_BITN                                           12
#define IOC_IOCFG11_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG11_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG11_IOCURR_W                                                 2
#define IOC_IOCFG11_IOCURR_M                                        0x00000C00
#define IOC_IOCFG11_IOCURR_S                                                10
#define IOC_IOCFG11_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG11_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG11_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG11_IOSTR_W                                                  2
#define IOC_IOCFG11_IOSTR_M                                         0x00000300
#define IOC_IOCFG11_IOSTR_S                                                  8
#define IOC_IOCFG11_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG11_IOSTR_MED                                       0x00000200
#define IOC_IOCFG11_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG11_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG11_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG11_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG11_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG11_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG11_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG11_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG11_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG11_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO11
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG11_PORT_ID_W                                                6
#define IOC_IOCFG11_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG11_PORT_ID_S                                                0
#define IOC_IOCFG11_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG11_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG11_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG11_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG11_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG11_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG11_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG11_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG11_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG11_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG11_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG11_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG11_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG11_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG11_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG11_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG11_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG11_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG11_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG11_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG11_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG11_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG11_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG11_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG11_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG11_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG11_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG11_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG11_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG11_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG11_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG11_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG11_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG11_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG11_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG11_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG11_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG11_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG11_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG11_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG11_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG11_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG11_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG11_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG11_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG11_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG12
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG12_HYST_EN                                         0x40000000
#define IOC_IOCFG12_HYST_EN_BITN                                            30
#define IOC_IOCFG12_HYST_EN_M                                       0x40000000
#define IOC_IOCFG12_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG12_IE                                              0x20000000
#define IOC_IOCFG12_IE_BITN                                                 29
#define IOC_IOCFG12_IE_M                                            0x20000000
#define IOC_IOCFG12_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG12_WU_CFG_W                                                 2
#define IOC_IOCFG12_WU_CFG_M                                        0x18000000
#define IOC_IOCFG12_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG12_IOMODE_W                                                 3
#define IOC_IOCFG12_IOMODE_M                                        0x07000000
#define IOC_IOCFG12_IOMODE_S                                                24
#define IOC_IOCFG12_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG12_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG12_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG12_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG12_IOMODE_INV                                      0x01000000
#define IOC_IOCFG12_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG12_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG12_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG12_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG12_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG12_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG12_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG12_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG12_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG12_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG12_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG12_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG12_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG12_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG12_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG12_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG12_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG12_EDGE_DET_W                                               2
#define IOC_IOCFG12_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG12_EDGE_DET_S                                              16
#define IOC_IOCFG12_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG12_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG12_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG12_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG12_PULL_CTL_W                                               2
#define IOC_IOCFG12_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG12_PULL_CTL_S                                              13
#define IOC_IOCFG12_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG12_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG12_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG12_SLEW_RED                                        0x00001000
#define IOC_IOCFG12_SLEW_RED_BITN                                           12
#define IOC_IOCFG12_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG12_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG12_IOCURR_W                                                 2
#define IOC_IOCFG12_IOCURR_M                                        0x00000C00
#define IOC_IOCFG12_IOCURR_S                                                10
#define IOC_IOCFG12_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG12_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG12_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG12_IOSTR_W                                                  2
#define IOC_IOCFG12_IOSTR_M                                         0x00000300
#define IOC_IOCFG12_IOSTR_S                                                  8
#define IOC_IOCFG12_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG12_IOSTR_MED                                       0x00000200
#define IOC_IOCFG12_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG12_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG12_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG12_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG12_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG12_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG12_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG12_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG12_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG12_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO12
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG12_PORT_ID_W                                                6
#define IOC_IOCFG12_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG12_PORT_ID_S                                                0
#define IOC_IOCFG12_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG12_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG12_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG12_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG12_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG12_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG12_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG12_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG12_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG12_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG12_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG12_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG12_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG12_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG12_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG12_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG12_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG12_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG12_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG12_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG12_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG12_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG12_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG12_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG12_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG12_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG12_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG12_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG12_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG12_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG12_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG12_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG12_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG12_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG12_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG12_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG12_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG12_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG12_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG12_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG12_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG12_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG12_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG12_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG12_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG12_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG13
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG13_HYST_EN                                         0x40000000
#define IOC_IOCFG13_HYST_EN_BITN                                            30
#define IOC_IOCFG13_HYST_EN_M                                       0x40000000
#define IOC_IOCFG13_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG13_IE                                              0x20000000
#define IOC_IOCFG13_IE_BITN                                                 29
#define IOC_IOCFG13_IE_M                                            0x20000000
#define IOC_IOCFG13_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG13_WU_CFG_W                                                 2
#define IOC_IOCFG13_WU_CFG_M                                        0x18000000
#define IOC_IOCFG13_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG13_IOMODE_W                                                 3
#define IOC_IOCFG13_IOMODE_M                                        0x07000000
#define IOC_IOCFG13_IOMODE_S                                                24
#define IOC_IOCFG13_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG13_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG13_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG13_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG13_IOMODE_INV                                      0x01000000
#define IOC_IOCFG13_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG13_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG13_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG13_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG13_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG13_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG13_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG13_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG13_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG13_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG13_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG13_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG13_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG13_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG13_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG13_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG13_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG13_EDGE_DET_W                                               2
#define IOC_IOCFG13_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG13_EDGE_DET_S                                              16
#define IOC_IOCFG13_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG13_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG13_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG13_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG13_PULL_CTL_W                                               2
#define IOC_IOCFG13_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG13_PULL_CTL_S                                              13
#define IOC_IOCFG13_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG13_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG13_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG13_SLEW_RED                                        0x00001000
#define IOC_IOCFG13_SLEW_RED_BITN                                           12
#define IOC_IOCFG13_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG13_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG13_IOCURR_W                                                 2
#define IOC_IOCFG13_IOCURR_M                                        0x00000C00
#define IOC_IOCFG13_IOCURR_S                                                10
#define IOC_IOCFG13_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG13_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG13_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG13_IOSTR_W                                                  2
#define IOC_IOCFG13_IOSTR_M                                         0x00000300
#define IOC_IOCFG13_IOSTR_S                                                  8
#define IOC_IOCFG13_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG13_IOSTR_MED                                       0x00000200
#define IOC_IOCFG13_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG13_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG13_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG13_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG13_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG13_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG13_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG13_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG13_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG13_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO13
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG13_PORT_ID_W                                                6
#define IOC_IOCFG13_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG13_PORT_ID_S                                                0
#define IOC_IOCFG13_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG13_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG13_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG13_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG13_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG13_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG13_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG13_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG13_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG13_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG13_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG13_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG13_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG13_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG13_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG13_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG13_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG13_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG13_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG13_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG13_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG13_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG13_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG13_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG13_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG13_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG13_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG13_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG13_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG13_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG13_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG13_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG13_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG13_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG13_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG13_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG13_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG13_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG13_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG13_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG13_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG13_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG13_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG13_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG13_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG13_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG14
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG14_HYST_EN                                         0x40000000
#define IOC_IOCFG14_HYST_EN_BITN                                            30
#define IOC_IOCFG14_HYST_EN_M                                       0x40000000
#define IOC_IOCFG14_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG14_IE                                              0x20000000
#define IOC_IOCFG14_IE_BITN                                                 29
#define IOC_IOCFG14_IE_M                                            0x20000000
#define IOC_IOCFG14_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG14_WU_CFG_W                                                 2
#define IOC_IOCFG14_WU_CFG_M                                        0x18000000
#define IOC_IOCFG14_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG14_IOMODE_W                                                 3
#define IOC_IOCFG14_IOMODE_M                                        0x07000000
#define IOC_IOCFG14_IOMODE_S                                                24
#define IOC_IOCFG14_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG14_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG14_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG14_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG14_IOMODE_INV                                      0x01000000
#define IOC_IOCFG14_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG14_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG14_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG14_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG14_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG14_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG14_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG14_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG14_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG14_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG14_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG14_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG14_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG14_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG14_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG14_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG14_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG14_EDGE_DET_W                                               2
#define IOC_IOCFG14_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG14_EDGE_DET_S                                              16
#define IOC_IOCFG14_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG14_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG14_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG14_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG14_PULL_CTL_W                                               2
#define IOC_IOCFG14_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG14_PULL_CTL_S                                              13
#define IOC_IOCFG14_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG14_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG14_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG14_SLEW_RED                                        0x00001000
#define IOC_IOCFG14_SLEW_RED_BITN                                           12
#define IOC_IOCFG14_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG14_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG14_IOCURR_W                                                 2
#define IOC_IOCFG14_IOCURR_M                                        0x00000C00
#define IOC_IOCFG14_IOCURR_S                                                10
#define IOC_IOCFG14_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG14_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG14_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG14_IOSTR_W                                                  2
#define IOC_IOCFG14_IOSTR_M                                         0x00000300
#define IOC_IOCFG14_IOSTR_S                                                  8
#define IOC_IOCFG14_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG14_IOSTR_MED                                       0x00000200
#define IOC_IOCFG14_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG14_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG14_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG14_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG14_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG14_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG14_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG14_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG14_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG14_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO14
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG14_PORT_ID_W                                                6
#define IOC_IOCFG14_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG14_PORT_ID_S                                                0
#define IOC_IOCFG14_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG14_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG14_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG14_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG14_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG14_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG14_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG14_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG14_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG14_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG14_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG14_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG14_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG14_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG14_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG14_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG14_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG14_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG14_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG14_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG14_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG14_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG14_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG14_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG14_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG14_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG14_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG14_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG14_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG14_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG14_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG14_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG14_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG14_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG14_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG14_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG14_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG14_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG14_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG14_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG14_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG14_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG14_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG14_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG14_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG14_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG15
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG15_HYST_EN                                         0x40000000
#define IOC_IOCFG15_HYST_EN_BITN                                            30
#define IOC_IOCFG15_HYST_EN_M                                       0x40000000
#define IOC_IOCFG15_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG15_IE                                              0x20000000
#define IOC_IOCFG15_IE_BITN                                                 29
#define IOC_IOCFG15_IE_M                                            0x20000000
#define IOC_IOCFG15_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG15_WU_CFG_W                                                 2
#define IOC_IOCFG15_WU_CFG_M                                        0x18000000
#define IOC_IOCFG15_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG15_IOMODE_W                                                 3
#define IOC_IOCFG15_IOMODE_M                                        0x07000000
#define IOC_IOCFG15_IOMODE_S                                                24
#define IOC_IOCFG15_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG15_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG15_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG15_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG15_IOMODE_INV                                      0x01000000
#define IOC_IOCFG15_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG15_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG15_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG15_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG15_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG15_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG15_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG15_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG15_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG15_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG15_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG15_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG15_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG15_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG15_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG15_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG15_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG15_EDGE_DET_W                                               2
#define IOC_IOCFG15_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG15_EDGE_DET_S                                              16
#define IOC_IOCFG15_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG15_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG15_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG15_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG15_PULL_CTL_W                                               2
#define IOC_IOCFG15_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG15_PULL_CTL_S                                              13
#define IOC_IOCFG15_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG15_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG15_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG15_SLEW_RED                                        0x00001000
#define IOC_IOCFG15_SLEW_RED_BITN                                           12
#define IOC_IOCFG15_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG15_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG15_IOCURR_W                                                 2
#define IOC_IOCFG15_IOCURR_M                                        0x00000C00
#define IOC_IOCFG15_IOCURR_S                                                10
#define IOC_IOCFG15_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG15_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG15_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG15_IOSTR_W                                                  2
#define IOC_IOCFG15_IOSTR_M                                         0x00000300
#define IOC_IOCFG15_IOSTR_S                                                  8
#define IOC_IOCFG15_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG15_IOSTR_MED                                       0x00000200
#define IOC_IOCFG15_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG15_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG15_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG15_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG15_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG15_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG15_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG15_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG15_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG15_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO15
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG15_PORT_ID_W                                                6
#define IOC_IOCFG15_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG15_PORT_ID_S                                                0
#define IOC_IOCFG15_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG15_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG15_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG15_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG15_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG15_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG15_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG15_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG15_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG15_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG15_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG15_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG15_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG15_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG15_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG15_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG15_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG15_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG15_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG15_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG15_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG15_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG15_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG15_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG15_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG15_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG15_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG15_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG15_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG15_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG15_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG15_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG15_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG15_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG15_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG15_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG15_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG15_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG15_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG15_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG15_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG15_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG15_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG15_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG15_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG15_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG16
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG16_HYST_EN                                         0x40000000
#define IOC_IOCFG16_HYST_EN_BITN                                            30
#define IOC_IOCFG16_HYST_EN_M                                       0x40000000
#define IOC_IOCFG16_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG16_IE                                              0x20000000
#define IOC_IOCFG16_IE_BITN                                                 29
#define IOC_IOCFG16_IE_M                                            0x20000000
#define IOC_IOCFG16_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG16_WU_CFG_W                                                 2
#define IOC_IOCFG16_WU_CFG_M                                        0x18000000
#define IOC_IOCFG16_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG16_IOMODE_W                                                 3
#define IOC_IOCFG16_IOMODE_M                                        0x07000000
#define IOC_IOCFG16_IOMODE_S                                                24
#define IOC_IOCFG16_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG16_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG16_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG16_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG16_IOMODE_INV                                      0x01000000
#define IOC_IOCFG16_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG16_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG16_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG16_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG16_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG16_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG16_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG16_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG16_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG16_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG16_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG16_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG16_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG16_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG16_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG16_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG16_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG16_EDGE_DET_W                                               2
#define IOC_IOCFG16_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG16_EDGE_DET_S                                              16
#define IOC_IOCFG16_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG16_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG16_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG16_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG16_PULL_CTL_W                                               2
#define IOC_IOCFG16_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG16_PULL_CTL_S                                              13
#define IOC_IOCFG16_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG16_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG16_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG16_SLEW_RED                                        0x00001000
#define IOC_IOCFG16_SLEW_RED_BITN                                           12
#define IOC_IOCFG16_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG16_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG16_IOCURR_W                                                 2
#define IOC_IOCFG16_IOCURR_M                                        0x00000C00
#define IOC_IOCFG16_IOCURR_S                                                10
#define IOC_IOCFG16_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG16_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG16_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG16_IOSTR_W                                                  2
#define IOC_IOCFG16_IOSTR_M                                         0x00000300
#define IOC_IOCFG16_IOSTR_S                                                  8
#define IOC_IOCFG16_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG16_IOSTR_MED                                       0x00000200
#define IOC_IOCFG16_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG16_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG16_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG16_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG16_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG16_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG16_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG16_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG16_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG16_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO16
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG16_PORT_ID_W                                                6
#define IOC_IOCFG16_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG16_PORT_ID_S                                                0
#define IOC_IOCFG16_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG16_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG16_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG16_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG16_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG16_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG16_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG16_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG16_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG16_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG16_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG16_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG16_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG16_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG16_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG16_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG16_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG16_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG16_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG16_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG16_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG16_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG16_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG16_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG16_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG16_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG16_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG16_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG16_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG16_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG16_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG16_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG16_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG16_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG16_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG16_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG16_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG16_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG16_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG16_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG16_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG16_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG16_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG16_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG16_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG16_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG17
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG17_HYST_EN                                         0x40000000
#define IOC_IOCFG17_HYST_EN_BITN                                            30
#define IOC_IOCFG17_HYST_EN_M                                       0x40000000
#define IOC_IOCFG17_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG17_IE                                              0x20000000
#define IOC_IOCFG17_IE_BITN                                                 29
#define IOC_IOCFG17_IE_M                                            0x20000000
#define IOC_IOCFG17_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG17_WU_CFG_W                                                 2
#define IOC_IOCFG17_WU_CFG_M                                        0x18000000
#define IOC_IOCFG17_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG17_IOMODE_W                                                 3
#define IOC_IOCFG17_IOMODE_M                                        0x07000000
#define IOC_IOCFG17_IOMODE_S                                                24
#define IOC_IOCFG17_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG17_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG17_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG17_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG17_IOMODE_INV                                      0x01000000
#define IOC_IOCFG17_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG17_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG17_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG17_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG17_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG17_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG17_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG17_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG17_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG17_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG17_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG17_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG17_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG17_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG17_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG17_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG17_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG17_EDGE_DET_W                                               2
#define IOC_IOCFG17_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG17_EDGE_DET_S                                              16
#define IOC_IOCFG17_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG17_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG17_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG17_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG17_PULL_CTL_W                                               2
#define IOC_IOCFG17_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG17_PULL_CTL_S                                              13
#define IOC_IOCFG17_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG17_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG17_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG17_SLEW_RED                                        0x00001000
#define IOC_IOCFG17_SLEW_RED_BITN                                           12
#define IOC_IOCFG17_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG17_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG17_IOCURR_W                                                 2
#define IOC_IOCFG17_IOCURR_M                                        0x00000C00
#define IOC_IOCFG17_IOCURR_S                                                10
#define IOC_IOCFG17_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG17_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG17_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG17_IOSTR_W                                                  2
#define IOC_IOCFG17_IOSTR_M                                         0x00000300
#define IOC_IOCFG17_IOSTR_S                                                  8
#define IOC_IOCFG17_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG17_IOSTR_MED                                       0x00000200
#define IOC_IOCFG17_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG17_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG17_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG17_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG17_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG17_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG17_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG17_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG17_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG17_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO17
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG17_PORT_ID_W                                                6
#define IOC_IOCFG17_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG17_PORT_ID_S                                                0
#define IOC_IOCFG17_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG17_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG17_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG17_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG17_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG17_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG17_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG17_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG17_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG17_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG17_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG17_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG17_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG17_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG17_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG17_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG17_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG17_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG17_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG17_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG17_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG17_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG17_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG17_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG17_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG17_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG17_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG17_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG17_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG17_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG17_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG17_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG17_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG17_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG17_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG17_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG17_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG17_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG17_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG17_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG17_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG17_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG17_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG17_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG17_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG17_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG18
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG18_HYST_EN                                         0x40000000
#define IOC_IOCFG18_HYST_EN_BITN                                            30
#define IOC_IOCFG18_HYST_EN_M                                       0x40000000
#define IOC_IOCFG18_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG18_IE                                              0x20000000
#define IOC_IOCFG18_IE_BITN                                                 29
#define IOC_IOCFG18_IE_M                                            0x20000000
#define IOC_IOCFG18_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG18_WU_CFG_W                                                 2
#define IOC_IOCFG18_WU_CFG_M                                        0x18000000
#define IOC_IOCFG18_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG18_IOMODE_W                                                 3
#define IOC_IOCFG18_IOMODE_M                                        0x07000000
#define IOC_IOCFG18_IOMODE_S                                                24
#define IOC_IOCFG18_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG18_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG18_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG18_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG18_IOMODE_INV                                      0x01000000
#define IOC_IOCFG18_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG18_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG18_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG18_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG18_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG18_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG18_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG18_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG18_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG18_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG18_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG18_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG18_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG18_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG18_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG18_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG18_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG18_EDGE_DET_W                                               2
#define IOC_IOCFG18_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG18_EDGE_DET_S                                              16
#define IOC_IOCFG18_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG18_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG18_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG18_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG18_PULL_CTL_W                                               2
#define IOC_IOCFG18_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG18_PULL_CTL_S                                              13
#define IOC_IOCFG18_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG18_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG18_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG18_SLEW_RED                                        0x00001000
#define IOC_IOCFG18_SLEW_RED_BITN                                           12
#define IOC_IOCFG18_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG18_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG18_IOCURR_W                                                 2
#define IOC_IOCFG18_IOCURR_M                                        0x00000C00
#define IOC_IOCFG18_IOCURR_S                                                10
#define IOC_IOCFG18_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG18_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG18_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG18_IOSTR_W                                                  2
#define IOC_IOCFG18_IOSTR_M                                         0x00000300
#define IOC_IOCFG18_IOSTR_S                                                  8
#define IOC_IOCFG18_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG18_IOSTR_MED                                       0x00000200
#define IOC_IOCFG18_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG18_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG18_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG18_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG18_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG18_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG18_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG18_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG18_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG18_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO18
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG18_PORT_ID_W                                                6
#define IOC_IOCFG18_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG18_PORT_ID_S                                                0
#define IOC_IOCFG18_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG18_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG18_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG18_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG18_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG18_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG18_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG18_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG18_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG18_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG18_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG18_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG18_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG18_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG18_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG18_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG18_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG18_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG18_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG18_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG18_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG18_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG18_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG18_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG18_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG18_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG18_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG18_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG18_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG18_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG18_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG18_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG18_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG18_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG18_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG18_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG18_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG18_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG18_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG18_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG18_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG18_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG18_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG18_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG18_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG18_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG19
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG19_HYST_EN                                         0x40000000
#define IOC_IOCFG19_HYST_EN_BITN                                            30
#define IOC_IOCFG19_HYST_EN_M                                       0x40000000
#define IOC_IOCFG19_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG19_IE                                              0x20000000
#define IOC_IOCFG19_IE_BITN                                                 29
#define IOC_IOCFG19_IE_M                                            0x20000000
#define IOC_IOCFG19_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG19_WU_CFG_W                                                 2
#define IOC_IOCFG19_WU_CFG_M                                        0x18000000
#define IOC_IOCFG19_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG19_IOMODE_W                                                 3
#define IOC_IOCFG19_IOMODE_M                                        0x07000000
#define IOC_IOCFG19_IOMODE_S                                                24
#define IOC_IOCFG19_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG19_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG19_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG19_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG19_IOMODE_INV                                      0x01000000
#define IOC_IOCFG19_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG19_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG19_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG19_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG19_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG19_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG19_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG19_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG19_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG19_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG19_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG19_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG19_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG19_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG19_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG19_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG19_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG19_EDGE_DET_W                                               2
#define IOC_IOCFG19_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG19_EDGE_DET_S                                              16
#define IOC_IOCFG19_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG19_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG19_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG19_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG19_PULL_CTL_W                                               2
#define IOC_IOCFG19_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG19_PULL_CTL_S                                              13
#define IOC_IOCFG19_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG19_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG19_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG19_SLEW_RED                                        0x00001000
#define IOC_IOCFG19_SLEW_RED_BITN                                           12
#define IOC_IOCFG19_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG19_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG19_IOCURR_W                                                 2
#define IOC_IOCFG19_IOCURR_M                                        0x00000C00
#define IOC_IOCFG19_IOCURR_S                                                10
#define IOC_IOCFG19_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG19_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG19_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG19_IOSTR_W                                                  2
#define IOC_IOCFG19_IOSTR_M                                         0x00000300
#define IOC_IOCFG19_IOSTR_S                                                  8
#define IOC_IOCFG19_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG19_IOSTR_MED                                       0x00000200
#define IOC_IOCFG19_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG19_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG19_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG19_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG19_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG19_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG19_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG19_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG19_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG19_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO19
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG19_PORT_ID_W                                                6
#define IOC_IOCFG19_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG19_PORT_ID_S                                                0
#define IOC_IOCFG19_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG19_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG19_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG19_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG19_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG19_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG19_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG19_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG19_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG19_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG19_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG19_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG19_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG19_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG19_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG19_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG19_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG19_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG19_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG19_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG19_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG19_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG19_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG19_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG19_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG19_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG19_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG19_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG19_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG19_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG19_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG19_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG19_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG19_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG19_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG19_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG19_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG19_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG19_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG19_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG19_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG19_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG19_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG19_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG19_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG19_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG20
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG20_HYST_EN                                         0x40000000
#define IOC_IOCFG20_HYST_EN_BITN                                            30
#define IOC_IOCFG20_HYST_EN_M                                       0x40000000
#define IOC_IOCFG20_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG20_IE                                              0x20000000
#define IOC_IOCFG20_IE_BITN                                                 29
#define IOC_IOCFG20_IE_M                                            0x20000000
#define IOC_IOCFG20_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG20_WU_CFG_W                                                 2
#define IOC_IOCFG20_WU_CFG_M                                        0x18000000
#define IOC_IOCFG20_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG20_IOMODE_W                                                 3
#define IOC_IOCFG20_IOMODE_M                                        0x07000000
#define IOC_IOCFG20_IOMODE_S                                                24
#define IOC_IOCFG20_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG20_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG20_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG20_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG20_IOMODE_INV                                      0x01000000
#define IOC_IOCFG20_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG20_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG20_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG20_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG20_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG20_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG20_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG20_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG20_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG20_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG20_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG20_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG20_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG20_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG20_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG20_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG20_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG20_EDGE_DET_W                                               2
#define IOC_IOCFG20_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG20_EDGE_DET_S                                              16
#define IOC_IOCFG20_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG20_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG20_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG20_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG20_PULL_CTL_W                                               2
#define IOC_IOCFG20_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG20_PULL_CTL_S                                              13
#define IOC_IOCFG20_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG20_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG20_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG20_SLEW_RED                                        0x00001000
#define IOC_IOCFG20_SLEW_RED_BITN                                           12
#define IOC_IOCFG20_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG20_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG20_IOCURR_W                                                 2
#define IOC_IOCFG20_IOCURR_M                                        0x00000C00
#define IOC_IOCFG20_IOCURR_S                                                10
#define IOC_IOCFG20_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG20_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG20_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG20_IOSTR_W                                                  2
#define IOC_IOCFG20_IOSTR_M                                         0x00000300
#define IOC_IOCFG20_IOSTR_S                                                  8
#define IOC_IOCFG20_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG20_IOSTR_MED                                       0x00000200
#define IOC_IOCFG20_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG20_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG20_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG20_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG20_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG20_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG20_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG20_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG20_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG20_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO20
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG20_PORT_ID_W                                                6
#define IOC_IOCFG20_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG20_PORT_ID_S                                                0
#define IOC_IOCFG20_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG20_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG20_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG20_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG20_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG20_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG20_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG20_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG20_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG20_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG20_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG20_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG20_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG20_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG20_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG20_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG20_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG20_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG20_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG20_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG20_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG20_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG20_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG20_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG20_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG20_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG20_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG20_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG20_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG20_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG20_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG20_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG20_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG20_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG20_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG20_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG20_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG20_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG20_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG20_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG20_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG20_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG20_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG20_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG20_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG20_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG21
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG21_HYST_EN                                         0x40000000
#define IOC_IOCFG21_HYST_EN_BITN                                            30
#define IOC_IOCFG21_HYST_EN_M                                       0x40000000
#define IOC_IOCFG21_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG21_IE                                              0x20000000
#define IOC_IOCFG21_IE_BITN                                                 29
#define IOC_IOCFG21_IE_M                                            0x20000000
#define IOC_IOCFG21_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG21_WU_CFG_W                                                 2
#define IOC_IOCFG21_WU_CFG_M                                        0x18000000
#define IOC_IOCFG21_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG21_IOMODE_W                                                 3
#define IOC_IOCFG21_IOMODE_M                                        0x07000000
#define IOC_IOCFG21_IOMODE_S                                                24
#define IOC_IOCFG21_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG21_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG21_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG21_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG21_IOMODE_INV                                      0x01000000
#define IOC_IOCFG21_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG21_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG21_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG21_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG21_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG21_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG21_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG21_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG21_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG21_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG21_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG21_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG21_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG21_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG21_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG21_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG21_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG21_EDGE_DET_W                                               2
#define IOC_IOCFG21_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG21_EDGE_DET_S                                              16
#define IOC_IOCFG21_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG21_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG21_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG21_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG21_PULL_CTL_W                                               2
#define IOC_IOCFG21_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG21_PULL_CTL_S                                              13
#define IOC_IOCFG21_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG21_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG21_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG21_SLEW_RED                                        0x00001000
#define IOC_IOCFG21_SLEW_RED_BITN                                           12
#define IOC_IOCFG21_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG21_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG21_IOCURR_W                                                 2
#define IOC_IOCFG21_IOCURR_M                                        0x00000C00
#define IOC_IOCFG21_IOCURR_S                                                10
#define IOC_IOCFG21_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG21_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG21_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG21_IOSTR_W                                                  2
#define IOC_IOCFG21_IOSTR_M                                         0x00000300
#define IOC_IOCFG21_IOSTR_S                                                  8
#define IOC_IOCFG21_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG21_IOSTR_MED                                       0x00000200
#define IOC_IOCFG21_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG21_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG21_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG21_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG21_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG21_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG21_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG21_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG21_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG21_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO21
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG21_PORT_ID_W                                                6
#define IOC_IOCFG21_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG21_PORT_ID_S                                                0
#define IOC_IOCFG21_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG21_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG21_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG21_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG21_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG21_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG21_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG21_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG21_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG21_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG21_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG21_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG21_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG21_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG21_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG21_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG21_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG21_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG21_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG21_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG21_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG21_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG21_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG21_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG21_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG21_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG21_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG21_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG21_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG21_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG21_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG21_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG21_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG21_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG21_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG21_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG21_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG21_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG21_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG21_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG21_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG21_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG21_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG21_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG21_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG21_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG22
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG22_HYST_EN                                         0x40000000
#define IOC_IOCFG22_HYST_EN_BITN                                            30
#define IOC_IOCFG22_HYST_EN_M                                       0x40000000
#define IOC_IOCFG22_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG22_IE                                              0x20000000
#define IOC_IOCFG22_IE_BITN                                                 29
#define IOC_IOCFG22_IE_M                                            0x20000000
#define IOC_IOCFG22_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG22_WU_CFG_W                                                 2
#define IOC_IOCFG22_WU_CFG_M                                        0x18000000
#define IOC_IOCFG22_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG22_IOMODE_W                                                 3
#define IOC_IOCFG22_IOMODE_M                                        0x07000000
#define IOC_IOCFG22_IOMODE_S                                                24
#define IOC_IOCFG22_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG22_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG22_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG22_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG22_IOMODE_INV                                      0x01000000
#define IOC_IOCFG22_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG22_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG22_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG22_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG22_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG22_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG22_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG22_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG22_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG22_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG22_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG22_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG22_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG22_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG22_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG22_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG22_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG22_EDGE_DET_W                                               2
#define IOC_IOCFG22_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG22_EDGE_DET_S                                              16
#define IOC_IOCFG22_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG22_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG22_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG22_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG22_PULL_CTL_W                                               2
#define IOC_IOCFG22_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG22_PULL_CTL_S                                              13
#define IOC_IOCFG22_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG22_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG22_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG22_SLEW_RED                                        0x00001000
#define IOC_IOCFG22_SLEW_RED_BITN                                           12
#define IOC_IOCFG22_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG22_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG22_IOCURR_W                                                 2
#define IOC_IOCFG22_IOCURR_M                                        0x00000C00
#define IOC_IOCFG22_IOCURR_S                                                10
#define IOC_IOCFG22_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG22_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG22_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG22_IOSTR_W                                                  2
#define IOC_IOCFG22_IOSTR_M                                         0x00000300
#define IOC_IOCFG22_IOSTR_S                                                  8
#define IOC_IOCFG22_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG22_IOSTR_MED                                       0x00000200
#define IOC_IOCFG22_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG22_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG22_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG22_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG22_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG22_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG22_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG22_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG22_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG22_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO22
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG22_PORT_ID_W                                                6
#define IOC_IOCFG22_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG22_PORT_ID_S                                                0
#define IOC_IOCFG22_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG22_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG22_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG22_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG22_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG22_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG22_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG22_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG22_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG22_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG22_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG22_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG22_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG22_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG22_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG22_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG22_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG22_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG22_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG22_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG22_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG22_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG22_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG22_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG22_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG22_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG22_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG22_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG22_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG22_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG22_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG22_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG22_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG22_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG22_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG22_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG22_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG22_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG22_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG22_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG22_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG22_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG22_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG22_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG22_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG22_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG23
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG23_HYST_EN                                         0x40000000
#define IOC_IOCFG23_HYST_EN_BITN                                            30
#define IOC_IOCFG23_HYST_EN_M                                       0x40000000
#define IOC_IOCFG23_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG23_IE                                              0x20000000
#define IOC_IOCFG23_IE_BITN                                                 29
#define IOC_IOCFG23_IE_M                                            0x20000000
#define IOC_IOCFG23_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG23_WU_CFG_W                                                 2
#define IOC_IOCFG23_WU_CFG_M                                        0x18000000
#define IOC_IOCFG23_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG23_IOMODE_W                                                 3
#define IOC_IOCFG23_IOMODE_M                                        0x07000000
#define IOC_IOCFG23_IOMODE_S                                                24
#define IOC_IOCFG23_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG23_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG23_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG23_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG23_IOMODE_INV                                      0x01000000
#define IOC_IOCFG23_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG23_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG23_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG23_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG23_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG23_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG23_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG23_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG23_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG23_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG23_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG23_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG23_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG23_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG23_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG23_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG23_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG23_EDGE_DET_W                                               2
#define IOC_IOCFG23_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG23_EDGE_DET_S                                              16
#define IOC_IOCFG23_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG23_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG23_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG23_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG23_PULL_CTL_W                                               2
#define IOC_IOCFG23_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG23_PULL_CTL_S                                              13
#define IOC_IOCFG23_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG23_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG23_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG23_SLEW_RED                                        0x00001000
#define IOC_IOCFG23_SLEW_RED_BITN                                           12
#define IOC_IOCFG23_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG23_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG23_IOCURR_W                                                 2
#define IOC_IOCFG23_IOCURR_M                                        0x00000C00
#define IOC_IOCFG23_IOCURR_S                                                10
#define IOC_IOCFG23_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG23_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG23_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG23_IOSTR_W                                                  2
#define IOC_IOCFG23_IOSTR_M                                         0x00000300
#define IOC_IOCFG23_IOSTR_S                                                  8
#define IOC_IOCFG23_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG23_IOSTR_MED                                       0x00000200
#define IOC_IOCFG23_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG23_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG23_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG23_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG23_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG23_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG23_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG23_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG23_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG23_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO23
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG23_PORT_ID_W                                                6
#define IOC_IOCFG23_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG23_PORT_ID_S                                                0
#define IOC_IOCFG23_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG23_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG23_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG23_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG23_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG23_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG23_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG23_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG23_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG23_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG23_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG23_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG23_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG23_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG23_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG23_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG23_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG23_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG23_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG23_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG23_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG23_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG23_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG23_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG23_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG23_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG23_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG23_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG23_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG23_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG23_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG23_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG23_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG23_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG23_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG23_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG23_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG23_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG23_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG23_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG23_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG23_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG23_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG23_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG23_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG23_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG24
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG24_HYST_EN                                         0x40000000
#define IOC_IOCFG24_HYST_EN_BITN                                            30
#define IOC_IOCFG24_HYST_EN_M                                       0x40000000
#define IOC_IOCFG24_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG24_IE                                              0x20000000
#define IOC_IOCFG24_IE_BITN                                                 29
#define IOC_IOCFG24_IE_M                                            0x20000000
#define IOC_IOCFG24_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG24_WU_CFG_W                                                 2
#define IOC_IOCFG24_WU_CFG_M                                        0x18000000
#define IOC_IOCFG24_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG24_IOMODE_W                                                 3
#define IOC_IOCFG24_IOMODE_M                                        0x07000000
#define IOC_IOCFG24_IOMODE_S                                                24
#define IOC_IOCFG24_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG24_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG24_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG24_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG24_IOMODE_INV                                      0x01000000
#define IOC_IOCFG24_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG24_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG24_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG24_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG24_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG24_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG24_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG24_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG24_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG24_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG24_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG24_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG24_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG24_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG24_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG24_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG24_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG24_EDGE_DET_W                                               2
#define IOC_IOCFG24_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG24_EDGE_DET_S                                              16
#define IOC_IOCFG24_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG24_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG24_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG24_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG24_PULL_CTL_W                                               2
#define IOC_IOCFG24_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG24_PULL_CTL_S                                              13
#define IOC_IOCFG24_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG24_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG24_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG24_SLEW_RED                                        0x00001000
#define IOC_IOCFG24_SLEW_RED_BITN                                           12
#define IOC_IOCFG24_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG24_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG24_IOCURR_W                                                 2
#define IOC_IOCFG24_IOCURR_M                                        0x00000C00
#define IOC_IOCFG24_IOCURR_S                                                10
#define IOC_IOCFG24_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG24_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG24_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG24_IOSTR_W                                                  2
#define IOC_IOCFG24_IOSTR_M                                         0x00000300
#define IOC_IOCFG24_IOSTR_S                                                  8
#define IOC_IOCFG24_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG24_IOSTR_MED                                       0x00000200
#define IOC_IOCFG24_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG24_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG24_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG24_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG24_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG24_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG24_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG24_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG24_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG24_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO24
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG24_PORT_ID_W                                                6
#define IOC_IOCFG24_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG24_PORT_ID_S                                                0
#define IOC_IOCFG24_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG24_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG24_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG24_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG24_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG24_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG24_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG24_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG24_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG24_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG24_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG24_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG24_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG24_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG24_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG24_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG24_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG24_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG24_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG24_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG24_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG24_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG24_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG24_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG24_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG24_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG24_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG24_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG24_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG24_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG24_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG24_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG24_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG24_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG24_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG24_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG24_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG24_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG24_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG24_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG24_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG24_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG24_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG24_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG24_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG24_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG25
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG25_HYST_EN                                         0x40000000
#define IOC_IOCFG25_HYST_EN_BITN                                            30
#define IOC_IOCFG25_HYST_EN_M                                       0x40000000
#define IOC_IOCFG25_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG25_IE                                              0x20000000
#define IOC_IOCFG25_IE_BITN                                                 29
#define IOC_IOCFG25_IE_M                                            0x20000000
#define IOC_IOCFG25_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG25_WU_CFG_W                                                 2
#define IOC_IOCFG25_WU_CFG_M                                        0x18000000
#define IOC_IOCFG25_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG25_IOMODE_W                                                 3
#define IOC_IOCFG25_IOMODE_M                                        0x07000000
#define IOC_IOCFG25_IOMODE_S                                                24
#define IOC_IOCFG25_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG25_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG25_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG25_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG25_IOMODE_INV                                      0x01000000
#define IOC_IOCFG25_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG25_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG25_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG25_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG25_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG25_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG25_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG25_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG25_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG25_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG25_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG25_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG25_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG25_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG25_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG25_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG25_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG25_EDGE_DET_W                                               2
#define IOC_IOCFG25_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG25_EDGE_DET_S                                              16
#define IOC_IOCFG25_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG25_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG25_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG25_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG25_PULL_CTL_W                                               2
#define IOC_IOCFG25_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG25_PULL_CTL_S                                              13
#define IOC_IOCFG25_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG25_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG25_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG25_SLEW_RED                                        0x00001000
#define IOC_IOCFG25_SLEW_RED_BITN                                           12
#define IOC_IOCFG25_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG25_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG25_IOCURR_W                                                 2
#define IOC_IOCFG25_IOCURR_M                                        0x00000C00
#define IOC_IOCFG25_IOCURR_S                                                10
#define IOC_IOCFG25_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG25_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG25_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG25_IOSTR_W                                                  2
#define IOC_IOCFG25_IOSTR_M                                         0x00000300
#define IOC_IOCFG25_IOSTR_S                                                  8
#define IOC_IOCFG25_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG25_IOSTR_MED                                       0x00000200
#define IOC_IOCFG25_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG25_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG25_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG25_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG25_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG25_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG25_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG25_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG25_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG25_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO25
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG25_PORT_ID_W                                                6
#define IOC_IOCFG25_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG25_PORT_ID_S                                                0
#define IOC_IOCFG25_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG25_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG25_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG25_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG25_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG25_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG25_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG25_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG25_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG25_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG25_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG25_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG25_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG25_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG25_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG25_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG25_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG25_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG25_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG25_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG25_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG25_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG25_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG25_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG25_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG25_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG25_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG25_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG25_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG25_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG25_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG25_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG25_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG25_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG25_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG25_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG25_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG25_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG25_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG25_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG25_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG25_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG25_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG25_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG25_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG25_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG26
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG26_HYST_EN                                         0x40000000
#define IOC_IOCFG26_HYST_EN_BITN                                            30
#define IOC_IOCFG26_HYST_EN_M                                       0x40000000
#define IOC_IOCFG26_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG26_IE                                              0x20000000
#define IOC_IOCFG26_IE_BITN                                                 29
#define IOC_IOCFG26_IE_M                                            0x20000000
#define IOC_IOCFG26_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG26_WU_CFG_W                                                 2
#define IOC_IOCFG26_WU_CFG_M                                        0x18000000
#define IOC_IOCFG26_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG26_IOMODE_W                                                 3
#define IOC_IOCFG26_IOMODE_M                                        0x07000000
#define IOC_IOCFG26_IOMODE_S                                                24
#define IOC_IOCFG26_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG26_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG26_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG26_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG26_IOMODE_INV                                      0x01000000
#define IOC_IOCFG26_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG26_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG26_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG26_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG26_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG26_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG26_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG26_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG26_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG26_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG26_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG26_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG26_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG26_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG26_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG26_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG26_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG26_EDGE_DET_W                                               2
#define IOC_IOCFG26_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG26_EDGE_DET_S                                              16
#define IOC_IOCFG26_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG26_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG26_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG26_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG26_PULL_CTL_W                                               2
#define IOC_IOCFG26_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG26_PULL_CTL_S                                              13
#define IOC_IOCFG26_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG26_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG26_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG26_SLEW_RED                                        0x00001000
#define IOC_IOCFG26_SLEW_RED_BITN                                           12
#define IOC_IOCFG26_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG26_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG26_IOCURR_W                                                 2
#define IOC_IOCFG26_IOCURR_M                                        0x00000C00
#define IOC_IOCFG26_IOCURR_S                                                10
#define IOC_IOCFG26_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG26_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG26_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG26_IOSTR_W                                                  2
#define IOC_IOCFG26_IOSTR_M                                         0x00000300
#define IOC_IOCFG26_IOSTR_S                                                  8
#define IOC_IOCFG26_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG26_IOSTR_MED                                       0x00000200
#define IOC_IOCFG26_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG26_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG26_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG26_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG26_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG26_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG26_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG26_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG26_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG26_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO26
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG26_PORT_ID_W                                                6
#define IOC_IOCFG26_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG26_PORT_ID_S                                                0
#define IOC_IOCFG26_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG26_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG26_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG26_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG26_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG26_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG26_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG26_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG26_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG26_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG26_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG26_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG26_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG26_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG26_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG26_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG26_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG26_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG26_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG26_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG26_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG26_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG26_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG26_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG26_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG26_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG26_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG26_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG26_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG26_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG26_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG26_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG26_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG26_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG26_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG26_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG26_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG26_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG26_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG26_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG26_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG26_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG26_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG26_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG26_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG26_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG27
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG27_HYST_EN                                         0x40000000
#define IOC_IOCFG27_HYST_EN_BITN                                            30
#define IOC_IOCFG27_HYST_EN_M                                       0x40000000
#define IOC_IOCFG27_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG27_IE                                              0x20000000
#define IOC_IOCFG27_IE_BITN                                                 29
#define IOC_IOCFG27_IE_M                                            0x20000000
#define IOC_IOCFG27_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG27_WU_CFG_W                                                 2
#define IOC_IOCFG27_WU_CFG_M                                        0x18000000
#define IOC_IOCFG27_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG27_IOMODE_W                                                 3
#define IOC_IOCFG27_IOMODE_M                                        0x07000000
#define IOC_IOCFG27_IOMODE_S                                                24
#define IOC_IOCFG27_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG27_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG27_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG27_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG27_IOMODE_INV                                      0x01000000
#define IOC_IOCFG27_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG27_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG27_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG27_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG27_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG27_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG27_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG27_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG27_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG27_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG27_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG27_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG27_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG27_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG27_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG27_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG27_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG27_EDGE_DET_W                                               2
#define IOC_IOCFG27_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG27_EDGE_DET_S                                              16
#define IOC_IOCFG27_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG27_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG27_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG27_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG27_PULL_CTL_W                                               2
#define IOC_IOCFG27_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG27_PULL_CTL_S                                              13
#define IOC_IOCFG27_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG27_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG27_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG27_SLEW_RED                                        0x00001000
#define IOC_IOCFG27_SLEW_RED_BITN                                           12
#define IOC_IOCFG27_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG27_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG27_IOCURR_W                                                 2
#define IOC_IOCFG27_IOCURR_M                                        0x00000C00
#define IOC_IOCFG27_IOCURR_S                                                10
#define IOC_IOCFG27_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG27_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG27_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG27_IOSTR_W                                                  2
#define IOC_IOCFG27_IOSTR_M                                         0x00000300
#define IOC_IOCFG27_IOSTR_S                                                  8
#define IOC_IOCFG27_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG27_IOSTR_MED                                       0x00000200
#define IOC_IOCFG27_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG27_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG27_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG27_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG27_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG27_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG27_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG27_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG27_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG27_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO27
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG27_PORT_ID_W                                                6
#define IOC_IOCFG27_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG27_PORT_ID_S                                                0
#define IOC_IOCFG27_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG27_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG27_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG27_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG27_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG27_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG27_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG27_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG27_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG27_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG27_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG27_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG27_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG27_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG27_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG27_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG27_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG27_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG27_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG27_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG27_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG27_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG27_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG27_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG27_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG27_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG27_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG27_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG27_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG27_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG27_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG27_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG27_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG27_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG27_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG27_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG27_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG27_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG27_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG27_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG27_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG27_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG27_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG27_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG27_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG27_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG28
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG28_HYST_EN                                         0x40000000
#define IOC_IOCFG28_HYST_EN_BITN                                            30
#define IOC_IOCFG28_HYST_EN_M                                       0x40000000
#define IOC_IOCFG28_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG28_IE                                              0x20000000
#define IOC_IOCFG28_IE_BITN                                                 29
#define IOC_IOCFG28_IE_M                                            0x20000000
#define IOC_IOCFG28_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG28_WU_CFG_W                                                 2
#define IOC_IOCFG28_WU_CFG_M                                        0x18000000
#define IOC_IOCFG28_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG28_IOMODE_W                                                 3
#define IOC_IOCFG28_IOMODE_M                                        0x07000000
#define IOC_IOCFG28_IOMODE_S                                                24
#define IOC_IOCFG28_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG28_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG28_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG28_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG28_IOMODE_INV                                      0x01000000
#define IOC_IOCFG28_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG28_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG28_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG28_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG28_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG28_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG28_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG28_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG28_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG28_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG28_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG28_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG28_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG28_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG28_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG28_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG28_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG28_EDGE_DET_W                                               2
#define IOC_IOCFG28_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG28_EDGE_DET_S                                              16
#define IOC_IOCFG28_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG28_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG28_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG28_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG28_PULL_CTL_W                                               2
#define IOC_IOCFG28_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG28_PULL_CTL_S                                              13
#define IOC_IOCFG28_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG28_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG28_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG28_SLEW_RED                                        0x00001000
#define IOC_IOCFG28_SLEW_RED_BITN                                           12
#define IOC_IOCFG28_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG28_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG28_IOCURR_W                                                 2
#define IOC_IOCFG28_IOCURR_M                                        0x00000C00
#define IOC_IOCFG28_IOCURR_S                                                10
#define IOC_IOCFG28_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG28_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG28_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG28_IOSTR_W                                                  2
#define IOC_IOCFG28_IOSTR_M                                         0x00000300
#define IOC_IOCFG28_IOSTR_S                                                  8
#define IOC_IOCFG28_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG28_IOSTR_MED                                       0x00000200
#define IOC_IOCFG28_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG28_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG28_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG28_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG28_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG28_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG28_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG28_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG28_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG28_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO28
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG28_PORT_ID_W                                                6
#define IOC_IOCFG28_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG28_PORT_ID_S                                                0
#define IOC_IOCFG28_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG28_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG28_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG28_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG28_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG28_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG28_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG28_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG28_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG28_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG28_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG28_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG28_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG28_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG28_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG28_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG28_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG28_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG28_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG28_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG28_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG28_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG28_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG28_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG28_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG28_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG28_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG28_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG28_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG28_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG28_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG28_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG28_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG28_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG28_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG28_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG28_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG28_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG28_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG28_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG28_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG28_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG28_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG28_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG28_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG28_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG29
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG29_HYST_EN                                         0x40000000
#define IOC_IOCFG29_HYST_EN_BITN                                            30
#define IOC_IOCFG29_HYST_EN_M                                       0x40000000
#define IOC_IOCFG29_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG29_IE                                              0x20000000
#define IOC_IOCFG29_IE_BITN                                                 29
#define IOC_IOCFG29_IE_M                                            0x20000000
#define IOC_IOCFG29_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG29_WU_CFG_W                                                 2
#define IOC_IOCFG29_WU_CFG_M                                        0x18000000
#define IOC_IOCFG29_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG29_IOMODE_W                                                 3
#define IOC_IOCFG29_IOMODE_M                                        0x07000000
#define IOC_IOCFG29_IOMODE_S                                                24
#define IOC_IOCFG29_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG29_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG29_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG29_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG29_IOMODE_INV                                      0x01000000
#define IOC_IOCFG29_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG29_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG29_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG29_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG29_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG29_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG29_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG29_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG29_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG29_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG29_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG29_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG29_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG29_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG29_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG29_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG29_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG29_EDGE_DET_W                                               2
#define IOC_IOCFG29_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG29_EDGE_DET_S                                              16
#define IOC_IOCFG29_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG29_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG29_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG29_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG29_PULL_CTL_W                                               2
#define IOC_IOCFG29_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG29_PULL_CTL_S                                              13
#define IOC_IOCFG29_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG29_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG29_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG29_SLEW_RED                                        0x00001000
#define IOC_IOCFG29_SLEW_RED_BITN                                           12
#define IOC_IOCFG29_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG29_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG29_IOCURR_W                                                 2
#define IOC_IOCFG29_IOCURR_M                                        0x00000C00
#define IOC_IOCFG29_IOCURR_S                                                10
#define IOC_IOCFG29_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG29_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG29_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG29_IOSTR_W                                                  2
#define IOC_IOCFG29_IOSTR_M                                         0x00000300
#define IOC_IOCFG29_IOSTR_S                                                  8
#define IOC_IOCFG29_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG29_IOSTR_MED                                       0x00000200
#define IOC_IOCFG29_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG29_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG29_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG29_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG29_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG29_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG29_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG29_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG29_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG29_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO29
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG29_PORT_ID_W                                                6
#define IOC_IOCFG29_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG29_PORT_ID_S                                                0
#define IOC_IOCFG29_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG29_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG29_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG29_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG29_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG29_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG29_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG29_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG29_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG29_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG29_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG29_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG29_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG29_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG29_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG29_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG29_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG29_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG29_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG29_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG29_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG29_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG29_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG29_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG29_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG29_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG29_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG29_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG29_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG29_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG29_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG29_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG29_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG29_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG29_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG29_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG29_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG29_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG29_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG29_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG29_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG29_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG29_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG29_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG29_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG29_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG30
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG30_HYST_EN                                         0x40000000
#define IOC_IOCFG30_HYST_EN_BITN                                            30
#define IOC_IOCFG30_HYST_EN_M                                       0x40000000
#define IOC_IOCFG30_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG30_IE                                              0x20000000
#define IOC_IOCFG30_IE_BITN                                                 29
#define IOC_IOCFG30_IE_M                                            0x20000000
#define IOC_IOCFG30_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG30_WU_CFG_W                                                 2
#define IOC_IOCFG30_WU_CFG_M                                        0x18000000
#define IOC_IOCFG30_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG30_IOMODE_W                                                 3
#define IOC_IOCFG30_IOMODE_M                                        0x07000000
#define IOC_IOCFG30_IOMODE_S                                                24
#define IOC_IOCFG30_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG30_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG30_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG30_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG30_IOMODE_INV                                      0x01000000
#define IOC_IOCFG30_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG30_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG30_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG30_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG30_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG30_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG30_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG30_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG30_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG30_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG30_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG30_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG30_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG30_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG30_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG30_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG30_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG30_EDGE_DET_W                                               2
#define IOC_IOCFG30_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG30_EDGE_DET_S                                              16
#define IOC_IOCFG30_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG30_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG30_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG30_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG30_PULL_CTL_W                                               2
#define IOC_IOCFG30_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG30_PULL_CTL_S                                              13
#define IOC_IOCFG30_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG30_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG30_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG30_SLEW_RED                                        0x00001000
#define IOC_IOCFG30_SLEW_RED_BITN                                           12
#define IOC_IOCFG30_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG30_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG30_IOCURR_W                                                 2
#define IOC_IOCFG30_IOCURR_M                                        0x00000C00
#define IOC_IOCFG30_IOCURR_S                                                10
#define IOC_IOCFG30_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG30_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG30_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG30_IOSTR_W                                                  2
#define IOC_IOCFG30_IOSTR_M                                         0x00000300
#define IOC_IOCFG30_IOSTR_S                                                  8
#define IOC_IOCFG30_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG30_IOSTR_MED                                       0x00000200
#define IOC_IOCFG30_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG30_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG30_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG30_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG30_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG30_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG30_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG30_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG30_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG30_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO30
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG30_PORT_ID_W                                                6
#define IOC_IOCFG30_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG30_PORT_ID_S                                                0
#define IOC_IOCFG30_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG30_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG30_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG30_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG30_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG30_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG30_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG30_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG30_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG30_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG30_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG30_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG30_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG30_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG30_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG30_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG30_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG30_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG30_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG30_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG30_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG30_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG30_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG30_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG30_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG30_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG30_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG30_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG30_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG30_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG30_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG30_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG30_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG30_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG30_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG30_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG30_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG30_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG30_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG30_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG30_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG30_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG30_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG30_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG30_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG30_PORT_ID_GPIO                                    0x00000000

//*****************************************************************************
//
// Register: IOC_O_IOCFG31
//
//*****************************************************************************
// Field:    [30] HYST_EN
//
// 0: Input hysteresis disable
// 1: Input hysteresis enable
#define IOC_IOCFG31_HYST_EN                                         0x40000000
#define IOC_IOCFG31_HYST_EN_BITN                                            30
#define IOC_IOCFG31_HYST_EN_M                                       0x40000000
#define IOC_IOCFG31_HYST_EN_S                                               30

// Field:    [29] IE
//
// 0: Input disabled
// 1: Input enabled
//
// Note: If IO is configured for AUX   PORT_ID = 0x08, the enable will be
// ignored.
#define IOC_IOCFG31_IE                                              0x20000000
#define IOC_IOCFG31_IE_BITN                                                 29
#define IOC_IOCFG31_IE_M                                            0x20000000
#define IOC_IOCFG31_IE_S                                                    29

// Field: [28:27] WU_CFG
//
// If DIO is configured GPIO or non-AON peripheral signals,  PORT_ID 0x00 or
// >0x08:
//
// 00: No wake-up
// 01: No wake-up
// 10: Wakes up from shutdown if this pad is going low.
// 11: Wakes up from shutdown if this pad is going high.
//
// If IO is configured for AON peripheral signals or AUX   PORT_ID 0x01-0x08,
// this register only sets wakeup enable or not.
//
// 00, 01: Wakeup disabled
// 10, 11: Wakeup enabled
//
// Polarity is controlled from AON registers.
//
// Note:When the MSB is set, the IOC will deactivate the output enable for the
// DIO.
#define IOC_IOCFG31_WU_CFG_W                                                 2
#define IOC_IOCFG31_WU_CFG_M                                        0x18000000
#define IOC_IOCFG31_WU_CFG_S                                                27

// Field: [26:24] IOMODE
//
// IO Mode
// Not applicable for IO configured for AON periph. signals and AUX   PORT_ID
// 0x01-0x08
// AUX has its own open_source/drain configuration.
//
// 0x2: Reserved. Undefined behavior.
// 0x3: Reserved. Undefined behavior.
// ENUMs:
// OPENSRC_INV              Open Source
//                          Inverted input / output
// OPENSRC                  Open Source
//                          Normal input / output
// OPENDR_INV               Open Drain
//                          Inverted input / output
// OPENDR                   Open Drain,
//                          Normal input / output
// INV                      Inverted input / ouput
// NORMAL                   Normal input / output
#define IOC_IOCFG31_IOMODE_W                                                 3
#define IOC_IOCFG31_IOMODE_M                                        0x07000000
#define IOC_IOCFG31_IOMODE_S                                                24
#define IOC_IOCFG31_IOMODE_OPENSRC_INV                              0x07000000
#define IOC_IOCFG31_IOMODE_OPENSRC                                  0x06000000
#define IOC_IOCFG31_IOMODE_OPENDR_INV                               0x05000000
#define IOC_IOCFG31_IOMODE_OPENDR                                   0x04000000
#define IOC_IOCFG31_IOMODE_INV                                      0x01000000
#define IOC_IOCFG31_IOMODE_NORMAL                                   0x00000000

// Field:    [23] IOEV_AON_PROG2_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG2 event
// 1: Input edge detection asserts AON_PROG2 event
#define IOC_IOCFG31_IOEV_AON_PROG2_EN                               0x00800000
#define IOC_IOCFG31_IOEV_AON_PROG2_EN_BITN                                  23
#define IOC_IOCFG31_IOEV_AON_PROG2_EN_M                             0x00800000
#define IOC_IOCFG31_IOEV_AON_PROG2_EN_S                                     23

// Field:    [22] IOEV_AON_PROG1_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG1 event
// 1: Input edge detection asserts AON_PROG1 event
#define IOC_IOCFG31_IOEV_AON_PROG1_EN                               0x00400000
#define IOC_IOCFG31_IOEV_AON_PROG1_EN_BITN                                  22
#define IOC_IOCFG31_IOEV_AON_PROG1_EN_M                             0x00400000
#define IOC_IOCFG31_IOEV_AON_PROG1_EN_S                                     22

// Field:    [21] IOEV_AON_PROG0_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert AON_PROG0 event
// 1: Input edge detection asserts AON_PROG0 event
#define IOC_IOCFG31_IOEV_AON_PROG0_EN                               0x00200000
#define IOC_IOCFG31_IOEV_AON_PROG0_EN_BITN                                  21
#define IOC_IOCFG31_IOEV_AON_PROG0_EN_M                             0x00200000
#define IOC_IOCFG31_IOEV_AON_PROG0_EN_S                                     21

// Field:    [18] EDGE_IRQ_EN
//
// 0: No interrupt generation
// 1: Enable interrupt generation for this IO (Only effective if EDGE_DET is
// enabled)
#define IOC_IOCFG31_EDGE_IRQ_EN                                     0x00040000
#define IOC_IOCFG31_EDGE_IRQ_EN_BITN                                        18
#define IOC_IOCFG31_EDGE_IRQ_EN_M                                   0x00040000
#define IOC_IOCFG31_EDGE_IRQ_EN_S                                           18

// Field: [17:16] EDGE_DET
//
// Enable generation of edge detection events on this IO
// ENUMs:
// BOTH                     Positive and negative edge detection
// POS                      Positive edge detection
// NEG                      Negative edge detection
// NONE                     No edge detection
#define IOC_IOCFG31_EDGE_DET_W                                               2
#define IOC_IOCFG31_EDGE_DET_M                                      0x00030000
#define IOC_IOCFG31_EDGE_DET_S                                              16
#define IOC_IOCFG31_EDGE_DET_BOTH                                   0x00030000
#define IOC_IOCFG31_EDGE_DET_POS                                    0x00020000
#define IOC_IOCFG31_EDGE_DET_NEG                                    0x00010000
#define IOC_IOCFG31_EDGE_DET_NONE                                   0x00000000

// Field: [14:13] PULL_CTL
//
// Pull control
// ENUMs:
// DIS                      No pull
// UP                       Pull up
// DWN                      Pull down
#define IOC_IOCFG31_PULL_CTL_W                                               2
#define IOC_IOCFG31_PULL_CTL_M                                      0x00006000
#define IOC_IOCFG31_PULL_CTL_S                                              13
#define IOC_IOCFG31_PULL_CTL_DIS                                    0x00006000
#define IOC_IOCFG31_PULL_CTL_UP                                     0x00004000
#define IOC_IOCFG31_PULL_CTL_DWN                                    0x00002000

// Field:    [12] SLEW_RED
//
// 0: Normal slew rate
// 1: Enables reduced slew rate in output driver.
#define IOC_IOCFG31_SLEW_RED                                        0x00001000
#define IOC_IOCFG31_SLEW_RED_BITN                                           12
#define IOC_IOCFG31_SLEW_RED_M                                      0x00001000
#define IOC_IOCFG31_SLEW_RED_S                                              12

// Field: [11:10] IOCURR
//
// Selects IO current mode of this IO.
// ENUMs:
// 4_8MA                    Extended-Current (EC) mode: Min 8 mA for double
//                          drive strength IOs (min 4 mA for normal IOs)
//                          when IOSTR is set to AUTO
// 4MA                      High-Current (HC) mode: Min 4 mA when IOSTR is set
//                          to AUTO
// 2MA                      Low-Current (LC) mode: Min 2 mA when IOSTR is set
//                          to AUTO
#define IOC_IOCFG31_IOCURR_W                                                 2
#define IOC_IOCFG31_IOCURR_M                                        0x00000C00
#define IOC_IOCFG31_IOCURR_S                                                10
#define IOC_IOCFG31_IOCURR_4_8MA                                    0x00000800
#define IOC_IOCFG31_IOCURR_4MA                                      0x00000400
#define IOC_IOCFG31_IOCURR_2MA                                      0x00000000

// Field:   [9:8] IOSTR
//
// Select source for drive strength control of this IO.
// This setting controls the drive strength of the Low-Current (LC) mode.
// Higher drive strength can be selected in IOCURR
// ENUMs:
// MAX                      Maximum drive strength, controlled by
//                          AON_IOC:IOSTRMAX (min 2 mA @1.8V with default
//                          values)
// MED                      Medium drive strength, controlled by
//                          AON_IOC:IOSTRMED (min 2 mA @2.5V with default
//                          values)
// MIN                      Minimum drive strength, controlled by
//                          AON_IOC:IOSTRMIN (min 2 mA @3.3V with default
//                          values)
// AUTO                     Automatic drive strength, controlled by AON BATMON
//                          based on battery voltage. (min 2 mA @VDDS)
#define IOC_IOCFG31_IOSTR_W                                                  2
#define IOC_IOCFG31_IOSTR_M                                         0x00000300
#define IOC_IOCFG31_IOSTR_S                                                  8
#define IOC_IOCFG31_IOSTR_MAX                                       0x00000300
#define IOC_IOCFG31_IOSTR_MED                                       0x00000200
#define IOC_IOCFG31_IOSTR_MIN                                       0x00000100
#define IOC_IOCFG31_IOSTR_AUTO                                      0x00000000

// Field:     [7] IOEV_RTC_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert RTC event
// 1: Input edge detection asserts RTC event
#define IOC_IOCFG31_IOEV_RTC_EN                                     0x00000080
#define IOC_IOCFG31_IOEV_RTC_EN_BITN                                         7
#define IOC_IOCFG31_IOEV_RTC_EN_M                                   0x00000080
#define IOC_IOCFG31_IOEV_RTC_EN_S                                            7

// Field:     [6] IOEV_MCU_WU_EN
//
// Event asserted by this IO when edge detection is enabled
//
// 0: Input edge detection does not assert MCU_WU event
// 1: Input edge detection asserts MCU_WU event
#define IOC_IOCFG31_IOEV_MCU_WU_EN                                  0x00000040
#define IOC_IOCFG31_IOEV_MCU_WU_EN_BITN                                      6
#define IOC_IOCFG31_IOEV_MCU_WU_EN_M                                0x00000040
#define IOC_IOCFG31_IOEV_MCU_WU_EN_S                                         6

// Field:   [5:0] PORT_ID
//
// Selects usage for DIO31
// ENUMs:
// RFC_SMI_CL_IN            RF Core SMI Command Link In
// RFC_SMI_CL_OUT           RF Core SMI Command Link Out
// RFC_SMI_DL_IN            RF Core SMI Data Link In
// RFC_SMI_DL_OUT           RF Core SMI Data Link Out
// RFC_GPI1                 RF Core Data In 1
// RFC_GPI0                 RF Core Data In 0
// RFC_GPO3                 RF Core Data Out 3
// RFC_GPO2                 RF Core Data Out 2
// RFC_GPO1                 RF Core Data Out 1
// RFC_GPO0                 RF Core Data Out 0
// RFC_TRC                  RF Core Trace
// I2S_MCLK                 I2S MCLK
// I2S_BCLK                 I2S BCLK
// I2S_WCLK                 I2S WCLK
// I2S_AD1                  I2S Data 1
// I2S_AD0                  I2S Data 0
// SSI1_CLK                 SSI1 CLK
// SSI1_FSS                 SSI1 FSS
// SSI1_TX                  SSI1 TX
// SSI1_RX                  SSI1 RX
// CPU_SWV                  CPU SWV
// PORT_EVENT7              PORT EVENT 7
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT6              PORT EVENT 6
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT5              PORT EVENT 5
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT4              PORT EVENT 4
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT3              PORT EVENT 3
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT2              PORT EVENT 2
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT1              PORT EVENT 1
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// PORT_EVENT0              PORT EVENT 0
//                          Can be used as a general
//                          purpose IO event by selecting it through
//                          registers in the EVENT module, for example
//                          EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV,
//                          and so on
// UART1_RTS                UART1 RTS
// UART1_CTS                UART1 CTS
// UART1_TX                 UART1 TX
// UART1_RX                 UART1 RX
// UART0_RTS                UART0 RTS
// UART0_CTS                UART0 CTS
// UART0_TX                 UART0 TX
// UART0_RX                 UART0 RX
// I2C_MSSCL                I2C Clock
// I2C_MSSDA                I2C Data
// SSI0_CLK                 SSI0 CLK
// SSI0_FSS                 SSI0 FSS
// SSI0_TX                  SSI0 TX
// SSI0_RX                  SSI0 RX
// AUX_IO                   AUX IO
// AON_CLK32K               AON 32 KHz clock (SCLK_LF)
// GPIO                     General Purpose IO
#define IOC_IOCFG31_PORT_ID_W                                                6
#define IOC_IOCFG31_PORT_ID_M                                       0x0000003F
#define IOC_IOCFG31_PORT_ID_S                                                0
#define IOC_IOCFG31_PORT_ID_RFC_SMI_CL_IN                           0x00000038
#define IOC_IOCFG31_PORT_ID_RFC_SMI_CL_OUT                          0x00000037
#define IOC_IOCFG31_PORT_ID_RFC_SMI_DL_IN                           0x00000036
#define IOC_IOCFG31_PORT_ID_RFC_SMI_DL_OUT                          0x00000035
#define IOC_IOCFG31_PORT_ID_RFC_GPI1                                0x00000034
#define IOC_IOCFG31_PORT_ID_RFC_GPI0                                0x00000033
#define IOC_IOCFG31_PORT_ID_RFC_GPO3                                0x00000032
#define IOC_IOCFG31_PORT_ID_RFC_GPO2                                0x00000031
#define IOC_IOCFG31_PORT_ID_RFC_GPO1                                0x00000030
#define IOC_IOCFG31_PORT_ID_RFC_GPO0                                0x0000002F
#define IOC_IOCFG31_PORT_ID_RFC_TRC                                 0x0000002E
#define IOC_IOCFG31_PORT_ID_I2S_MCLK                                0x00000029
#define IOC_IOCFG31_PORT_ID_I2S_BCLK                                0x00000028
#define IOC_IOCFG31_PORT_ID_I2S_WCLK                                0x00000027
#define IOC_IOCFG31_PORT_ID_I2S_AD1                                 0x00000026
#define IOC_IOCFG31_PORT_ID_I2S_AD0                                 0x00000025
#define IOC_IOCFG31_PORT_ID_SSI1_CLK                                0x00000024
#define IOC_IOCFG31_PORT_ID_SSI1_FSS                                0x00000023
#define IOC_IOCFG31_PORT_ID_SSI1_TX                                 0x00000022
#define IOC_IOCFG31_PORT_ID_SSI1_RX                                 0x00000021
#define IOC_IOCFG31_PORT_ID_CPU_SWV                                 0x00000020
#define IOC_IOCFG31_PORT_ID_PORT_EVENT7                             0x0000001E
#define IOC_IOCFG31_PORT_ID_PORT_EVENT6                             0x0000001D
#define IOC_IOCFG31_PORT_ID_PORT_EVENT5                             0x0000001C
#define IOC_IOCFG31_PORT_ID_PORT_EVENT4                             0x0000001B
#define IOC_IOCFG31_PORT_ID_PORT_EVENT3                             0x0000001A
#define IOC_IOCFG31_PORT_ID_PORT_EVENT2                             0x00000019
#define IOC_IOCFG31_PORT_ID_PORT_EVENT1                             0x00000018
#define IOC_IOCFG31_PORT_ID_PORT_EVENT0                             0x00000017
#define IOC_IOCFG31_PORT_ID_UART1_RTS                               0x00000016
#define IOC_IOCFG31_PORT_ID_UART1_CTS                               0x00000015
#define IOC_IOCFG31_PORT_ID_UART1_TX                                0x00000014
#define IOC_IOCFG31_PORT_ID_UART1_RX                                0x00000013
#define IOC_IOCFG31_PORT_ID_UART0_RTS                               0x00000012
#define IOC_IOCFG31_PORT_ID_UART0_CTS                               0x00000011
#define IOC_IOCFG31_PORT_ID_UART0_TX                                0x00000010
#define IOC_IOCFG31_PORT_ID_UART0_RX                                0x0000000F
#define IOC_IOCFG31_PORT_ID_I2C_MSSCL                               0x0000000E
#define IOC_IOCFG31_PORT_ID_I2C_MSSDA                               0x0000000D
#define IOC_IOCFG31_PORT_ID_SSI0_CLK                                0x0000000C
#define IOC_IOCFG31_PORT_ID_SSI0_FSS                                0x0000000B
#define IOC_IOCFG31_PORT_ID_SSI0_TX                                 0x0000000A
#define IOC_IOCFG31_PORT_ID_SSI0_RX                                 0x00000009
#define IOC_IOCFG31_PORT_ID_AUX_IO                                  0x00000008
#define IOC_IOCFG31_PORT_ID_AON_CLK32K                              0x00000007
#define IOC_IOCFG31_PORT_ID_GPIO                                    0x00000000

#endif // __HW_IOC_H__

#ifndef __HW_UDMA_H__
#define __HW_UDMA_H__

//*****************************************************************************
//
// This section defines the register offsets of
// UDMA component
//
//*****************************************************************************
// Status
#define UDMA_O_STATUS                                               0x00000000

// Configuration
#define UDMA_O_CFG                                                  0x00000004

// Channel Control Data Base Pointer
#define UDMA_O_CTRL                                                 0x00000008

// Channel Alternate Control Data Base Pointer
#define UDMA_O_ALTCTRL                                              0x0000000C

// Channel Wait On Request Status
#define UDMA_O_WAITONREQ                                            0x00000010

// Channel Software Request
#define UDMA_O_SOFTREQ                                              0x00000014

// Channel Set UseBurst
#define UDMA_O_SETBURST                                             0x00000018

// Channel Clear UseBurst
#define UDMA_O_CLEARBURST                                           0x0000001C

// Channel Set Request Mask
#define UDMA_O_SETREQMASK                                           0x00000020

// Clear Channel Request Mask
#define UDMA_O_CLEARREQMASK                                         0x00000024

// Set Channel Enable
#define UDMA_O_SETCHANNELEN                                         0x00000028

// Clear Channel Enable
#define UDMA_O_CLEARCHANNELEN                                       0x0000002C

// Channel Set Primary-Alternate
#define UDMA_O_SETCHNLPRIALT                                        0x00000030

// Channel Clear Primary-Alternate
#define UDMA_O_CLEARCHNLPRIALT                                      0x00000034

// Set Channel Priority
#define UDMA_O_SETCHNLPRIORITY                                      0x00000038

// Clear Channel Priority
#define UDMA_O_CLEARCHNLPRIORITY                                    0x0000003C

// Error Status and Clear
#define UDMA_O_ERROR                                                0x0000004C

// Channel Request Done
#define UDMA_O_REQDONE                                              0x00000504

// Channel Request Done Mask
#define UDMA_O_DONEMASK                                             0x00000520

//*****************************************************************************
//
// Register: UDMA_O_STATUS
//
//*****************************************************************************
// Field: [31:28] TEST
//
//
// 0x0: Controller does not include the integration test logic
// 0x1: Controller includes the integration test logic
// 0x2: Undefined
// ...
// 0xF: Undefined
#define UDMA_STATUS_TEST_W                                                   4
#define UDMA_STATUS_TEST_M                                          0xF0000000
#define UDMA_STATUS_TEST_S                                                  28

// Field: [20:16] TOTALCHANNELS
//
// Register value returns number of available uDMA channels minus one. For
// example a read out value of:
//
// 0x00: Show that the controller is configured to use 1 uDMA channel
// 0x01: Shows that the controller is configured to use 2 uDMA channels
// ...
// 0x1F: Shows that the controller is configured to use 32 uDMA channels
// (32-1=31=0x1F)
#define UDMA_STATUS_TOTALCHANNELS_W                                          5
#define UDMA_STATUS_TOTALCHANNELS_M                                 0x001F0000
#define UDMA_STATUS_TOTALCHANNELS_S                                         16

// Field:   [7:4] STATE
//
// Current state of the control state machine. State can be one of the
// following:
//
// 0x0: Idle
// 0x1: Reading channel controller data
// 0x2: Reading source data end pointer
// 0x3: Reading destination data end pointer
// 0x4: Reading source data
// 0x5: Writing destination data
// 0x6: Waiting for uDMA request to clear
// 0x7: Writing channel controller data
// 0x8: Stalled
// 0x9: Done
// 0xA: Peripheral scatter-gather transition
// 0xB: Undefined
// ...
// 0xF: Undefined.
#define UDMA_STATUS_STATE_W                                                  4
#define UDMA_STATUS_STATE_M                                         0x000000F0
#define UDMA_STATUS_STATE_S                                                  4

// Field:     [0] MASTERENABLE
//
// Shows the enable status of the controller as configured by CFG.MASTERENABLE:
//
// 0: Controller is disabled
// 1: Controller is enabled
#define UDMA_STATUS_MASTERENABLE                                    0x00000001
#define UDMA_STATUS_MASTERENABLE_BITN                                        0
#define UDMA_STATUS_MASTERENABLE_M                                  0x00000001
#define UDMA_STATUS_MASTERENABLE_S                                           0

//*****************************************************************************
//
// Register: UDMA_O_CFG
//
//*****************************************************************************
// Field:   [7:5] PRTOCTRL
//
// Sets the AHB-Lite bus protocol protection state by controlling the AHB
// signal HProt[3:1] as follows:
//
// Bit [7] Controls HProt[3] to indicate if a cacheable access is occurring.
// Bit [6] Controls HProt[2] to indicate if a bufferable access is occurring.
// Bit [5] Controls HProt[1] to indicate if a privileged access is occurring.
//
// When bit [n] = 1 then the corresponding HProt bit is high.
// When bit [n] = 0 then the corresponding HProt bit is low.
//
// This field controls HProt[3:1] signal for all transactions initiated by uDMA
// except two transactions below:
// - the read from the address indicated by source address pointer
// - the write to the address indicated by destination address pointer
// HProt[3:1] for these two exceptions can be controlled by dedicated fields in
// the channel configutation descriptor.
#define UDMA_CFG_PRTOCTRL_W                                                  3
#define UDMA_CFG_PRTOCTRL_M                                         0x000000E0
#define UDMA_CFG_PRTOCTRL_S                                                  5

// Field:     [0] MASTERENABLE
//
// Enables the controller:
//
// 0: Disables the controller
// 1: Enables the controller
#define UDMA_CFG_MASTERENABLE                                       0x00000001
#define UDMA_CFG_MASTERENABLE_BITN                                           0
#define UDMA_CFG_MASTERENABLE_M                                     0x00000001
#define UDMA_CFG_MASTERENABLE_S                                              0

//*****************************************************************************
//
// Register: UDMA_O_CTRL
//
//*****************************************************************************
// Field: [31:10] BASEPTR
//
// This register point to the base address for the primary data structures of
// each DMA channel. This is not stored in module, but in system memory, thus
// space must be allocated for this usage when DMA is in usage
#define UDMA_CTRL_BASEPTR_W                                                 22
#define UDMA_CTRL_BASEPTR_M                                         0xFFFFFC00
#define UDMA_CTRL_BASEPTR_S                                                 10

//*****************************************************************************
//
// Register: UDMA_O_ALTCTRL
//
//*****************************************************************************
// Field:  [31:0] BASEPTR
//
// This register shows the base address for the alternate data structures and
// is calculated by module, thus read only
#define UDMA_ALTCTRL_BASEPTR_W                                              32
#define UDMA_ALTCTRL_BASEPTR_M                                      0xFFFFFFFF
#define UDMA_ALTCTRL_BASEPTR_S                                               0

//*****************************************************************************
//
// Register: UDMA_O_WAITONREQ
//
//*****************************************************************************
// Field:  [31:0] CHNLSTATUS
//
// Channel wait on request status:
//
// Bit [Ch] = 0: Once uDMA receives a single or burst request on channel Ch,
// this channel may come out of active state even if request is still present.
// Bit [Ch] = 1: Once uDMA receives a single or burst request on channel Ch, it
// keeps channel Ch in active state until the requests are deasserted. This
// handshake is necessary for channels where the requester is in an
// asynchronous domain or can run at slower clock speed than uDMA
#define UDMA_WAITONREQ_CHNLSTATUS_W                                         32
#define UDMA_WAITONREQ_CHNLSTATUS_M                                 0xFFFFFFFF
#define UDMA_WAITONREQ_CHNLSTATUS_S                                          0

//*****************************************************************************
//
// Register: UDMA_O_SOFTREQ
//
//*****************************************************************************
// Field:  [31:0] CHNLS
//
// Set the appropriate bit to generate a software uDMA request on the
// corresponding uDMA channel
//
// Bit [Ch] = 0: Does not create a uDMA request for channel Ch
// Bit [Ch] = 1: Creates a uDMA request for channel Ch
//
// Writing to a bit where a uDMA channel is not implemented does not create a
// uDMA request for that channel
#define UDMA_SOFTREQ_CHNLS_W                                                32
#define UDMA_SOFTREQ_CHNLS_M                                        0xFFFFFFFF
#define UDMA_SOFTREQ_CHNLS_S                                                 0

//*****************************************************************************
//
// Register: UDMA_O_SETBURST
//
//*****************************************************************************
// Field:  [31:0] CHNLS
//
// Returns the useburst status, or disables individual channels from generating
// single uDMA requests. The value R is the arbitration rate and stored in the
// controller data structure.
//
// Read as:
//
// Bit [Ch] = 0: uDMA channel Ch responds to both burst and single requests on
// channel C. The controller performs 2^R, or single, bus transfers.
//
// Bit [Ch] = 1: uDMA channel Ch does not respond to single transfer requests.
// The controller only responds to burst transfer requests and performs 2^R
// transfers.
//
// Write as:
// Bit [Ch] = 0: No effect. Use the CLEARBURST.CHNLS to set bit [Ch] to 0.
// Bit [Ch] = 1: Disables single transfer requests on channel Ch. The
// controller performs 2^R transfers for burst requests.
//
// Writing to a bit where a uDMA channel is not implemented has no effect
#define UDMA_SETBURST_CHNLS_W                                               32
#define UDMA_SETBURST_CHNLS_M                                       0xFFFFFFFF
#define UDMA_SETBURST_CHNLS_S                                                0

//*****************************************************************************
//
// Register: UDMA_O_CLEARBURST
//
//*****************************************************************************
// Field:  [31:0] CHNLS
//
// Set the appropriate bit to enable single transfer requests.
//
// Write as:
//
// Bit [Ch] = 0: No effect. Use the SETBURST.CHNLS to disable single transfer
// requests.
//
// Bit [Ch] = 1: Enables single transfer requests on channel Ch.
//
// Writing to a bit where a DMA channel is not implemented has no effect.
#define UDMA_CLEARBURST_CHNLS_W                                             32
#define UDMA_CLEARBURST_CHNLS_M                                     0xFFFFFFFF
#define UDMA_CLEARBURST_CHNLS_S                                              0

//*****************************************************************************
//
// Register: UDMA_O_SETREQMASK
//
//*****************************************************************************
// Field:  [31:0] CHNLS
//
// Returns the burst and single request mask status, or disables the
// corresponding channel from generating uDMA requests.
//
// Read as:
// Bit [Ch] = 0: External requests are enabled for channel Ch.
// Bit [Ch] = 1: External requests are disabled for channel Ch.
//
// Write as:
// Bit [Ch] = 0: No effect. Use the CLEARREQMASK.CHNLS to enable uDMA requests.
// Bit [Ch] = 1: Disables uDMA burst request channel [C] and uDMA single
// request channel [C] input from generating uDMA requests.
//
// Writing to a bit where a uDMA channel is not implemented has no effect
#define UDMA_SETREQMASK_CHNLS_W                                             32
#define UDMA_SETREQMASK_CHNLS_M                                     0xFFFFFFFF
#define UDMA_SETREQMASK_CHNLS_S                                              0

//*****************************************************************************
//
// Register: UDMA_O_CLEARREQMASK
//
//*****************************************************************************
// Field:  [31:0] CHNLS
//
// Set the appropriate bit to enable DMA request for the channel.
//
// Write as:
// Bit [Ch] = 0: No effect. Use the SETREQMASK.CHNLS to disable channel C from
// generating requests.
// Bit [Ch] = 1: Enables channel [C] to generate DMA requests.
//
// Writing to a bit where a DMA channel is not implemented has no effect.
#define UDMA_CLEARREQMASK_CHNLS_W                                           32
#define UDMA_CLEARREQMASK_CHNLS_M                                   0xFFFFFFFF
#define UDMA_CLEARREQMASK_CHNLS_S                                            0

//*****************************************************************************
//
// Register: UDMA_O_SETCHANNELEN
//
//*****************************************************************************
// Field:  [31:0] CHNLS
//
// Returns the enable status of the channels, or enables the corresponding
// channels.
//
// Read as:
// Bit [Ch] = 0: Channel Ch is disabled.
// Bit [Ch] = 1: Channel Ch is enabled.
//
// Write as:
// Bit [Ch] = 0: No effect. Use the CLEARCHANNELEN.CHNLS to disable a channel
// Bit [Ch] = 1: Enables channel Ch
//
// Writing to a bit where a DMA channel is not implemented has no effect
#define UDMA_SETCHANNELEN_CHNLS_W                                           32
#define UDMA_SETCHANNELEN_CHNLS_M                                   0xFFFFFFFF
#define UDMA_SETCHANNELEN_CHNLS_S                                            0

//*****************************************************************************
//
// Register: UDMA_O_CLEARCHANNELEN
//
//*****************************************************************************
// Field:  [31:0] CHNLS
//
// Set the appropriate bit to disable the corresponding uDMA channel.
//
// Write as:
// Bit [Ch] = 0: No effect. Use the SETCHANNELEN.CHNLS to enable uDMA channels.
// Bit [Ch] = 1: Disables channel Ch
//
// Writing to a bit where a uDMA channel is not implemented has no effect
#define UDMA_CLEARCHANNELEN_CHNLS_W                                         32
#define UDMA_CLEARCHANNELEN_CHNLS_M                                 0xFFFFFFFF
#define UDMA_CLEARCHANNELEN_CHNLS_S                                          0

//*****************************************************************************
//
// Register: UDMA_O_SETCHNLPRIALT
//
//*****************************************************************************
// Field:  [31:0] CHNLS
//
// Returns the channel control data structure status, or selects the alternate
// data structure for the corresponding uDMA channel.
//
// Read as:
// Bit [Ch] = 0: uDMA channel Ch is using the primary data structure.
// Bit [Ch] = 1: uDMA channel Ch is using the alternate data structure.
//
// Write as:
// Bit [Ch] = 0: No effect. Use the CLEARCHNLPRIALT.CHNLS to disable a channel
// Bit [Ch] = 1: Selects the alternate data structure for channel Ch
//
// Writing to a bit where a uDMA channel is not implemented has no effect
#define UDMA_SETCHNLPRIALT_CHNLS_W                                          32
#define UDMA_SETCHNLPRIALT_CHNLS_M                                  0xFFFFFFFF
#define UDMA_SETCHNLPRIALT_CHNLS_S                                           0

//*****************************************************************************
//
// Register: UDMA_O_CLEARCHNLPRIALT
//
//*****************************************************************************
// Field:  [31:0] CHNLS
//
// Clears the appropriate bit to select the primary data structure for the
// corresponding uDMA channel.
//
// Write as:
// Bit [Ch] = 0: No effect. Use the SETCHNLPRIALT.CHNLS to select the alternate
// data structure.
// Bit [Ch] = 1: Selects the primary data structure for channel Ch.
//
// Writing to a bit where a uDMA channel is not implemented has no effect
#define UDMA_CLEARCHNLPRIALT_CHNLS_W                                        32
#define UDMA_CLEARCHNLPRIALT_CHNLS_M                                0xFFFFFFFF
#define UDMA_CLEARCHNLPRIALT_CHNLS_S                                         0

//*****************************************************************************
//
// Register: UDMA_O_SETCHNLPRIORITY
//
//*****************************************************************************
// Field:  [31:0] CHNLS
//
// Returns the channel priority mask status, or sets the channel priority to
// high.
//
// Read as:
// Bit [Ch] = 0: uDMA channel Ch is using the default priority level.
// Bit [Ch] = 1: uDMA channel Ch is using a high priority level.
//
// Write as:
// Bit [Ch] = 0: No effect. Use the CLEARCHNLPRIORITY.CHNLS to set channel Ch
// to the default priority level.
// Bit [Ch] = 1: Channel Ch uses the high priority level.
//
// Writing to a bit where a uDMA channel is not implemented has no effect
#define UDMA_SETCHNLPRIORITY_CHNLS_W                                        32
#define UDMA_SETCHNLPRIORITY_CHNLS_M                                0xFFFFFFFF
#define UDMA_SETCHNLPRIORITY_CHNLS_S                                         0

//*****************************************************************************
//
// Register: UDMA_O_CLEARCHNLPRIORITY
//
//*****************************************************************************
// Field:  [31:0] CHNLS
//
// Clear the appropriate bit to select the default priority level for the
// specified uDMA channel.
//
// Write as:
// Bit [Ch] = 0: No effect. Use the SETCHNLPRIORITY.CHNLS to set channel Ch to
// the high priority level.
// Bit [Ch] = 1: Channel Ch uses the default priority level.
//
// Writing to a bit where a uDMA channel is not implemented has no effect
#define UDMA_CLEARCHNLPRIORITY_CHNLS_W                                      32
#define UDMA_CLEARCHNLPRIORITY_CHNLS_M                              0xFFFFFFFF
#define UDMA_CLEARCHNLPRIORITY_CHNLS_S                                       0

//*****************************************************************************
//
// Register: UDMA_O_ERROR
//
//*****************************************************************************
// Field:     [0] STATUS
//
// Returns the status of bus error flag in uDMA, or clears this bit
//
// Read as:
//
// 0: No bus error detected
// 1: Bus error detected
//
// Write as:
//
// 0: No effect, status of bus error flag is unchanged.
// 1: Clears the bus error flag.
#define UDMA_ERROR_STATUS                                           0x00000001
#define UDMA_ERROR_STATUS_BITN                                               0
#define UDMA_ERROR_STATUS_M                                         0x00000001
#define UDMA_ERROR_STATUS_S                                                  0

//*****************************************************************************
//
// Register: UDMA_O_REQDONE
//
//*****************************************************************************
// Field:  [31:0] CHNLS
//
// Reflects the uDMA done status for the given channel, channel [Ch]. It's a
// sticky done bit. Unless cleared by writing a 1, it holds the value of 1.
//
// Read as:
// Bit [Ch] = 0: Request has not completed for channel Ch
// Bit [Ch] = 1: Request has completed for the channel Ch
//
// Writing a 1 to individual bits would clear the corresponding bit.
//
// Write as:
// Bit [Ch] = 0: No effect.
// Bit [Ch] = 1: The corresponding [Ch] bit is cleared  and is set to 0
#define UDMA_REQDONE_CHNLS_W                                                32
#define UDMA_REQDONE_CHNLS_M                                        0xFFFFFFFF
#define UDMA_REQDONE_CHNLS_S                                                 0

//*****************************************************************************
//
// Register: UDMA_O_DONEMASK
//
//*****************************************************************************
// Field:  [31:0] CHNLS
//
// Controls the propagation of the uDMA done and active state to the assigned
// peripheral. Specifically used for software channels.
//
// Read as:
// Bit [Ch] = 0: uDMA done and active state for channel Ch is not blocked from
// reaching to the peripherals.
// Note that the uDMA done state for channel [Ch] is blocked from contributing
// to generation of combined uDMA done signal
//
// Bit [Ch] = 1: uDMA done and active state for channel Ch is blocked from
// reaching to the peripherals.
// Note that the uDMA done state for channel [Ch] is not blocked from
// contributing to generation of combined uDMA done signal
//
// Write as:
// Bit [Ch] = 0: Allows uDMA done and active stat to propagate to the
// peripherals.
// Note that this disables uDMA done state for channel [Ch] from contributing
// to generation of combined uDMA done signal
//
// Bit [Ch] = 1: Blocks uDMA done and active state to propagate to the
// peripherals.
// Note that this enables uDMA done for  channel [Ch] to contribute to
// generation of combined uDMA done signal.
#define UDMA_DONEMASK_CHNLS_W                                               32
#define UDMA_DONEMASK_CHNLS_M                                       0xFFFFFFFF
#define UDMA_DONEMASK_CHNLS_S                                                0
#endif // __HW_UDMA_H__

#ifndef __UDMA_H__
#define __UDMA_H__

typedef struct PACK_STRUCTURE {

    volatile void *pvSrcEndAddr;   //!< The ending source address of the data transfer.
    volatile void *pvDstEndAddr;   //!< The ending destination address of the data transfer.
    volatile uint32_t ui32Control; //!< The channel control mode.
    volatile uint32_t ui32Spare;   //!< An unused location.
	 
} tDMAControlTable;

//*****************************************************************************
//
//! \brief A helper macro for building scatter-gather task table entries.
//!
//! This macro is intended to be used to help populate a table of uDMA tasks
//! for a scatter-gather transfer. This macro will calculate the values for
//! the fields of a task structure entry based on the input parameters.
//!
//! There are specific requirements for the values of each parameter.  No
//! checking is done so it is up to the caller to ensure that correct values
//! are used for the parameters.
//!
//! This macro is intended to be used to initialize individual entries of
//! a structure of tDMAControlTable type, like this:
//!
/*!
\verbatim
  tDMAControlTable MyTaskList[] =
  {
      uDMATaskStructEntry(Task1Count, UDMA_SIZE_8,
                          UDMA_SRC_INC_8, MySourceBuf,
                          UDMA_DST_INC_8, MyDestBuf,
                          UDMA_ARB_8, UDMA_MODE_MEM_SCATTER_GATHER),
      uDMATaskStructEntry(Task2Count, ... ),
  }
\endverbatim
*/
//! \param ui32TransferCount is the count of items to transfer for this task.
//! It must be in the range 1-1024.
//! \param ui32ItemSize is the bit size of the items to transfer for this task.
//! It must be one of:
//! - \ref UDMA_SIZE_8
//! - \ref UDMA_SIZE_16
//! - \ref UDMA_SIZE_32
//! \param ui32SrcIncrement is the bit size increment for source data.
//! It must be one of:
//! - \ref UDMA_SRC_INC_8
//! - \ref UDMA_SRC_INC_16
//! - \ref UDMA_SRC_INC_32
//! - \ref UDMA_SRC_INC_NONE
//! \param pvSrcAddr is the starting address of the data to transfer.
//! \param ui32DstIncrement is the bit size increment for destination data.
//! It must be one of:
//! - \ref UDMA_DST_INC_8
//! - \ref UDMA_DST_INC_16
//! - \ref UDMA_DST_INC_32
//! - \ref UDMA_DST_INC_NONE
//! \param pvDstAddr is the starting address of the destination data.
//! \param ui32ArbSize is the arbitration size to use for the transfer task.
//! This is used to select the arbitration size in powers of 2, from 1 to 1024.
//! It must be one of:
//! - \ref UDMA_ARB_1
//! - \ref UDMA_ARB_2
//! - \ref UDMA_ARB_4
//! - ...
//! - \ref UDMA_ARB_1024
//! \param ui32Mode is the transfer mode for this task.
//! Note that normally all tasks will be one of the scatter-gather modes while the
//! last task is a task list will be AUTO or BASIC.
//! It must be one of:
//! - \ref UDMA_MODE_BASIC
//! - \ref UDMA_MODE_AUTO
//! - \ref UDMA_MODE_MEM_SCATTER_GATHER
//! - \ref UDMA_MODE_PER_SCATTER_GATHER
//!
//! \return None (this is not a function)
//
//*****************************************************************************
#define uDMATaskStructEntry(ui32TransferCount,                                \
                            ui32ItemSize,                                     \
                            ui32SrcIncrement,                                 \
                            pvSrcAddr,                                        \
                            ui32DstIncrement,                                 \
                            pvDstAddr,                                        \
                            ui32ArbSize,                                      \
                            ui32Mode)                                         \
    {                                                                         \
        (((ui32SrcIncrement) == UDMA_SRC_INC_NONE) ? (pvSrcAddr) :            \
            ((void *)(&((uint8_t *)(pvSrcAddr))[((ui32TransferCount) <<       \
                                         ((ui32SrcIncrement) >> 26)) - 1]))), \
        (((ui32DstIncrement) == UDMA_DST_INC_NONE) ? (pvDstAddr) :            \
            ((void *)(&((uint8_t *)(pvDstAddr))[((ui32TransferCount) <<       \
                                         ((ui32DstIncrement) >> 30)) - 1]))), \
        (ui32SrcIncrement) | (ui32DstIncrement) | (ui32ItemSize) |            \
        (ui32ArbSize) | (((ui32TransferCount) - 1) << 4) |                    \
        ((((ui32Mode) == UDMA_MODE_MEM_SCATTER_GATHER) ||                     \
          ((ui32Mode) == UDMA_MODE_PER_SCATTER_GATHER)) ?                     \
                (ui32Mode) | UDMA_MODE_ALT_SELECT : (ui32Mode)), 0            \
    }

//*****************************************************************************
//
// The hardware configured number of uDMA channels.
//
//*****************************************************************************
#define UDMA_NUM_CHANNELS       21

//*****************************************************************************
//
// The level of priority for the uDMA channels
//
//*****************************************************************************
#define UDMA_PRIORITY_LOW       0x00000000
#define UDMA_PRIORITY_HIGH      0x00000001

//*****************************************************************************
//
// Flags that can be passed to uDMAChannelAttributeEnable(),
// uDMAChannelAttributeDisable(), and returned from uDMAChannelAttributeGet().
//
//*****************************************************************************
#define UDMA_ATTR_USEBURST      0x00000001
#define UDMA_ATTR_ALTSELECT     0x00000002
#define UDMA_ATTR_HIGH_PRIORITY 0x00000004
#define UDMA_ATTR_REQMASK       0x00000008
#define UDMA_ATTR_ALL           0x0000000F

//*****************************************************************************
//
// DMA control modes that can be passed to uDMAChannelModeSet() and returned
// uDMAChannelModeGet().
//
//*****************************************************************************
#define UDMA_MODE_STOP          0x00000000
#define UDMA_MODE_BASIC         0x00000001
#define UDMA_MODE_AUTO          0x00000002
#define UDMA_MODE_PINGPONG      0x00000003
#define UDMA_MODE_MEM_SCATTER_GATHER                                          \
                                0x00000004
#define UDMA_MODE_PER_SCATTER_GATHER                                          \
                                0x00000006
#define UDMA_MODE_M             0x00000007  // uDMA Transfer Mode
#define UDMA_MODE_ALT_SELECT    0x00000001

//*****************************************************************************
//
// Channel configuration values that can be passed to uDMAControlSet().
//
//*****************************************************************************
#define UDMA_DST_INC_8          0x00000000
#define UDMA_DST_INC_16         0x40000000
#define UDMA_DST_INC_32         0x80000000
#define UDMA_DST_INC_NONE       0xC0000000
#define UDMA_DST_INC_M          0xC0000000  // Destination Address Increment
#define UDMA_DST_INC_S          30
#define UDMA_SRC_INC_8          0x00000000
#define UDMA_SRC_INC_16         0x04000000
#define UDMA_SRC_INC_32         0x08000000
#define UDMA_SRC_INC_NONE       0x0c000000
#define UDMA_SRC_INC_M          0x0C000000  // Source Address Increment
#define UDMA_SRC_INC_S          26
#define UDMA_SIZE_8             0x00000000
#define UDMA_SIZE_16            0x11000000
#define UDMA_SIZE_32            0x22000000
#define UDMA_SIZE_M             0x33000000  // Data Size
#define UDMA_SIZE_S             24
#define UDMA_ARB_1              0x00000000
#define UDMA_ARB_2              0x00004000
#define UDMA_ARB_4              0x00008000
#define UDMA_ARB_8              0x0000c000
#define UDMA_ARB_16             0x00010000
#define UDMA_ARB_32             0x00014000
#define UDMA_ARB_64             0x00018000
#define UDMA_ARB_128            0x0001c000
#define UDMA_ARB_256            0x00020000
#define UDMA_ARB_512            0x00024000
#define UDMA_ARB_1024           0x00028000
#define UDMA_ARB_M              0x0003C000  // Arbitration Size
#define UDMA_ARB_S              14
#define UDMA_NEXT_USEBURST      0x00000008
#define UDMA_XFER_SIZE_MAX      1024
#define UDMA_XFER_SIZE_M        0x00003FF0  // Transfer size
#define UDMA_XFER_SIZE_S        4

//*****************************************************************************
//
// Channel numbers to be passed to API functions that require a channel number
// ID.
//
//*****************************************************************************
#define UDMA_CHAN_SW_EVT0       0   // Software Event Channel 0
#define UDMA_CHAN_UART0_RX      1   // UART0 RX Data
#define UDMA_CHAN_UART0_TX      2   // UART0 RX Data
#define UDMA_CHAN_SSI0_RX       3   // SSI0 RX Data
#define UDMA_CHAN_SSI0_TX       4   // SSI0 RX Data
#define UDMA_CHAN_AUX_ADC       7   // AUX ADC event
#define UDMA_CHAN_AUX_SW        8   // AUX Software event
#define UDMA_CHAN_TIMER0_A      9   // Timer0 A event
#define UDMA_CHAN_TIMER0_B      10  // Timer0 B event
#define UDMA_CHAN_TIMER1_A      11
#define UDMA_CHAN_TIMER1_B      12
#define UDMA_CHAN_AON_PROG2     13
#define UDMA_CHAN_DMA_PROG      14
#define UDMA_CHAN_AON_RTC       15
#define UDMA_CHAN_SSI1_RX       16
#define UDMA_CHAN_SSI1_TX       17
#define UDMA_CHAN_SW_EVT1       18
#define UDMA_CHAN_SW_EVT2       19
#define UDMA_CHAN_SW_EVT3       20

//*****************************************************************************
//
// Flags to be OR'd with the channel ID to indicate if the primary or alternate
// control structure should be used.
//
//*****************************************************************************
#define UDMA_PRI_SELECT         0x00000000
#define UDMA_ALT_SELECT         0x00000020


#endif // __UDMA_H__

#ifndef __HW_TRNG_H__
#define __HW_TRNG_H__

//*****************************************************************************
//
// This section defines the register offsets of
// TRNG component
//
//*****************************************************************************
// Random Number Lower Word Readout Value
#define TRNG_O_OUT0                                                 0x00000000

// Random Number Upper Word Readout Value
#define TRNG_O_OUT1                                                 0x00000004

// Interrupt Status
#define TRNG_O_IRQFLAGSTAT                                          0x00000008

// Interrupt Mask
#define TRNG_O_IRQFLAGMASK                                          0x0000000C

// Interrupt Flag Clear
#define TRNG_O_IRQFLAGCLR                                           0x00000010

// Control
#define TRNG_O_CTL                                                  0x00000014

// Configuration 0
#define TRNG_O_CFG0                                                 0x00000018

// Alarm Control
#define TRNG_O_ALARMCNT                                             0x0000001C

// FRO Enable
#define TRNG_O_FROEN                                                0x00000020

// FRO De-tune Bit
#define TRNG_O_FRODETUNE                                            0x00000024

// Alarm Event
#define TRNG_O_ALARMMASK                                            0x00000028

// Alarm Shutdown
#define TRNG_O_ALARMSTOP                                            0x0000002C

// LFSR Readout Value
#define TRNG_O_LFSR0                                                0x00000030

// LFSR Readout Value
#define TRNG_O_LFSR1                                                0x00000034

// LFSR Readout Value
#define TRNG_O_LFSR2                                                0x00000038

// TRNG Engine Options Information
#define TRNG_O_HWOPT                                                0x00000078

// HW Version 0
#define TRNG_O_HWVER0                                               0x0000007C

// Interrupt Status After Masking
#define TRNG_O_IRQSTATMASK                                          0x00001FD8

// HW Version 1
#define TRNG_O_HWVER1                                               0x00001FE0

// Interrupt Set
#define TRNG_O_IRQSET                                               0x00001FEC

// SW Reset Control
#define TRNG_O_SWRESET                                              0x00001FF0

// Interrupt Status
#define TRNG_O_IRQSTAT                                              0x00001FF8

//*****************************************************************************
//
// Register: TRNG_O_OUT0
//
//*****************************************************************************
// Field:  [31:0] VALUE_31_0
//
// LSW of 64- bit random value. New value ready when IRQFLAGSTAT.RDY = 1.
#define TRNG_OUT0_VALUE_31_0_W                                              32
#define TRNG_OUT0_VALUE_31_0_M                                      0xFFFFFFFF
#define TRNG_OUT0_VALUE_31_0_S                                               0

//*****************************************************************************
//
// Register: TRNG_O_OUT1
//
//*****************************************************************************
// Field:  [31:0] VALUE_63_32
//
// MSW of 64-bit random value. New value ready when IRQFLAGSTAT.RDY = 1.
#define TRNG_OUT1_VALUE_63_32_W                                             32
#define TRNG_OUT1_VALUE_63_32_M                                     0xFFFFFFFF
#define TRNG_OUT1_VALUE_63_32_S                                              0

//*****************************************************************************
//
// Register: TRNG_O_IRQFLAGSTAT
//
//*****************************************************************************
// Field:    [31] NEED_CLOCK
//
// 1: Indicates that the TRNG is busy generating entropy or is in one of its
// test modes - clocks may not be turned off and the power supply voltage must
// be kept stable.
// 0: TRNG is idle and can be shut down
#define TRNG_IRQFLAGSTAT_NEED_CLOCK                                 0x80000000
#define TRNG_IRQFLAGSTAT_NEED_CLOCK_BITN                                    31
#define TRNG_IRQFLAGSTAT_NEED_CLOCK_M                               0x80000000
#define TRNG_IRQFLAGSTAT_NEED_CLOCK_S                                       31

// Field:     [1] SHUTDOWN_OVF
//
// 1: The number of FROs shut down (i.e. the number of '1' bits in the
// ALARMSTOP register) has exceeded the threshold set by ALARMCNT.SHUTDOWN_THR
//
// Writing '1' to IRQFLAGCLR.SHUTDOWN_OVF clears this bit to '0' again.
#define TRNG_IRQFLAGSTAT_SHUTDOWN_OVF                               0x00000002
#define TRNG_IRQFLAGSTAT_SHUTDOWN_OVF_BITN                                   1
#define TRNG_IRQFLAGSTAT_SHUTDOWN_OVF_M                             0x00000002
#define TRNG_IRQFLAGSTAT_SHUTDOWN_OVF_S                                      1

// Field:     [0] RDY
//
// 1: Data are available in OUT0 and OUT1.
//
// Acknowledging this state by writing '1' to IRQFLAGCLR.RDY clears this bit to
// '0'.
// If a new number is already available in the internal register of the TRNG,
// the number is directly clocked into the result register. In this case the
// status bit is asserted again, after one clock cycle.
#define TRNG_IRQFLAGSTAT_RDY                                        0x00000001
#define TRNG_IRQFLAGSTAT_RDY_BITN                                            0
#define TRNG_IRQFLAGSTAT_RDY_M                                      0x00000001
#define TRNG_IRQFLAGSTAT_RDY_S                                               0

//*****************************************************************************
//
// Register: TRNG_O_IRQFLAGMASK
//
//*****************************************************************************
// Field:     [1] SHUTDOWN_OVF
//
// 1: Allow IRQFLAGSTAT.SHUTDOWN_OVF to activate the interrupt from this
// module.
#define TRNG_IRQFLAGMASK_SHUTDOWN_OVF                               0x00000002
#define TRNG_IRQFLAGMASK_SHUTDOWN_OVF_BITN                                   1
#define TRNG_IRQFLAGMASK_SHUTDOWN_OVF_M                             0x00000002
#define TRNG_IRQFLAGMASK_SHUTDOWN_OVF_S                                      1

// Field:     [0] RDY
//
// 1: Allow IRQFLAGSTAT.RDY to activate the interrupt from this module.
#define TRNG_IRQFLAGMASK_RDY                                        0x00000001
#define TRNG_IRQFLAGMASK_RDY_BITN                                            0
#define TRNG_IRQFLAGMASK_RDY_M                                      0x00000001
#define TRNG_IRQFLAGMASK_RDY_S                                               0

//*****************************************************************************
//
// Register: TRNG_O_IRQFLAGCLR
//
//*****************************************************************************
// Field:     [1] SHUTDOWN_OVF
//
// 1: Clear IRQFLAGSTAT.SHUTDOWN_OVF.
#define TRNG_IRQFLAGCLR_SHUTDOWN_OVF                                0x00000002
#define TRNG_IRQFLAGCLR_SHUTDOWN_OVF_BITN                                    1
#define TRNG_IRQFLAGCLR_SHUTDOWN_OVF_M                              0x00000002
#define TRNG_IRQFLAGCLR_SHUTDOWN_OVF_S                                       1

// Field:     [0] RDY
//
// 1: Clear IRQFLAGSTAT.RDY.
#define TRNG_IRQFLAGCLR_RDY                                         0x00000001
#define TRNG_IRQFLAGCLR_RDY_BITN                                             0
#define TRNG_IRQFLAGCLR_RDY_M                                       0x00000001
#define TRNG_IRQFLAGCLR_RDY_S                                                0

//*****************************************************************************
//
// Register: TRNG_O_CTL
//
//*****************************************************************************
// Field: [31:16] STARTUP_CYCLES
//
// This field determines the number of samples (between 2^8 and 2^24) taken to
// gather entropy from the FROs during startup. If the written value of this
// field is zero, the number of samples is 2^24, otherwise the number of
// samples equals the written value times 2^8.
//
// 0x0000: 2^24 samples
// 0x0001: 1*2^8 samples
// 0x0002: 2*2^8 samples
// 0x0003: 3*2^8 samples
// ...
// 0x8000: 32768*2^8 samples
// 0xC000: 49152*2^8 samples
// ...
// 0xFFFF: 65535*2^8 samples
//
// This field can only be modified while TRNG_EN is 0. If 1 an update will be
// ignored.
#define TRNG_CTL_STARTUP_CYCLES_W                                           16
#define TRNG_CTL_STARTUP_CYCLES_M                                   0xFFFF0000
#define TRNG_CTL_STARTUP_CYCLES_S                                           16

// Field:    [10] TRNG_EN
//
// 0: Forces all TRNG logic back into the idle state immediately.
// 1: Starts TRNG, gathering entropy from the FROs for the number of samples
// determined by STARTUP_CYCLES.
#define TRNG_CTL_TRNG_EN                                            0x00000400
#define TRNG_CTL_TRNG_EN_BITN                                               10
#define TRNG_CTL_TRNG_EN_M                                          0x00000400
#define TRNG_CTL_TRNG_EN_S                                                  10

// Field:     [2] NO_LFSR_FB
//
// 1: Remove XNOR feedback from the main LFSR, converting it into a normal
// shift register for the XOR-ed outputs of the FROs (shifting data in on the
// LSB side). A '1' also forces the LFSR to sample continuously.
//
// This bit can only be set to '1' when TEST_MODE is also set to '1' and should
// not be used for other than test purposes
#define TRNG_CTL_NO_LFSR_FB                                         0x00000004
#define TRNG_CTL_NO_LFSR_FB_BITN                                             2
#define TRNG_CTL_NO_LFSR_FB_M                                       0x00000004
#define TRNG_CTL_NO_LFSR_FB_S                                                2

// Field:     [1] TEST_MODE
//
// 1: Enables access to the TESTCNT and LFSR0/LFSR1/LFSR2 registers (the latter
// are automatically cleared before enabling access)  and keeps
// IRQFLAGSTAT.NEED_CLOCK at '1'.
//
// This bit shall not be used unless you need to change the LFSR seed prior to
// creating a new random value. All other testing is done external to register
// control.
#define TRNG_CTL_TEST_MODE                                          0x00000002
#define TRNG_CTL_TEST_MODE_BITN                                              1
#define TRNG_CTL_TEST_MODE_M                                        0x00000002
#define TRNG_CTL_TEST_MODE_S                                                 1

//*****************************************************************************
//
// Register: TRNG_O_CFG0
//
//*****************************************************************************
// Field: [31:16] MAX_REFILL_CYCLES
//
// This field determines the maximum number of samples (between 2^8 and 2^24)
// taken to re-generate entropy from the FROs after reading out a 64 bits
// random number. If the written value of this field is zero, the number of
// samples is 2^24, otherwise the number of samples equals the written value
// times 2^8.
//
// 0x0000: 2^24 samples
// 0x0001: 1*2^8 samples
// 0x0002: 2*2^8 samples
// 0x0003: 3*2^8 samples
// ...
// 0x8000: 32768*2^8 samples
// 0xC000: 49152*2^8 samples
// ...
// 0xFFFF: 65535*2^8 samples
//
// This field can only be modified while CTL.TRNG_EN is 0.
#define TRNG_CFG0_MAX_REFILL_CYCLES_W                                       16
#define TRNG_CFG0_MAX_REFILL_CYCLES_M                               0xFFFF0000
#define TRNG_CFG0_MAX_REFILL_CYCLES_S                                       16

// Field:  [11:8] SMPL_DIV
//
// This field directly controls the number of clock cycles between samples
// taken from the FROs. Default value 0 indicates that samples are taken every
// clock cycle,
// maximum value 0xF takes one sample every 16 clock cycles.
// This field must be set to a value such that the slowest FRO (even under
// worst-case
// conditions) has a cycle time less than twice the sample period.
//
// This field can only be modified while CTL.TRNG_EN is '0'.
#define TRNG_CFG0_SMPL_DIV_W                                                 4
#define TRNG_CFG0_SMPL_DIV_M                                        0x00000F00
#define TRNG_CFG0_SMPL_DIV_S                                                 8

// Field:   [7:0] MIN_REFILL_CYCLES
//
// This field determines the minimum number of samples (between 2^6 and 2^14)
// taken to re-generate entropy from the FROs after reading out a 64 bits
// random number. If the value of this field is zero, the number of samples is
// fixed to the value determined by the MAX_REFILL_CYCLES field, otherwise the
// minimum number of samples equals the written value times 64 (which can be up
// to 2^14). To ensure same entropy in all generated random numbers the value 0
// should be used. Then MAX_REFILL_CYCLES controls the minimum refill interval.
// The number of samples defined here cannot be higher than the number defined
// by the 'max_refill_cycles' field (i.e. that field takes precedence). No
// random value will be created if min refill > max refill.
//
// This field can only be modified while CTL.TRNG_EN = 0.
//
// 0x00: Minimum samples = MAX_REFILL_CYCLES (all numbers have same entropy)
// 0x01: 1*2^6 samples
// 0x02: 2*2^6 samples
// ...
// 0xFF: 255*2^6 samples
#define TRNG_CFG0_MIN_REFILL_CYCLES_W                                        8
#define TRNG_CFG0_MIN_REFILL_CYCLES_M                               0x000000FF
#define TRNG_CFG0_MIN_REFILL_CYCLES_S                                        0

//*****************************************************************************
//
// Register: TRNG_O_ALARMCNT
//
//*****************************************************************************
// Field: [29:24] SHUTDOWN_CNT
//
// Read-only, indicates the number of '1' bits in ALARMSTOP register.
// The maximum value equals the number of FROs.
#define TRNG_ALARMCNT_SHUTDOWN_CNT_W                                         6
#define TRNG_ALARMCNT_SHUTDOWN_CNT_M                                0x3F000000
#define TRNG_ALARMCNT_SHUTDOWN_CNT_S                                        24

// Field: [20:16] SHUTDOWN_THR
//
// Threshold setting for generating IRQFLAGSTAT.SHUTDOWN_OVF interrupt. The
// interrupt is triggered when SHUTDOWN_CNT value exceeds this bit field.
#define TRNG_ALARMCNT_SHUTDOWN_THR_W                                         5
#define TRNG_ALARMCNT_SHUTDOWN_THR_M                                0x001F0000
#define TRNG_ALARMCNT_SHUTDOWN_THR_S                                        16

// Field:   [7:0] ALARM_THR
//
// Alarm detection threshold for the repeating pattern detectors on each FRO.
// An FRO 'alarm event' is declared when a repeating pattern (of up to four
// samples length) is detected continuously for the number of samples defined
// by this field's value. Reset value 0xFF should keep the number of 'alarm
// events' to a manageable level.
#define TRNG_ALARMCNT_ALARM_THR_W                                            8
#define TRNG_ALARMCNT_ALARM_THR_M                                   0x000000FF
#define TRNG_ALARMCNT_ALARM_THR_S                                            0

//*****************************************************************************
//
// Register: TRNG_O_FROEN
//
//*****************************************************************************
// Field:  [23:0] FRO_MASK
//
// Enable bits for the individual FROs. A '1' in bit [n] enables FRO 'n'.
// Default state is all '1's to enable all FROs after power-up. Note that they
// are not actually started up before the CTL.TRNG_EN bit  is set to '1'.
//
// Bits are automatically forced to '0' here (and cannot be written to '1')
// while the corresponding bit in  ALARMSTOP.FRO_FLAGS has value '1'.
#define TRNG_FROEN_FRO_MASK_W                                               24
#define TRNG_FROEN_FRO_MASK_M                                       0x00FFFFFF
#define TRNG_FROEN_FRO_MASK_S                                                0

//*****************************************************************************
//
// Register: TRNG_O_FRODETUNE
//
//*****************************************************************************
// Field:  [23:0] FRO_MASK
//
// De-tune bits for the individual FROs. A '1' in bit [n] lets FRO 'n' run
// approximately 5% faster. The value of one of these bits may only be changed
// while the corresponding FRO is turned off (by temporarily writing a '0' in
// the corresponding
// bit of the FROEN.FRO_MASK register).
#define TRNG_FRODETUNE_FRO_MASK_W                                           24
#define TRNG_FRODETUNE_FRO_MASK_M                                   0x00FFFFFF
#define TRNG_FRODETUNE_FRO_MASK_S                                            0

//*****************************************************************************
//
// Register: TRNG_O_ALARMMASK
//
//*****************************************************************************
// Field:  [23:0] FRO_MASK
//
// Logging bits for the 'alarm events' of individual FROs. A '1' in bit [n]
// indicates FRO 'n' experienced an 'alarm event'.
#define TRNG_ALARMMASK_FRO_MASK_W                                           24
#define TRNG_ALARMMASK_FRO_MASK_M                                   0x00FFFFFF
#define TRNG_ALARMMASK_FRO_MASK_S                                            0

//*****************************************************************************
//
// Register: TRNG_O_ALARMSTOP
//
//*****************************************************************************
// Field:  [23:0] FRO_FLAGS
//
// Logging bits for the 'alarm events' of individual FROs. A '1' in bit [n]
// indicates FRO 'n' experienced more than one 'alarm event' in quick
// succession and has been turned off. A '1' in this field forces the
// corresponding bit in FROEN.FRO_MASK to '0'.
#define TRNG_ALARMSTOP_FRO_FLAGS_W                                          24
#define TRNG_ALARMSTOP_FRO_FLAGS_M                                  0x00FFFFFF
#define TRNG_ALARMSTOP_FRO_FLAGS_S                                           0

//*****************************************************************************
//
// Register: TRNG_O_LFSR0
//
//*****************************************************************************
// Field:  [31:0] LFSR_31_0
//
// Bits [31:0] of the main entropy accumulation LFSR. Register can only be
// accessed when CTL.TEST_MODE  = 1.
// Register contents will be cleared to zero before access is enabled.
#define TRNG_LFSR0_LFSR_31_0_W                                              32
#define TRNG_LFSR0_LFSR_31_0_M                                      0xFFFFFFFF
#define TRNG_LFSR0_LFSR_31_0_S                                               0

//*****************************************************************************
//
// Register: TRNG_O_LFSR1
//
//*****************************************************************************
// Field:  [31:0] LFSR_63_32
//
// Bits [63:32] of the main entropy accumulation LFSR. Register can only be
// accessed when CTL.TEST_MODE = 1.
// Register contents will be cleared to zero before access is enabled.
#define TRNG_LFSR1_LFSR_63_32_W                                             32
#define TRNG_LFSR1_LFSR_63_32_M                                     0xFFFFFFFF
#define TRNG_LFSR1_LFSR_63_32_S                                              0

//*****************************************************************************
//
// Register: TRNG_O_LFSR2
//
//*****************************************************************************
// Field:  [16:0] LFSR_80_64
//
// Bits [80:64] of the main entropy accumulation LFSR. Register can only be
// accessed when CTL.TEST_MODE = 1.
// Register contents will be cleared to zero before access is enabled.
#define TRNG_LFSR2_LFSR_80_64_W                                             17
#define TRNG_LFSR2_LFSR_80_64_M                                     0x0001FFFF
#define TRNG_LFSR2_LFSR_80_64_S                                              0

//*****************************************************************************
//
// Register: TRNG_O_HWOPT
//
//*****************************************************************************
// Field:  [11:6] NR_OF_FROS
//
// Number of FROs implemented in this TRNG, value 24 (decimal).
#define TRNG_HWOPT_NR_OF_FROS_W                                              6
#define TRNG_HWOPT_NR_OF_FROS_M                                     0x00000FC0
#define TRNG_HWOPT_NR_OF_FROS_S                                              6

//*****************************************************************************
//
// Register: TRNG_O_HWVER0
//
//*****************************************************************************
// Field: [27:24] HW_MAJOR_VER
//
// 4 bits binary encoding of the major hardware revision number.
#define TRNG_HWVER0_HW_MAJOR_VER_W                                           4
#define TRNG_HWVER0_HW_MAJOR_VER_M                                  0x0F000000
#define TRNG_HWVER0_HW_MAJOR_VER_S                                          24

// Field: [23:20] HW_MINOR_VER
//
// 4 bits binary encoding of the minor hardware revision number.
#define TRNG_HWVER0_HW_MINOR_VER_W                                           4
#define TRNG_HWVER0_HW_MINOR_VER_M                                  0x00F00000
#define TRNG_HWVER0_HW_MINOR_VER_S                                          20

// Field: [19:16] HW_PATCH_LVL
//
// 4 bits binary encoding of the hardware patch level, initial release will
// carry value zero.
#define TRNG_HWVER0_HW_PATCH_LVL_W                                           4
#define TRNG_HWVER0_HW_PATCH_LVL_M                                  0x000F0000
#define TRNG_HWVER0_HW_PATCH_LVL_S                                          16

// Field:  [15:8] EIP_NUM_COMPL
//
// Bit-by-bit logic complement of bits [7:0]. This TRNG gives 0xB4.
#define TRNG_HWVER0_EIP_NUM_COMPL_W                                          8
#define TRNG_HWVER0_EIP_NUM_COMPL_M                                 0x0000FF00
#define TRNG_HWVER0_EIP_NUM_COMPL_S                                          8

// Field:   [7:0] EIP_NUM
//
// 8 bits binary encoding of the module number. This TRNG gives 0x4B.
#define TRNG_HWVER0_EIP_NUM_W                                                8
#define TRNG_HWVER0_EIP_NUM_M                                       0x000000FF
#define TRNG_HWVER0_EIP_NUM_S                                                0

//*****************************************************************************
//
// Register: TRNG_O_IRQSTATMASK
//
//*****************************************************************************
// Field:     [1] SHUTDOWN_OVF
//
// Shutdown Overflow (result of IRQFLAGSTAT.SHUTDOWN_OVF AND'ed with
// IRQFLAGMASK.SHUTDOWN_OVF)
#define TRNG_IRQSTATMASK_SHUTDOWN_OVF                               0x00000002
#define TRNG_IRQSTATMASK_SHUTDOWN_OVF_BITN                                   1
#define TRNG_IRQSTATMASK_SHUTDOWN_OVF_M                             0x00000002
#define TRNG_IRQSTATMASK_SHUTDOWN_OVF_S                                      1

// Field:     [0] RDY
//
// New random value available (result of IRQFLAGSTAT.RDY AND'ed with
// IRQFLAGMASK.RDY)
#define TRNG_IRQSTATMASK_RDY                                        0x00000001
#define TRNG_IRQSTATMASK_RDY_BITN                                            0
#define TRNG_IRQSTATMASK_RDY_M                                      0x00000001
#define TRNG_IRQSTATMASK_RDY_S                                               0

//*****************************************************************************
//
// Register: TRNG_O_HWVER1
//
//*****************************************************************************
// Field:   [7:0] REV
//
// The revision number of this module is Rev 2.0.
#define TRNG_HWVER1_REV_W                                                    8
#define TRNG_HWVER1_REV_M                                           0x000000FF
#define TRNG_HWVER1_REV_S                                                    0

//*****************************************************************************
//
// Register: TRNG_O_IRQSET
//
//*****************************************************************************
//*****************************************************************************
//
// Register: TRNG_O_SWRESET
//
//*****************************************************************************
// Field:     [0] RESET
//
// Write '1' to soft reset , reset will be low for 4-5 clock cycles. Poll to 0
// for reset to be completed.
#define TRNG_SWRESET_RESET                                          0x00000001
#define TRNG_SWRESET_RESET_BITN                                              0
#define TRNG_SWRESET_RESET_M                                        0x00000001
#define TRNG_SWRESET_RESET_S                                                 0

//*****************************************************************************
//
// Register: TRNG_O_IRQSTAT
//
//*****************************************************************************
// Field:     [0] STAT
//
// TRNG Interrupt status. OR'ed version of IRQFLAGSTAT.SHUTDOWN_OVF and
// IRQFLAGSTAT.RDY
#define TRNG_IRQSTAT_STAT                                           0x00000001
#define TRNG_IRQSTAT_STAT_BITN                                               0
#define TRNG_IRQSTAT_STAT_M                                         0x00000001
#define TRNG_IRQSTAT_STAT_S                                                  0


#endif // __HW_TRNG_H__

#ifndef __TRNG_H__
#define __TRNG_H__

void
TRNGReset (void) {
	HWREG(TRNG_BASE + TRNG_O_SWRESET) = 1;
	while (HWREG(TRNG_BASE + TRNG_O_SWRESET) == 1);
}

INLINE_FUNCTION void
TRNGEnable (void) {
    HWREGBITW(TRNG_BASE + TRNG_O_CTL, TRNG_CTL_TRNG_EN_BITN) = 1;
}

INLINE_FUNCTION void
TRNGDisable (void) {
    HWREGBITW(TRNG_BASE + TRNG_O_CTL, TRNG_CTL_TRNG_EN_BITN) = 0;
}

INLINE_FUNCTION void
TRNGConfigure (uint32_t ui32MinSamplesPerCycle,
              uint32_t ui32MaxSamplesPerCycle,
              uint32_t ui32ClocksPerSample)
{
    uint32_t ui32Val;

    // Make sure the TRNG is disabled.
    ui32Val = HWREG(TRNG_BASE + TRNG_O_CTL) & ~TRNG_CTL_TRNG_EN;
    HWREG(TRNG_BASE + TRNG_O_CTL) = ui32Val;

    // Configure the startup number of samples.
    ui32Val &= ~TRNG_CTL_STARTUP_CYCLES_M;
    ui32Val |= ((( ui32MaxSamplesPerCycle >> 8 ) << TRNG_CTL_STARTUP_CYCLES_S ) & TRNG_CTL_STARTUP_CYCLES_M );
    HWREG(TRNG_BASE + TRNG_O_CTL) = ui32Val;

    // Configure the minimum and maximum number of samples pr generated number
    // and the number of clocks per sample.
    HWREG(TRNG_BASE + TRNG_O_CFG0) = (
        ((( ui32MaxSamplesPerCycle >> 8 ) << TRNG_CFG0_MAX_REFILL_CYCLES_S ) & TRNG_CFG0_MAX_REFILL_CYCLES_M ) |
        ((( ui32ClocksPerSample         ) << TRNG_CFG0_SMPL_DIV_S          ) & TRNG_CFG0_SMPL_DIV_M          ) |
        ((( ui32MinSamplesPerCycle >> 6 ) << TRNG_CFG0_MIN_REFILL_CYCLES_S ) & TRNG_CFG0_MIN_REFILL_CYCLES_M )   );
}


#endif  // __TRNG_H__

#ifdef IMPLEMENT_IO_CPU

//
// 
//

void
GPIO_setOutputEnableDio (uint32_t dioNumber,uint32_t outputEnableValue) {
	HWREGBITW( GPIO_BASE + GPIO_O_DOE31_0, dioNumber ) = outputEnableValue;
}


void
IOCPortConfigureSet (
	uint32_t ui32IOId,uint32_t ui32PortId,uint32_t ui32IOConfig
) {
	uint32_t ui32Reg = IOC_BASE + ( ui32IOId << 2 );
	HWREG(ui32Reg) = ui32IOConfig | ui32PortId;
}

uint32_t
IOCPortConfigureGet (uint32_t ui32IOId) {
	uint32_t ui32Reg = IOC_BASE + ( ui32IOId << 2 );
	return HWREG(ui32Reg);
}

void
IOCIOPortPullSet (uint32_t ui32IOId,uint32_t ui32Pull) {
	uint32_t ui32IOReg;
	uint32_t ui32Config;

	ui32IOReg = IOC_BASE + ( ui32IOId << 2 );
	ui32Config = HWREG(ui32IOReg);
	ui32Config &= ~IOC_IOCFG0_PULL_CTL_M;
	HWREG(ui32IOReg) = ui32Config | ui32Pull;
}

void
IOCPinTypeGpioOutput (uint32_t ui32IOId) {
	IOCPortConfigureSet(ui32IOId, IOC_PORT_GPIO, IOC_STD_OUTPUT);
	GPIO_setOutputEnableDio(ui32IOId, GPIO_OUTPUT_ENABLE);
}

void
IOCPinTypeGpioInput(uint32_t ui32IOId) {
	IOCPortConfigureSet(ui32IOId, IOC_PORT_GPIO, IOC_STD_INPUT);
	GPIO_setOutputEnableDio(ui32IOId, GPIO_OUTPUT_DISABLE);
}

// Read in existing value in IOCFG register and update with supplied mux value
void
IOCPinSetIoCfgMux(uint32_t ui32IOId,uint32_t mux) {
	uint32_t tmpConfig;
	tmpConfig = HWREG (IOC_BASE + IOC_O_IOCFG0 + 4 * ui32IOId);
	tmpConfig &= ~IOC_IOCFG0_PORT_ID_M;
	tmpConfig |= mux & IOC_IOCFG0_PORT_ID_M;
	HWREG(IOC_BASE + IOC_O_IOCFG0 + 4 * ui32IOId) = tmpConfig;
}

uint32_t
PRCMPowerDomainStatus(uint32_t ui32Domains)
{
    bool bStatus;
    uint32_t ui32StatusRegister0;
    uint32_t ui32StatusRegister1;


    bStatus = true;
    ui32StatusRegister0 = HWREG(PRCM_BASE + PRCM_O_PDSTAT0);
    ui32StatusRegister1 = HWREG(PRCM_BASE + PRCM_O_PDSTAT1);

    // Return the correct power status.
    if(ui32Domains & PRCM_DOMAIN_RFCORE)
    {
       bStatus = bStatus &&
                 ((ui32StatusRegister0 & PRCM_PDSTAT0_RFC_ON) ||
                  (ui32StatusRegister1 & PRCM_PDSTAT1_RFC_ON));
    }
    if(ui32Domains & PRCM_DOMAIN_SERIAL)
    {
        bStatus = bStatus && (ui32StatusRegister0 & PRCM_PDSTAT0_SERIAL_ON);
    }
    if(ui32Domains & PRCM_DOMAIN_PERIPH)
    {
        bStatus = bStatus && (ui32StatusRegister0 & PRCM_PDSTAT0_PERIPH_ON);
    }

    // Return the status.
    return (bStatus ? PRCM_DOMAIN_POWER_ON : PRCM_DOMAIN_POWER_OFF);
}

void
PRCMPowerDomainOn(uint32_t ui32Domains)
{
    // Assert the request to power on the right domains.
    if(ui32Domains & PRCM_DOMAIN_RFCORE)
    {
        HWREG(PRCM_BASE + PRCM_O_PDCTL0RFC   ) = 1;
    }
    if(ui32Domains & PRCM_DOMAIN_SERIAL)
    {
        HWREG(PRCM_BASE + PRCM_O_PDCTL0SERIAL) = 1;
    }
    if(ui32Domains & PRCM_DOMAIN_PERIPH)
    {
        HWREG(PRCM_BASE + PRCM_O_PDCTL0PERIPH) = 1;
    }
    if(ui32Domains & PRCM_DOMAIN_VIMS)
    {
        HWREG(PRCM_BASE + PRCM_O_PDCTL1VIMS  ) = 1;
    }
    if(ui32Domains & PRCM_DOMAIN_CPU)
    {
        HWREG(PRCM_BASE + PRCM_O_PDCTL1CPU   ) = 1;
    }
}
void
PRCMPowerDomainOff(uint32_t ui32Domains)
{
    // Assert the request to power off the right domains.
    if(ui32Domains & PRCM_DOMAIN_RFCORE)
    {
        HWREG(PRCM_BASE + PRCM_O_PDCTL0RFC   ) = 0;
    }
    if(ui32Domains & PRCM_DOMAIN_SERIAL)
    {
        HWREG(PRCM_BASE + PRCM_O_PDCTL0SERIAL) = 0;
    }
    if(ui32Domains & PRCM_DOMAIN_PERIPH)
    {
        HWREG(PRCM_BASE + PRCM_O_PDCTL0PERIPH) = 0;
    }
    if(ui32Domains & PRCM_DOMAIN_VIMS)
    {
        // Write bits ui32Domains[17:16] to the VIMS_MODE alias register.
        // PRCM_DOMAIN_VIMS sets VIMS_MODE=0b00, PRCM_DOMAIN_VIMS_OFF_NO_WAKEUP sets VIMS_MODE=0b10.
        HWREG(PRCM_BASE + PRCM_O_PDCTL1VIMS  ) = ( ui32Domains >> 16 ) & 3;
    }
    if(ui32Domains & PRCM_DOMAIN_CPU)
    {
        HWREG(PRCM_BASE + PRCM_O_PDCTL1CPU   ) = 0;
    }
}

void
PRCMLoadSet(void) {
	HWREG(PRCM_NONBUF_BASE + PRCM_O_CLKLOADCTL) = PRCM_CLKLOADCTL_LOAD;
}

// Run mode registers
static const uint32_t g_pui32RCGCRegs[] =
{
    PRCM_O_GPTCLKGR,
    PRCM_O_SSICLKGR,
    PRCM_O_UARTCLKGR,
    PRCM_O_I2CCLKGR,
    PRCM_O_SECDMACLKGR,
    PRCM_O_GPIOCLKGR,
    PRCM_O_I2SCLKGR
};
#define PRCM_PERIPH_INDEX(a)  (((a) >> 8) & 0xf)
#define PRCM_PERIPH_MASKBIT(a) (0x00000001 << ((a) & 0xf))

//
// Enable module (power domain) in Run Mode.
//
void
PRCMPeripheralRunEnable (uint32_t ui32Peripheral) {
	HWREG (PRCM_BASE + g_pui32RCGCRegs[PRCM_PERIPH_INDEX(ui32Peripheral)]) |= (
		PRCM_PERIPH_MASKBIT(ui32Peripheral)
	);
}

#endif /* IMPLEMENT_IO_CPU */
#endif
/******************************************************************************
*  simplelink_cc13x2_26x2_sdk_3_40_00_02 source
*
* Copyright (c) 2015 - 2017, Texas Instruments Incorporated
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* 1) Redistributions of source code must retain the above copyright notice,
*    this list of conditions and the following disclaimer.
*
* 2) Redistributions in binary form must reproduce the above copyright notice,
*    this list of conditions and the following disclaimer in the documentation
*    and/or other materials provided with the distribution.
*
* 3) Neither the name of the ORGANIZATION nor the names of its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
*
******************************************************************************/

